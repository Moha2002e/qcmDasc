
1. Bases Th√©oriques & Mod√®le TCP/IP (Pages 1-3)
Le Mod√®le en 4 Couches
Contrairement au mod√®le OSI (7 couches), le mod√®le utilis√© ici en comporte 4 :
1.	Application : HTTP, FTP, DNS, SMTP...
2.	Transport : TCP, UDP.
3.	Internet : IP.
4.	H√¥te-R√©seau : Ethernet, Wi-Fi...

TCP vs UDP (Comparatif technique)
Crit√®re	TCP (Transport Control Protocol)	UDP (User Datagram Protocol)
Connexion	Orient√© connexion (Handshake avant √©change).	Non connect√© (Envoi direct).
Fiabilit√©	Fiable (Garantie d'arriv√©e et d'ordre).	Non fiable (Perte et d√©sordre possibles).
Type de transfert	Par Flot (Stream), comme un tuyau continu.	Par Paquets (Datagrammes).

Adresses et Ports
‚Ä¢	Adresse IP (32 bits) : Identifie la machine (l'h√¥te).
‚Ä¢	Port (16 bits) : Identifie l'application (le processus) sur la machine.
o	Plage : 0 √† 65535.
o	Ports R√©serv√©s (0-1023) :
ÔÇß	HTTP : 80
ÔÇß	FTP : 20 (data) et 21 (commande)
ÔÇß	SSH : 22
ÔÇß	Telnet : 23
ÔÇß	SMTP : 25
üö® ZONE PI√àGE QCM
‚Ä¢	Un num√©ro de port est cod√© sur 16 bits (pas 32).
‚Ä¢	Une adresse IP identifie une machine, mais √ßa ne suffit pas pour communiquer avec un programme : il faut IP + Port = Socket.
‚Ä¢	TCP assure l'ordre des paquets, UDP non.








2. Adresses IP en Java : InetAddress (Pages 3-4)
Cette classe repr√©sente une adresse IP (v4 ou v6).

Instanciation (Factory Methods)
La classe n'a PAS de constructeur public. On utilise des m√©thodes statiques :
1.	InetAddress.getLocalHost() : Retourne l'IP de la machine locale.
o	Exemple de r√©sultat : moon/192.168.228.167 (Nom/IP).
2.	InetAddress.getByName(String host) : Retourne l'IP d'une machine distante (r√©solution DNS).

M√©thodes d'instance (Une fois l'objet obtenu)
‚Ä¢	getHostName() : Retourne le nom de la machine (String).
‚Ä¢	getHostAddress() : Retourne l'IP sous forme textuelle (ex: "192.168.1.1").
‚Ä¢	getAddress() : Retourne l'IP sous forme de tableau de byte[] (ordre r√©seau).
‚Ä¢	isMulticastAddress() : Retourne true si c'est une adresse de classe D (Multicast).

Sous-classes
‚Ä¢	Inet4Address (IPv4)
‚Ä¢	Inet6Address (IPv6)

üö® ZONE PI√àGE QCM
‚Ä¢	Peut-on faire new InetAddress() ? NON.
‚Ä¢	getByName peut lever l'exception UnknownHostException (si le domaine n'existe pas).
‚Ä¢	La m√©thode getAddress() renvoie des byte sign√©s (en Java les bytes vont de -128 √† 127), attention √† la conversion si on veut afficher 0-255.

3. Communication TCP (Mode Connect√©) (Pages 5-7)
C√¥t√© Serveur : ServerSocket

Permet d'attendre les clients.
‚Ä¢	Constructeurs :
o	ServerSocket(int port) : √âcoute sur ce port. Limite la file d'attente √† 50 connexions par d√©faut.
o	ServerSocket(int port, int backlog) : Permet de changer la limite de 50.
o	ServerSocket(int port, int backlog, InetAddress bindAddr) : Pour n'√©couter que sur une carte r√©seau pr√©cise (IP locale sp√©cifique).
‚Ä¢	M√©thode Cl√© : accept().
o	Elle est BLOQUANTE.
o	Elle retourne un objet Socket quand un client arrive.
‚Ä¢	Timeout : setSoTimeout(int ms). Si activ√©, accept() l√®ve SocketTimeoutException si personne ne vient apr√®s le d√©lai.





C√¥t√© Client : Socket
Permet de se connecter.
‚Ä¢	Constructeur : Socket(String host, int port).
o	L'appel de ce constructeur tente imm√©diatement la connexion. C'est bloquant tant que la connexion n'est pas faite.
‚Ä¢	M√©thodes d'info :
o	getPort() / getInetAddress() : Infos du Distant (Serveur).
o	getLocalPort() / getLocalAddress() : Infos du Local (Client).

üö® ZONE PI√àGE QCM
‚Ä¢	ServerSocket sert uniquement √† attendre (accept). Pour discuter ensuite, on utilise la Socket retourn√©e par accept.
‚Ä¢	La limite par d√©faut de la file d'attente (backlog) du ServerSocket est 50.
‚Ä¢	Si on instancie new Socket(...) et que le serveur n'est pas lanc√© -> ConnectException.
‚Ä¢	setSoTimeout doit √™tre appel√© avant accept().

4. Transfert de Donn√©es (Pages 8-12)
Une fois la connexion √©tablie, on utilise des Flux (Streams) sur la Socket.
‚Ä¢	getInputStream() : Pour lire.
‚Ä¢	getOutputStream() : Pour √©crire.

Les 3 Niveaux de Flux

1. Types Primitifs (DataInputStream / DataOutputStream)
‚Ä¢	Permet d'envoyer : int, double, boolean, String (UTF).
‚Ä¢	Exemple : writeInt(12) -> readInt().
‚Ä¢	Ordre : Il faut lire exactement dans le m√™me ordre qu'on a √©crit.
2. Objets (ObjectInputStream / ObjectOutputStream) - S√©rialisation
‚Ä¢	Permet d'envoyer des instances de classes Java.
‚Ä¢	Condition absolue : La classe doit impl√©menter java.io.Serializable.
‚Ä¢	M√©thodes : writeObject(obj) -> readObject().
‚Ä¢	Cast : Il faut caster l'objet √† la r√©ception : (Donnee) ois.readObject().
3. Texte (BufferedReader / BufferedWriter)
‚Ä¢	Utilise InputStreamReader / OutputStreamWriter pour convertir les bytes en caract√®res (charset).
‚Ä¢	Lecture : readLine() (lit jusqu'au saut de ligne).
‚Ä¢	√âcriture : write(), newLine().
‚Ä¢	Flush : bw.flush() est obligatoire pour forcer l'envoi des donn√©es rest√©es dans le tampon (buffer).

üö® ZONE PI√àGE QCM
‚Ä¢	Si on oublie flush() avec un BufferedWriter, rien ne part sur le r√©seau.
‚Ä¢	Si une classe n'est pas Serializable, writeObject lance NotSerializableException.
‚Ä¢	L'ordre de cr√©ation des flux est parfois important (cr√©er ObjectOutputStream avant ObjectInputStream pour l'en-t√™te, bien que le PDF ne s'attarde pas sur ce bug sp√©cifique de Java, c'est bon √† savoir).

5. Communication Java <-> C (Bas niveau) (Pages 13-16)
Quand on communique avec du C, on ne peut pas utiliser la s√©rialisation Java. On √©change des Bytes.

Le probl√®me de la fin de message
En TCP (flux continu), comment savoir o√π finit le message ?

Solution 1 : D√©limiteurs (Fin de trame)
‚Ä¢	On ajoute des caract√®res sp√©ciaux √† la fin (ex: $%).
‚Ä¢	Le r√©cepteur lit octet par octet jusqu'√† trouver $%.
‚Ä¢	Inconv√©nient : Il faut lire byte par byte (lent).
Solution 2 : En-t√™te de taille (Header)
‚Ä¢	On envoie d'abord la taille (N) du message (souvent sous forme de cha√Æne de caract√®res pour simplifier la lecture en C).
‚Ä¢	Puis on lit N bytes.

üö® ZONE PI√àGE QCM
‚Ä¢	readByte() est bloquant s'il n'y a pas de donn√©es.
‚Ä¢	En C, les cha√Ænes finissent par \0, pas en Java.
‚Ä¢	La communication inter-langage se fait toujours au niveau Byte (Socket pure).

6. Architecture Serveur G√©n√©rique Multi-Threads (Pages 17-34)
C'est le c≈ìur complexe du cours. Objectif : Un serveur qui g√®re N clients et dont on peut changer le protocole sans changer le code serveur.

Les Composants (Interfaces)
1.	Requete / Reponse : Interfaces h√©ritant de Serializable.
2.	Protocole : Interface avec la m√©thode :
o	Reponse TraiteRequete(Requete r, Socket s) throws FinConnexionException.
3.	FinConnexionException : Exception lanc√©e par le protocole pour dire "Le client veut partir" (ex: LOGOUT). Elle peut contenir une derni√®re r√©ponse.
4.	Logger : Interface pour afficher les traces (Console ou GUI).

Les Threads
1.	ThreadServeur :
o	Boucle infinie sur accept().
o	Ne traite jamais les donn√©es. Il passe la socket au ThreadClient.
2.	ThreadClient :
o	Re√ßoit la socket.
o	Boucle : readObject (Requ√™te) -> TraiteRequete (Protocole) -> writeObject (R√©ponse).
o	G√®re la fermeture propre de la socket dans le finally.





Mod√®le 1 : √Ä la demande ("On Demand")
‚Ä¢	Principe : 1 Client arrive = 1 new ThreadClient() cr√©√©. Le client part = Thread meurt.
‚Ä¢	Code Serveur : while(true) { socket = accept(); new ThreadClient(..., socket).start(); }
‚Ä¢	Code Client : Constructeur re√ßoit directement la socket.
‚Ä¢	Inconv√©nient : Risque de saturation m√©moire (Denial of Service) si trop de clients.

Mod√®le 2 : En Pool ("Producteur/Consommateur")
‚Ä¢	Principe : On cr√©e X threads au d√©marrage. Ils attendent du travail.
‚Ä¢	La File d'Attente (FileAttente) :
o	C'est un Moniteur (m√©thodes synchronized).
o	addConnexion(Socket s) : Ajoute socket + notify().
o	getConnexion() : while(empty) wait(), puis retourne socket.
‚Ä¢	ThreadServeur Pool : accept() -> ajoute dans la file d'attente.
‚Ä¢	ThreadClient Pool : Boucle infinie : Demande socket √† la file -> Traite le client -> Revient demander une socket.
‚Ä¢	Gestion de groupe : Utilise ThreadGroup pour pouvoir interrompre tous les threads du pool d'un coup via interrupt().

üö® ZONE PI√àGE QCM
‚Ä¢	Dans le mod√®le Pool, le ThreadServeur ne cr√©e pas de threads √† chaque connexion, il d√©pose juste la socket dans la liste.
‚Ä¢	C'est la m√©thode getConnexion qui est bloquante (wait) pour les ouvriers s'il n'y a pas de client.
‚Ä¢	notify() r√©veille un thread arbitraire, notifyAll() tous. Ici notify() suffit car un seul thread prend la socket.
‚Ä¢	activeCount() sur un ThreadGroup donne une estimation, pas un chiffre exact (vu dans le chap pr√©c√©dent mais rappel√© ici).

7. Exemple LILOC & Interface Graphique (Pages 35-46)

Protocole LILOC (Login In Login Out Calcul)
‚Ä¢	Utilise instanceof pour savoir quel type de requ√™te arrive (RequeteLOGIN, RequeteCALCUL...).
‚Ä¢	Stocke les clients connect√©s dans une HashMap<Login, Socket>.
‚Ä¢	S√©curit√© : V√©rifie login/pass dans une autre Map.










Le Probl√®me de l'EDT (Event Dispatch Thread)

En Swing/AWT, un seul thread g√®re l'affichage et les clics.
‚Ä¢	L'Erreur fatale : Faire ssocket.accept() ou lire le r√©seau directement dans le code d'un bouton (actionPerformed).
‚Ä¢	La Cons√©quence : L'interface G√àLE (plus de rafra√Æchissement, plus de clic possible) tant que l'op√©ration r√©seau n'est pas finie.
‚Ä¢	La Solution : Le ThreadServeur doit √™tre lanc√© via start() pour tourner en parall√®le. La fen√™tre Swing impl√©mente souvent l'interface Logger pour recevoir les messages du serveur via Trace().

üö® ZONE PI√àGE QCM
‚Ä¢	Si on met Thread.sleep(10000) ou un accept() dans un ActionListener d'un bouton, la fen√™tre devient toute blanche/grise (freeze).
‚Ä¢	Le serveur g√©n√©rique ne conna√Æt pas Swing, il parle via l'interface Logger. C'est la fen√™tre Swing qui impl√©mente Logger et met √† jour la JTable.

8. Code / Pi√®ges (Extraits & Astuces)


Concept	Pi√®ge / Attention	Mini-Exemple	
ServerSocket / Socket	accept() bloquant ‚Üí ne jamais mettre dans l‚ÄôEDT. File d‚Äôattente par d√©faut = 50. Socket(host, port) bloque ou ConnectException.	ServerSocket server = new ServerSocket(5000); Socket client = server.accept();	
Timeout	setSoTimeout(ms) doit √™tre appel√© avant accept().	server.setSoTimeout(5000);	
Flux ‚Äì BufferedWriter	Oublier flush() ‚Üí rien envoy√©.	BufferedWriter bw = new BufferedWriter(...); bw.write("msg"); bw.flush();	
Flux ‚Äì ObjectOutputStream / ObjectInputStream	Classe doit √™tre Serializable. Ordre de cr√©ation important : OOS avant OIS.	ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());	
InetAddress	new InetAddress() impossible. getByName(host) peut lever UnknownHostException. getAddress() ‚Üí byte sign√©.	InetAddress ip = InetAddress.getByName("www.google.com");	
TCP ‚Äì Java ‚Üî C	TCP = flux continu ‚Üí fin de message non d√©finie. Solutions : d√©limiteur ($%) ou header (taille). readByte() bloquant.	while((b = in.readByte()) != '$') {...}	
Multi-thread / Pool	Pool ‚Üí serveur ne cr√©e pas de thread par client, juste ajoute socket. getConnexion() bloque si vide. notify() r√©veille 1 thread.	socketQueue.add(s); synchronized(queue){queue.notify();}	
Swing / EDT	Ne jamais faire sleep() ou accept() dans actionPerformed ‚Üí interface freeze. Utiliser thread s√©par√©, communiquer via Logger.	new ThreadServeur().start();	
Port & Socket	Port sur 16 bits (0-65535). IP seule ‚â† communication ‚Üí il faut IP + Port = Socket.	Socket socket = new Socket("192.168.1.2", 80);	
