1ï¸âƒ£ La classe Class et le chargement du driver JDBC
ğŸ”¹ Nature de Class
â€¢	Class est une classe du JDK
â€¢	Elle appartient au package :
java.lang
â¡ï¸ donc import automatique
________________________________________
ğŸ”¹ RÃ´le fondamental de Class.forName()
Class.forName("com.mysql.cj.jdbc.Driver");
Cette instruction permet :
âœ… de localiser une classe Ã  partir de son nom
âœ… de charger cette classe en mÃ©moire
âœ… dâ€™exÃ©cuter son bloc statique
âœ… dâ€™enregistrer le driver JDBC dans DriverManager
âš ï¸ Important QCM
Class.forName() ne crÃ©e pas de connexion Ã  la base de donnÃ©es.
________________________________________
ğŸ”¹ Type de mÃ©canisme utilisÃ©
â€¢	Câ€™est un mÃ©canisme de chargement dynamique
â€¢	BasÃ© sur lâ€™introspection
â€¢	La classe est connue Ã  lâ€™exÃ©cution, pas Ã  la compilation
________________________________________
ğŸ”¹ Signature exacte Ã  reconnaÃ®tre en QCM
public static native Class forName(String className)
    throws ClassNotFoundException
________________________________________
ğŸ”¹ Exception associÃ©e
â€¢	ClassNotFoundException
â¡ï¸ levÃ©e si :
â€¢	le JAR du driver nâ€™est pas dans le classpath
â€¢	la classe est mal orthographiÃ©e
________________________________________
ğŸ”¹ Effet rÃ©el sur le driver
Quand Class.forName() est exÃ©cutÃ© :
âœ” la classe du driver est chargÃ©e
âœ” son bloc static {} sâ€™exÃ©cute
âœ” le driver sâ€™auto-enregistre auprÃ¨s de DriverManager
ğŸ‘‰ Câ€™est pour cela que DriverManager peut le retrouver plus tard.
________________________________________
ğŸ”¹ PiÃ¨ges classiques QCM
âŒ Class.forName() crÃ©e une connexion
âŒ Class.forName() retourne un Driver
âŒ Class.forName() appartient Ã  java.sql
âœ” Class.forName() retourne un objet de type Class
âœ” le driver doit Ãªtre prÃ©sent dans le projet
âœ” un driver = une classe Java
________________________________________
2ï¸âƒ£ La classe DriverManager
________________________________________
ğŸ”¹ Nature de DriverManager
â€¢	Classe abstraite ? âŒ NON
â€¢	Classe utilitaire avec mÃ©thodes statiques âœ”
â€¢	Package :
java.sql
________________________________________
ğŸ”¹ RÃ´le de DriverManager
DriverManager :
âœ… maintient une liste interne des drivers JDBC disponibles
âœ… joue le rÃ´le dâ€™intermÃ©diaire entre Java et les drivers
âœ… choisit automatiquement le driver compatible avec lâ€™URL JDBC
âœ… Ã©tablit la connexion logique avec la base de donnÃ©es
________________________________________
ğŸ”¹ Ce que DriverManager NE FAIT PAS
âŒ Il ne charge pas les drivers
âŒ Il nâ€™exÃ©cute pas de SQL
âŒ Il ne reprÃ©sente pas la connexion
________________________________________
ğŸ”¹ MÃ©thode centrale Ã  connaÃ®tre PAR CÅ’UR
public static synchronized Connection getConnection(
    String url,
    String user,
    String password
) throws SQLException
________________________________________
ğŸ”¹ Mot-clÃ© IMPORTANT pour QCM
â€¢	synchronized â†’ thread-safe
â€¢	garantit quâ€™une seule connexion est crÃ©Ã©e Ã  la fois
________________________________________
ğŸ”¹ URL JDBC â€“ analyse dÃ©taillÃ©e
Format :
jdbc:<sous-protocole>:<informations>
Exemple MySQL :
jdbc:mysql://192.168.228.167/PourStudent
DÃ©composition QCM :
Ã‰lÃ©ment	Signification
jdbc	protocole JDBC
mysql	sous-protocole (driver)
IP	serveur
PourStudent	base de donnÃ©es
________________________________________
ğŸ”¹ SÃ©lection du driver
â¡ï¸ DriverManager :
â€¢	parcourt la liste des drivers chargÃ©s
â€¢	teste leur compatibilitÃ© avec lâ€™URL
â€¢	sÃ©lectionne le premier driver compatible
âš ï¸ QCM classique :
Si aucun driver compatible nâ€™est trouvÃ© â†’ SQLException
________________________________________
ğŸ”¹ Exceptions associÃ©es
â€¢	SQLException :
o	URL invalide
o	mauvais login/mot de passe
o	base inexistante
o	driver incompatible
________________________________________
3ï¸âƒ£ Lâ€™interface Connection
________________________________________
ğŸ”¹ Nature de Connection
â€¢	Connection est une interface
â€¢	Package :
java.sql
â€¢	Elle est implÃ©mentÃ©e par le driver JDBC
â¡ï¸ Le programmeur ne connaÃ®t jamais la classe concrÃ¨te
________________________________________
ğŸ”¹ RÃ´le conceptuel de Connection
â€¢	ReprÃ©sente une connexion logique
â€¢	Plus prÃ©cisÃ©ment une session
â€¢	Contient :
o	lâ€™Ã©tat de la transaction
o	les requÃªtes SQL
o	les rÃ©sultats
o	les paramÃ¨tres de connexion
________________________________________
ğŸ”¹ CrÃ©ation dâ€™un objet Connection
Connection con = DriverManager.getConnection(...);
âœ” toujours retournÃ© par DriverManager
âŒ jamais instanciÃ© avec new
________________________________________
ğŸ”¹ Fermeture de la connexion
con.close();
Effets :
â€¢	libÃ©ration des ressources
â€¢	fin de la session
â€¢	fermeture logique de la connexion
âš ï¸ QCM :
Une connexion non fermÃ©e peut provoquer une fuite de ressources.
________________________________________
ğŸ”¹ Auto-commit (PIÃˆGE FRÃ‰QUENT)
Par dÃ©faut :
autoCommit = true
ğŸ‘‰ Chaque requÃªte INSERT, UPDATE, DELETE est validÃ©e automatiquement.
________________________________________
ğŸ”¹ DÃ©sactivation de lâ€™auto-commit
con.setAutoCommit(false);
â¡ï¸ Le programmeur doit gÃ©rer la transaction manuellement.
________________________________________
ğŸ”¹ MÃ©thodes de transaction
MÃ©thode	Effet
commit()	valide dÃ©finitivement
rollback()	annule les modifications
âš ï¸ QCM :
rollback() nâ€™a dâ€™effet que si autoCommit est dÃ©sactivÃ©.
________________________________________
ğŸ”¹ CrÃ©ation dâ€™instructions SQL
Statement stmt = con.createStatement();
ğŸ‘‰ Connection est le point dâ€™entrÃ©e vers le SQL
________________________________________
ğŸ” CHAÃNE JDBC â€“ Ã€ RECONNAÃTRE EN QCM
Ordre logique obligatoire :
1ï¸âƒ£ Charger le driver
Class.forName(...)
2ï¸âƒ£ GÃ©rer les drivers
DriverManager
3ï¸âƒ£ Obtenir une connexion
Connection
4ï¸âƒ£ ExÃ©cuter du SQL
Statement
5ï¸âƒ£ Fermer la connexion
close()
________________________________________
â— PIÃˆGES QCM CLASSIQUES (TRÃˆS IMPORTANTS)
âœ” Class.forName() nâ€™Ã©tablit pas de connexion
âœ” DriverManager ne reprÃ©sente pas la session
âœ” Connection est une interface
âœ” Un driver = une classe Java
âœ” Lâ€™URL JDBC dÃ©termine le driver
âœ” commit() nâ€™est utile que si auto-commit est dÃ©sactivÃ©
âœ” Une connexion doit toujours Ãªtre fermÃ©e
________________________________________
ğŸ§ª EXEMPLES DE QUESTIONS TYPE QCM
âœ” Â« Le rÃ´le de Class.forName() est de charger le driver JDBC Â» â†’ VRAI
âœ” Â« DriverManager contient la connexion Ã  la base Â» â†’ FAUX
âœ” Â« Connection est une classe concrÃ¨te Â» â†’ FAUX
âœ” Â« getConnection() peut lever une SQLException Â» â†’ VRAI
âœ” Â« Le driver MySQL doit Ãªtre prÃ©sent dans le classpath Â» â†’ VRAI
________________________________________
ğŸ§  PHRASE Ã€ RÃ‰CITER Ã€ Lâ€™EXAMEN
Â« JDBC fonctionne par chargement dynamique du driver via Class.forName(), gestion des drivers par DriverManager, et communication avec la base via un objet Connection reprÃ©sentant une session. Â»
________________________________________
ğŸ§  SYNTHÃˆSE JDBC â€“ STATEMENT / RESULTSET
ğŸ¯ Version EXAMEN QCM â€“ trÃ¨s dÃ©veloppÃ©e
________________________________________
1ï¸âƒ£ Lâ€™interface Statement
________________________________________
ğŸ”¹ Nature de Statement
â€¢	Statement est une interface
â€¢	Elle appartient au package :
java.sql
â€¢	Elle est implÃ©mentÃ©e par le driver JDBC
ğŸ‘‰ On ne fait jamais :
new Statement(); âŒ
________________________________________
ğŸ”¹ RÃ´le fondamental de Statement
Un objet Statement :
â€¢	reprÃ©sente une instruction SQL
â€¢	permet dâ€™envoyer des commandes SQL au SGBD
â€¢	agit comme un canal de communication SQL entre Java et la base
________________________________________
ğŸ”¹ CrÃ©ation dâ€™un Statement
Statement stmt = con.createStatement();
âš ï¸ QCM important :
Un Statement ne peut exister que si une Connection existe.
________________________________________
ğŸ”¹ Ce que Statement peut exÃ©cuter
Type de requÃªte SQL	MÃ©thode
SELECT	executeQuery()
INSERT / UPDATE / DELETE	executeUpdate()
RequÃªte quelconque	execute()
________________________________________
ğŸ”¹ MÃ©thode executeQuery()
public abstract ResultSet executeQuery(String sql)
    throws SQLException
CaractÃ©ristiques QCM :
âœ” accepte uniquement une requÃªte SELECT
âœ” retourne obligatoirement un ResultSet
âŒ ne peut pas exÃ©cuter INSERT / UPDATE / DELETE
________________________________________
ğŸ”¹ MÃ©thode executeUpdate()
public abstract int executeUpdate(String sql)
    throws SQLException
CaractÃ©ristiques QCM :
âœ” utilisÃ©e pour :
â€¢	INSERT
â€¢	UPDATE
â€¢	DELETE
âœ” retourne :
â€¢	le nombre de lignes affectÃ©es
âŒ ne retourne jamais de ResultSet
________________________________________
ğŸ”¹ MÃ©thode execute()
public boolean execute(String sql)
    throws SQLException
CaractÃ©ristiques QCM TRÃˆS PIÃ‰GEUSES :
âœ” peut exÃ©cuter nâ€™importe quelle requÃªte SQL
âœ” retourne :
â€¢	true â†’ si un ResultSet est produit
â€¢	false â†’ sinon
âš ï¸ La valeur retournÃ©e ne dit PAS si la requÃªte a rÃ©ussi
________________________________________
ğŸ”¹ RÃ©cupÃ©ration du ResultSet aprÃ¨s execute()
ResultSet rs = stmt.getResultSet();
âš ï¸ QCM :
getResultSet() ne fonctionne que si execute() a retournÃ© true.
________________________________________
ğŸ”¥ PIÃˆGES QCM â€“ Statement
âŒ Statement est une classe
âŒ executeQuery() retourne un int
âŒ executeUpdate() retourne un ResultSet
âŒ execute() indique le succÃ¨s de la requÃªte
âœ” Statement est une interface
âœ” executeUpdate() retourne un nombre de lignes
âœ” execute() indique la prÃ©sence dâ€™un ResultSet
________________________________________
2ï¸âƒ£ Lâ€™interface ResultSet
________________________________________
ğŸ”¹ Nature de ResultSet
â€¢	ResultSet est une interface
â€¢	Package :
java.sql
â€¢	ImplÃ©mentÃ©e par le driver JDBC
________________________________________
ğŸ”¹ RÃ´le de ResultSet
Un ResultSet :
â€¢	contient tous les tuples rÃ©sultant dâ€™un SELECT
â€¢	reprÃ©sente un curseur SQL
â€¢	correspond Ã  une table virtuelle
â€¢	possÃ¨de :
o	des lignes â†’ tuples
o	des colonnes â†’ champs sÃ©lectionnÃ©s
________________________________________
ğŸ”¹ Notion de curseur (TRÃˆS IMPORTANT QCM)
â€¢	Le curseur est :
o	sÃ©quentiel
o	Ã  sens unique
o	positionnÃ© avant la premiÃ¨re ligne au dÃ©part
ğŸ‘‰ Il faut obligatoirement appeler next() avant de lire des donnÃ©es.
________________________________________
ğŸ”¹ MÃ©thode next()
public abstract boolean next()
âœ” avance le curseur dâ€™un tuple
âœ” retourne :
â€¢	true â†’ tuple disponible
â€¢	false â†’ fin du ResultSet
ğŸ“Œ Analogie officielle du cours :
Comparable Ã  un itÃ©rateur C++
________________________________________
ğŸ”¹ Lecture des donnÃ©es â€“ mÃ©thode gÃ©nÃ©rique
Object getObject(int col)
âœ” retourne la valeur de la colonne col
âœ” sous forme de Object
âœ” index de colonne commence Ã  1 (âš ï¸ QCM)
________________________________________
ğŸ”¹ Lecture typÃ©e (lecture â€œfineâ€)
MÃ©thodes IMPORTANTES Ã  reconnaÃ®tre :
getString("Nom")
getInt("NbEnfants")
getFloat("Poids")
getDate("AnneeNaissance")
âœ” conversion automatique SQL â†’ Java
âœ” le driver tente dâ€™adapter le type
________________________________________
ğŸ”¹ Conversion des dates (PIÃˆGE QCM)
â€¢	SQL â†’ java.sql.Date
â€¢	Conversion vers Java moderne :
LocalDate d = dateSql.toLocalDate();
âœ” mÃ©thode de java.sql.Date
________________________________________
ğŸ”¹ Fermeture dâ€™un ResultSet
rs.close();
âš ï¸ QCM :
Un ResultSet doit Ãªtre fermÃ© avant la fermeture de la Connection.
________________________________________
ğŸ”¥ PIÃˆGES QCM â€“ ResultSet
âŒ Le curseur est positionnÃ© sur la premiÃ¨re ligne au dÃ©part
âŒ Les indices de colonnes commencent Ã  0
âŒ next() retourne un tuple
âœ” next() retourne un boolean
âœ” lecture impossible sans next()
âœ” parcours uniquement du dÃ©but vers la fin
________________________________________
3ï¸âƒ£ Lâ€™interface ResultSetMetaData
________________________________________
ğŸ”¹ Nature de ResultSetMetaData
â€¢	Interface
â€¢	Package :
java.sql
â€¢	Obtenue Ã  partir dâ€™un ResultSet
________________________________________
ğŸ”¹ Obtention des mÃ©tadonnÃ©es
ResultSetMetaData meta = rs.getMetaData();
________________________________________
ğŸ”¹ RÃ´le de ResultSetMetaData
Elle permet dâ€™obtenir :
â€¢	le nombre de colonnes
â€¢	le nom des colonnes
â€¢	le nom de la table source
ğŸ‘‰ Indispensable pour un traitement dynamique des rÃ©sultats.
________________________________________
ğŸ”¹ MÃ©thodes clÃ©s Ã  connaÃ®tre par cÅ“ur
int getColumnCount()
String getColumnName(int col)
String getTableName(int col)
âš ï¸ Indices de colonnes commencent Ã  1
________________________________________
ğŸ”¥ PIÃˆGES QCM â€“ MetaData
âŒ ResultSetMetaData permet dâ€™accÃ©der aux donnÃ©es
âŒ Les indices commencent Ã  0
âœ” permet uniquement dâ€™analyser la structure
âœ” associÃ©e Ã  un ResultSet
________________________________________
ğŸ” CHAÃNE JDBC COMPLÃˆTE (QCM CLASSIQUE)
Connection
   â†“
Statement
   â†“
executeQuery / executeUpdate / execute
   â†“
ResultSet
   â†“
next()
   â†“
getXXX()
________________________________________
â— QCM â€“ VRAI / FAUX TYPIQUES
âœ” executeQuery() retourne toujours un ResultSet
âœ” executeUpdate() retourne un int
âœ” execute() peut retourner true ou false
âœ” ResultSet est un curseur
âœ” next() doit Ãªtre appelÃ© avant toute lecture
âœ” Les indices de colonnes commencent Ã  1
âœ” ResultSetMetaData dÃ©crit la structure des rÃ©sultats
________________________________________
ğŸ§  PHRASE Ã€ RÃ‰CITER Ã€ Lâ€™EXAMEN
Â« Un Statement permet dâ€™exÃ©cuter des commandes SQL, un ResultSet reprÃ©sente un curseur contenant les tuples dâ€™un SELECT, et ResultSetMetaData permet dâ€™analyser dynamiquement la structure des rÃ©sultats. Â»
.
________________________________________
1ï¸âƒ£ JDBC : vue dâ€™ensemble (QUESTION QCM CLASSIQUE)
JDBC (Java DataBase Connectivity) est une API Java qui permet :
â€¢	de se connecter Ã  une base de donnÃ©es
â€¢	dâ€™exÃ©cuter des requÃªtes SQL
â€¢	de rÃ©cupÃ©rer et manipuler les rÃ©sultats
ğŸ“Œ JDBC est indÃ©pendant du SGBD (MySQL, PostgreSQL, Oracleâ€¦).
________________________________________
2ï¸âƒ£ Class.forName() (TRÃˆS PIÃ‰GEUX EN QCM)
RÃ´le
Class.forName("com.mysql.cj.jdbc.Driver");
ğŸ‘‰ Sert Ã  charger dynamiquement le driver JDBC en mÃ©moire.
Ã€ retenir ABSOLUMENT
â€¢	âŒ Ne crÃ©e PAS la connexion
â€¢	âœ… Enregistre le driver auprÃ¨s de DriverManager
â€¢	âš ï¸ Ã‰tait obligatoire avant JDBC 4
â€¢	âœ… Aujourdâ€™hui souvent optionnel, mais toujours correct
QCM typiques
âœ”ï¸ Class.forName() charge le driver
âŒ Class.forName() ouvre la connexion
âŒ Class.forName() exÃ©cute une requÃªte
________________________________________
3ï¸âƒ£ DriverManager (FONDAMENTAL)
RÃ´le
Connection con = DriverManager.getConnection(url, user, password);
ğŸ‘‰ Fabrique des objets Connection
Ã€ retenir
â€¢	DriverManager :
o	connaÃ®t les drivers disponibles
o	choisit le bon driver selon lâ€™URL JDBC
â€¢	Câ€™est une classe utilitaire, pas une interface
QCM
âœ”ï¸ DriverManager fournit une Connection
âŒ DriverManager exÃ©cute des requÃªtes SQL
________________________________________
4ï¸âƒ£ Interface Connection
RÃ´le
ReprÃ©sente une connexion active Ã  la base de donnÃ©es
Fonctions principales
â€¢	crÃ©er des requÃªtes :
Statement stmt = con.createStatement();
PreparedStatement ps = con.prepareStatement(sql);
â€¢	gÃ©rer les transactions :
con.commit();
con.rollback();
â€¢	fermer la connexion :
con.close();
QCM
âœ”ï¸ Connection permet de crÃ©er Statement et PreparedStatement
âŒ Connection contient les rÃ©sultats SQL
________________________________________
5ï¸âƒ£ Statement vs PreparedStatement (QUESTION MAJEURE)
Statement
Statement stmt = con.createStatement();
stmt.executeQuery("SELECT * FROM cars");
InconvÃ©nients
â€¢	âŒ VulnÃ©rable aux injections SQL
â€¢	âŒ RequÃªte recompilÃ©e Ã  chaque exÃ©cution
â€¢	âŒ SQL mÃ©langÃ© avec les donnÃ©es
________________________________________
PreparedStatement (TRÃˆS IMPORTANT)
PreparedStatement ps =
 con.prepareStatement("UPDATE Personne SET NbEnfants = ? WHERE Nom = ?");
Principe clÃ©
ğŸ‘‰ Le SQL est prÃ©parÃ© UNE FOIS
ğŸ‘‰ Les valeurs sont injectÃ©es sÃ©parÃ©ment
ps.setInt(1, 2);
ps.setString(2, "issier");
ps.executeUpdate();
________________________________________
6ï¸âƒ£ Avantages des requÃªtes prÃ©parÃ©es (Ã€ CONNAÃTRE PAR CÅ’UR)
ğŸ” SÃ©curitÃ©
âœ”ï¸ EmpÃªche les injections SQL
âœ”ï¸ Les paramÃ¨tres sont traitÃ©s comme des donnÃ©es, pas du code
âš¡ Performances
âœ”ï¸ RequÃªte compilÃ©e une seule fois
âœ”ï¸ RÃ©utilisable avec plusieurs valeurs
ğŸ§¹ LisibilitÃ© / Maintenance
âœ”ï¸ Code plus propre
âœ”ï¸ SÃ©paration SQL / donnÃ©es
QCM PIÃˆGE
âŒ Une requÃªte prÃ©parÃ©e empÃªche toute erreur SQL
âŒ Une requÃªte prÃ©parÃ©e est plus lente
________________________________________
7ï¸âƒ£ executeQuery() vs executeUpdate() (CLASSIQUE)
MÃ©thode	Utilisation	Retour
executeQuery()	SELECT	ResultSet
executeUpdate()	INSERT / UPDATE / DELETE	int (nb lignes)
________________________________________
8ï¸âƒ£ Interface ResultSet
RÃ´le
ğŸ‘‰ Contient le rÃ©sultat dâ€™un SELECT
while (rs.next()) {
   rs.getString("model");
   rs.getDouble("price");
}
Ã€ retenir
â€¢	Curseur ligne par ligne
â€¢	AccÃ¨s par :
o	nom de colonne
o	index (âš ï¸ fragile)
QCM
âœ”ï¸ ResultSet contient les donnÃ©es
âŒ ResultSet modifie la base
________________________________________
9ï¸âƒ£ DAO (Data Access Object) â€” QUESTION DE CONCEPTION
DÃ©finition
Un DAO encapsule lâ€™accÃ¨s aux donnÃ©es.
ğŸ‘‰ Le reste de lâ€™application ne voit PAS le SQL
________________________________________
Ce que fait un DAO
âœ”ï¸ GÃ¨re la connexion
âœ”ï¸ Contient les requÃªtes SQL
âœ”ï¸ Fournit des mÃ©thodes mÃ©tier (save, load, delete)
Ce quâ€™un DAO NE fait PAS
âŒ Affichage
âŒ Logique UI
________________________________________
SOLID
âœ”ï¸ Respecte le principe O (Open/Closed)
â†’ on peut changer la BD sans casser le reste
________________________________________
ğŸ”Ÿ EntitÃ©s (Car, Engine)
Mapping champ Ã  champ
Table	Classe
cars	Car
engines	Engine
Point TRÃˆS IMPORTANT
âœ”ï¸ Car contient un Engine
âŒ Car ne contient PAS juste engine_id
________________________________________
1ï¸âƒ£1ï¸âƒ£ Wrapper classes (PIÃˆGE QCM)
Pourquoi Integer au lieu de int ?
âœ”ï¸ Un Integer peut Ãªtre null
âœ”ï¸ Un int ne peut PAS Ãªtre null
ğŸ“Œ Cas clÃ© :
id == null â†’ objet pas encore persistÃ© en BD
________________________________________
1ï¸âƒ£2ï¸âƒ£ Search View Model (CarSearchVM)
Concept
ğŸ‘‰ Objet qui contient les critÃ¨res de recherche
Exemples de critÃ¨res
â€¢	id
â€¢	model
â€¢	maxPrice
â€¢	engineType
â€¢	minEnginePower
RÃ¨gle essentielle
â€¢	champ null â†’ critÃ¨re ignorÃ©
â€¢	tous les champs null â†’ SELECT *
________________________________________
1ï¸âƒ£3ï¸âƒ£ Construction dynamique des requÃªtes
âœ”ï¸ Le DAO :
â€¢	lit le SearchVM
â€¢	construit la clause WHERE
â€¢	utilise des PreparedStatement
âœ”ï¸ JOIN nÃ©cessaire :
cars JOIN engines
________________________________________
1ï¸âƒ£4ï¸âƒ£ MÃ©thode save(Car c) (IMPORTANT)
Cas 1 : c.getId() == null
âœ”ï¸ INSERT
âœ”ï¸ ID auto-gÃ©nÃ©rÃ©
âœ”ï¸ ID rÃ©cupÃ©rÃ© et affectÃ© Ã  lâ€™objet
Cas 2 : c.getId() != null
âœ”ï¸ UPDATE
Condition obligatoire
âŒ Impossible si Engine.id == null
________________________________________
ğŸ¯ RÃ‰SUMÃ‰ EXPRESS POUR LE QCM
â€¢	Class.forName() â†’ charge le driver
â€¢	DriverManager â†’ crÃ©e la connexion
â€¢	Connection â†’ fabrique les statements
â€¢	PreparedStatement â†’ sÃ©curitÃ© + perf
â€¢	ResultSet â†’ rÃ©sultats SELECT
â€¢	DAO â†’ encapsule SQL + connexion
â€¢	Wrapper classes â†’ permettent null
â€¢	SearchVM â†’ critÃ¨res combinables
â€¢	JOIN â†’ nÃ©cessaire pour Car â†” Engine
