[
    {
        "id": 44,
        "question": "Analysez ce code :\n```java\nClass.forName(\"com.mysql.cj.jdbc.Driver\");\n```\nQuelle est la conséquence EXACTE de cette ligne ?",
        "options": [
            "Elle crée une instance du Driver et la connecte à la DB.",
            "Elle charge le bytecode de la classe Driver, ce qui déclenche son bloc `static { }` et l'enregistre auprès du `DriverManager`.",
            "Elle retourne un objet `Connection` null.",
            "Elle vérifie si le jar est présent et lance `FileNotFoundException` sinon."
        ],
        "answer": 1,
        "explanation": "Mécanisme d'introspection. Le driver JDBC moderne s'auto-enregistre dans son bloc statique lors du chargement de la classe.",
        "chapterId": 3
    },
    {
        "id": 45,
        "question": "Quel est le comportement par défaut d'une `Connection` JDBC concernant les transactions (`autoCommit`) ?",
        "options": [
            "AutoCommit est FALSE par défaut (sécurité).",
            "AutoCommit est TRUE par défaut (chaque requête est validée immédiatement).",
            "Cela dépend du SGBD (Oracle vs MySQL).",
            "Les transactions sont désactivées par défaut."
        ],
        "answer": 1,
        "explanation": "Dangereux pour les applications réelles : par défaut, JDBC committe chaque ligne. Il faut `setAutoCommit(false)` pour faire une transaction groupée.",
        "chapterId": 3
    },
    {
        "id": 46,
        "question": "Code :\n```java\nboolean b = stmt.execute(\"UPDATE Employe SET salaire = salaire * 1.1\");\n```\nQue vaut `b` ?",
        "options": [
            "`true` car la requête a réussi.",
            "`false` car la requête ne retourne pas de ResultSet.",
            "Le nombre de lignes mises à jour (int casté en boolean).",
            "`null`."
        ],
        "answer": 1,
        "explanation": "PIÈGE MAJEUR : `execute()` retourne `true` SI le résultat est un ResultSet (SELECT), et `false` sinon (UPDATE/INSERT/DELETE). Pour savoir si ça a réussi, il faut vérifier qu'il n'y a pas d'exception.",
        "chapterId": 3
    },
    {
        "id": 47,
        "question": "Quelle méthode de `ResultSet` permet d'obtenir le nom de la 3ème colonne ?",
        "options": [
            "`rs.getColumnName(3)`",
            "`rs.getMetaData().getColumnName(3)`",
            "`rs.getMetaData().getColumnName(2)`",
            "`rs.getColumn(3).getName()`"
        ],
        "answer": 1,
        "explanation": "Les infos de structure (Noms, Types) sont dans les Méta-données, pas directement sur le `rs`. Et les indices commencent à 1.",
        "chapterId": 3
    },
    {
        "id": 48,
        "question": "Pourquoi est-il CRITIQUE d'utiliser `PreparedStatement` au lieu de `Statement` pour une authentification par login/mot de passe ?",
        "options": [
            "Car `Statement` ne crypte pas le mot de passe sur le réseau.",
            "Car `Statement` est vulnérable à l'injection SQL (ex: ' OR '1'='1').",
            "Car `PreparedStatement` est le seul à supporter les Strings.",
            "Car `Statement` est déprécié depuis Java 8."
        ],
        "answer": 1,
        "explanation": "L'injection SQL permet de contourner l'authentification en modifiant la logique de la requête via des chaînes concaténées.",
        "chapterId": 3
    },
    {
        "id": 49,
        "question": "Dans le modèle DAO présenté, que doit contenir la classe `Car` (Entity) pour représenter la relation avec `Engine` ?",
        "options": [
            "Un champ `int engineId` uniquement.",
            "Un objet complet `Engine engine`.",
            "Une String représentant le nom du moteur.",
            "Rien, la relation est gérée uniquement en base."
        ],
        "answer": 1,
        "explanation": "En POO, on mappe les relations par composition d'objets, pas par des Clés Étrangères (IDs) comme en relationnel.",
        "chapterId": 3
    },
    {
        "id": 50,
        "question": "Si `rs.next()` vient de retourner `false`, quel est l'état du curseur ?",
        "options": [
            "Il est sur la dernière ligne valide.",
            "Il est positionné 'AfterLast' (après la dernière ligne).",
            "Il est revenu au début ('BeforeFirst').",
            "Le ResultSet est fermé automatiquement."
        ],
        "answer": 1,
        "explanation": "Le curseur est 'tombé' après la fin. Toute tentative de lecture (`getString`) lèvera une exception.",
        "chapterId": 3
    },
    {
        "id": 51,
        "question": "Pour une requête `INSERT` qui génère un ID auto-incrémenté, comment le récupérer proprement ?",
        "options": [
            "On fait un `SELECT MAX(id)` juste après.",
            "Impossible avec JDBC standard.",
            "On utilise `Statement.RETURN_GENERATED_KEYS` à la création du statement, puis `getGeneratedKeys()`.",
            "L'ID est retourné directement par `executeUpdate()`."
        ],
        "answer": 2,
        "explanation": "Faire un SELECT MAX est risqué (concurrence). JDBC fournit un mécanisme standard pour récupérer la clé créée dans la même transaction.",
        "chapterId": 3
    },
    {
        "id": 52,
        "question": "Quelle est la nature exacte de `java.sql.Connection` ?",
        "options": [
            "Une Classe abstraite.",
            "Une Interface.",
            "Une Classe finale.",
            "Un Enum."
        ],
        "answer": 1,
        "explanation": "Tout JDBC est basé sur des interfaces. C'est le Driver du constructeur (Oracle, MySQL) qui fournit l'implémentation concrète cachée.",
        "chapterId": 3
    },
    {
        "id": 53,
        "question": "Dans un `SearchVM` (ViewModel de recherche), comment interpréter un champ `minPrice` qui vaut `null` ?",
        "options": [
            "On cherche les voitures dont le prix est 0.",
            "On cherche les voitures dont le prix est NULL en base.",
            "On ignore ce critère dans la clause WHERE (pas de filtre sur le prix).",
            "Cela lève une NullPointerException à l'exécution."
        ],
        "answer": 2,
        "explanation": "Principe des filtres dynamiques : Null = 'Peu importe', on n'ajoute pas la condition au SQL.",
        "chapterId": 3
    },
    {
        "id": 54,
        "question": "Quelle exception JDBC est de type 'Checked Exception' et doit obligatoirement être gérée ?",
        "options": [
            "`DataAccessException`",
            "`SQLException`",
            "`JDBCException`",
            "`DatabaseConnectionError`"
        ],
        "answer": 1,
        "explanation": "C'est la plaie de JDBC historique : tout lance SQLException, qu'il faut catcher ou thrower.",
        "chapterId": 3
    },
    {
        "id": 55,
        "question": "Que retourne `stmt.executeUpdate(\"DELETE FROM users\")` si la table contient 10 utilisateurs ?",
        "options": [
            "Un ResultSet vide.",
            "Le nombre 10 (int).",
            "True.",
            "Null."
        ],
        "answer": 1,
        "explanation": "Il retourne le 'Row Count', c'est-à-dire le nombre d'enregistrements affectés par la commande.",
        "chapterId": 3
    },
    {
        "id": 56,
        "question": "Pourquoi utilise-t-on des classes Wrapper (`Integer`, `Double`) au lieu des primitifs (`int`, `double`) dans les Entités (DTO) ?",
        "options": [
            "Pour la performance.",
            "Car les primitifs ne peuvent pas représenter la valeur SQL `NULL`.",
            "Car JDBC ne supporte pas les primitifs.",
            "Pour pouvoir utiliser `toString()`."
        ],
        "answer": 1,
        "explanation": "En base de données, une colonne INT peut être NULL. En Java, `int i = null` est impossible. `Integer` résout ce problème.",
        "chapterId": 3
    },
    {
        "id": 57,
        "question": "Quelle méthode permet de désactiver le mode qui valide chaque requête individuellement ?",
        "options": [
            "`con.setTransaction(false)`",
            "`con.setAutoCommit(false)`",
            "`con.setManualCommit(true)`",
            "`con.beginTransaction()`"
        ],
        "answer": 1,
        "explanation": "C'est la méthode standard pour démarrer une transaction 'manuelle' en JDBC.",
        "chapterId": 3
    },
    {
        "id": 58,
        "question": "À quoi sert l'interface `ResultSetMetaData` ?",
        "options": [
            "À lire les données du résultat.",
            "À connaître le nombre de colonnes, leurs noms et leurs types dynamiquement.",
            "À modifier la structure de la table (ALTER TABLE).",
            "À gérer les méta-données de la connexion."
        ],
        "answer": 1,
        "explanation": "Essentiel pour faire des affichages génériques (ex: afficher n'importe quelle table dans une grille sans connaître ses colonnes à l'avance).",
        "chapterId": 3
    },
    {
        "id": 59,
        "question": "Quelle est la particularité des indices de colonnes dans `ResultSet.getString(i)` ?",
        "options": [
            "Ils commencent à 0 (comme les tableaux Java).",
            "Ils commencent à 1 (convention SQL).",
            "On doit utiliser le nom de la colonne, l'index est interdit.",
            "Ils sont négatifs en cas d'erreur."
        ],
        "answer": 1,
        "explanation": "Piège mémoriel : JDBC suit la convention SQL (1-based), alors que tout le reste de Java est 0-based.",
        "chapterId": 3
    },
    {
        "id": 60,
        "question": "Un DAO (Data Access Object) bien conçu doit :",
        "options": [
            "Contenir du code Swing pour afficher les erreurs.",
            "Masquer totalement le SQL et l'API JDBC au reste de l'application.",
            "Ouvrir une nouvelle connexion à chaque appel de méthode.",
            "Être une interface sans implémentation."
        ],
        "answer": 1,
        "explanation": "Séparation des couches : Le contrôleur appelle `dao.findAll()`, il ne doit pas savoir qu'il y a du SQL derrière.",
        "chapterId": 3
    },
    {
        "id": 61,
        "question": "Si j'utilise `Statement` (non préparé), que se passe-t-il au niveau du SGBD ?",
        "options": [
            "La requête est mise en cache efficacement.",
            "La requête doit être analysée, parsée et planifiée à chaque exécution.",
            "Le SGBD refuse la requête.",
            "C'est plus rapide que PreparedStatement."
        ],
        "answer": 1,
        "explanation": "Performance : Sans bind variable, le SGBD voit chaque requête comme nouvelle ('...WHERE id=4', '...WHERE id=5'). Il recompilera le plan d'exécution à chaque fois.",
        "chapterId": 3
    },
    {
        "id": 62,
        "question": "Quand faut-il fermer un `ResultSet` ?",
        "options": [
            "Jamais, le GC s'en occupe.",
            "Avant de fermer le Statement qui l'a créé.",
            "Après avoir fermé la Connection.",
            "C'est automatique à la fin du `while`."
        ],
        "answer": 1,
        "explanation": "L'ordre de fermeture est inverse de l'ouverture : ResultSet -> Statement -> Connection.",
        "chapterId": 3
    },
    {
        "id": 63,
        "question": "Dans le pattern DAO, la méthode `save(Car c)` gère souvent deux cas. Lesquels ?",
        "options": [
            "Lecture et Écriture.",
            "INSERT (si id null) et UPDATE (si id existant).",
            "Suppression et Création.",
            "Connexion et Déconnexion."
        ],
        "answer": 1,
        "explanation": "C'est la logique standard de persistance : un objet sans ID est nouveau, un objet avec ID existe déjà.",
        "chapterId": 3
    },
    {
        "id": 61,
        "question": "Code :\n```java\nint age = rs.getInt(\"age\");\n```\nSi la colonne age vaut NULL en base, que vaut la variable `age` ?",
        "options": [
            "`null`",
            "`0`",
            "`-1`",
            "Une exception est levée."
        ],
        "answer": 1,
        "explanation": "JDBC retourne 0 pour les types primitifs quand la valeur est NULL. Il faut appeler `rs.wasNull()` immédiatement après pour distinguer 0 et NULL.",
        "chapterId": 3
    },
    {
        "id": 62,
        "question": "Le chargement dynamique `Class.forName` est-il toujours OBLIGATOIRE en JDBC 4.0+ ?",
        "options": [
            "Oui, sinon ça ne marche pas.",
            "Non, le mécanisme SPI (Service Provider Interface) charge automatiquement les drivers présents dans le classpath.",
            "Seulement pour Oracle.",
            "Oui, pour des raisons de sécurité."
        ],
        "answer": 1,
        "explanation": "Le texte précise que c'est 'souvent optionnel' aujourd'hui mais toujours correct. En JDBC moderne, c'est automatique.",
        "chapterId": 3
    },
    {
        "id": 66,
        "question": "Quelle est l'URL JDBC typique pour se connecter à MySQL ?",
        "options": [
            "`http://mysql.com:3306/db`",
            "`jdbc:mysql://host:port/database`",
            "`sql:mysql://host/db`",
            "`mysql:jdbc://host/db`"
        ],
        "answer": 1,
        "explanation": "Protocole (`jdbc`) + Sous-protocole (`mysql`) + adresse standard.",
        "chapterId": 3
    },
    {
        "id": 67,
        "question": "Si je fais `con.rollback()` alors que `autoCommit` est à `true`, que se passe-t-il ?",
        "options": [
            "La dernière requête est annulée.",
            "Une `SQLException` est levée.",
            "Rien ne se passe.",
            "La connexion se ferme."
        ],
        "answer": 1,
        "explanation": "C'est un non-sens : il n'y a pas de transaction en cours à annuler puisque tout est déjà committé.",
        "chapterId": 3
    },
    {
        "id": 68,
        "question": "Un `PreparedStatement` est-il compilé côté client (Java) ou côté serveur (SGBD) ?",
        "options": [
            "Côté Java (Bytecode).",
            "Côté SGBD (Plan d'exécution).",
            "Il n'est pas compilé.",
            "Par le driver JDBC."
        ],
        "answer": 1,
        "explanation": "C'est la base de données qui 'prépare' la requête optimisée, pas le programme Java.",
        "chapterId": 3
    },
    {
        "id": 69,
        "question": "Pour récupérer une date SQL en Java moderne (Java 8+), quelle conversion est recommandée dans le texte ?",
        "options": [
            "Utiliser `java.util.Date` directement.",
            "Convertir `java.sql.Date` en `LocalDate` via `toLocalDate()`.",
            "Traiter la date comme une String.",
            "Utiliser `Calendar`."
        ],
        "answer": 1,
        "explanation": "L'API `java.time` (LocalDate) est bien meilleure. JDBC supporte la conversion depuis les vieux types `java.sql`.",
        "chapterId": 3
    },
    {
        "id": 70,
        "question": "Quelle méthode permet d'exécuter un `SELECT` ?",
        "options": [
            "`executeUpdate()`",
            "`executeQuery()`",
            "`executeSelect()`",
            "`executeSQL()`"
        ],
        "answer": 1,
        "explanation": "Distinction fondamentale : Query=Question (Select), Update=Mise à jour (Changement d'état).",
        "chapterId": 3
    },
    {
        "id": 71,
        "question": "Peut-on instancier `new Class()` pour charger un driver ?",
        "options": [
            "Oui.",
            "Non, `Class` n'a pas de constructeur public.",
            "Oui, mais c'est déprécié.",
            "Seulement dans un bloc static."
        ],
        "answer": 1,
        "explanation": "`Class` est une méta-classe du système. On obtient des instances via `forName` ou `.class`, mais on ne les crée pas avec `new`.",
        "chapterId": 3
    },
    {
        "id": 72,
        "question": "Dans l'architecture proposée, si on supprime une `Car`, doit-on supprimer son `Engine` associé ?",
        "options": [
            "C'est automatique.",
            "Cela dépend des règles métier et des contraintes de clé étrangère (Cascade).",
            "Non, c'est interdit.",
            "Oui, le DAO le fait toujours."
        ],
        "answer": 1,
        "explanation": "Question de conception. Si l'Engine est partagé, non. Si c'est une composition forte, oui. JDBC ne le fait pas magiquement, c'est la base ou le DAO qui gère.",
        "chapterId": 3
    },
    {
        "id": 73,
        "question": "Le mot clé `limit` dans une requête SQL MySQL sert à :",
        "options": [
            "Limiter le temps d'exécution.",
            "Limiter le nombre de lignes retournées.",
            "Limiter le nombre de connexions.",
            "Limiter la taille mémoire."
        ],
        "answer": 1,
        "explanation": "Bien que ce soit du SQL pur, c'est souvent utilisé avec JDBC pour la pagination.",
        "chapterId": 3
    },
    {
        "id": 74,
        "question": "Code :\n```java\nPreparedStatement ps = con.prepareStatement(\n  \"SELECT * FROM users WHERE nom = ?\");\nps.setString(1, \"O'Brian\");\n```\nComment le SGBD reçoit-il cette requête ?",
        "options": [
            "Il reçoit `SELECT * FROM users WHERE nom = 'O''Brian'` (échappement automatique).",
            "Il reçoit la requête compilée avec un placeholder, et le paramètre est envoyé séparément (protocole binaire).",
            "Il reçoit `SELECT * FROM users WHERE nom = \"O'Brian\"`.",
            "Il reçoit une erreur de syntaxe à cause de l'apostrophe."
        ],
        "answer": 1,
        "explanation": "C'est la force des requêtes préparées : les données ne sont jamais interprétées comme du code SQL. L'injection SQL est impossible.",
        "chapterId": 3
    },
    {
        "id": 75,
        "question": "Si `autoCommit` est à `false`, que se passe-t-il si je ferme la connexion (`con.close()`) sans faire `commit()` ?",
        "options": [
            "Le SGBD effectue un commit automatique.",
            "Le SGBD effectue un rollback automatique (les changements sont perdus).",
            "La connexion reste ouverte côté serveur.",
            "Une exception est levée."
        ],
        "answer": 1,
        "explanation": "Comportement standard : fermeture de session sans validation explicite => annulation de la transaction en cours.",
        "chapterId": 3
    },
    {
        "id": 76,
        "question": "Code :\n```java\nResultSet rs = stmt.executeQuery(\"SELECT count(*) FROM table\");\nint count = rs.getInt(1);\n```\nCe code est-il correct ?",
        "options": [
            "Oui.",
            "Non, il manque obligatoirement `rs.next()` avant de lire les données.",
            "Non, l'index commence à 0.",
            "Non, `getInt` ne marche pas sur un count."
        ],
        "answer": 1,
        "explanation": "Le curseur est initialisé AVANT la première ligne. Même s'il n'y a qu'une seule ligne de résultat, il faut avancer dessus avec `next()`.",
        "chapterId": 3
    },
    {
        "id": 77,
        "question": "Quelle méthode permet de récupérer le nom de la table d'origine de la 2ème colonne du résultat ?",
        "options": [
            "`rs.getMetaData().getTableName(2)`",
            "`rs.getTableName(2)`",
            "`rs.getColumn(2).getTable()`",
            "Impossible en JDBC."
        ],
        "answer": 0,
        "explanation": "Les métadonnées (`ResultSetMetaData`) contiennent toutes les infos structurelles (Table, Schema, Type, Nom, etc.).",
        "chapterId": 3
    },
    {
        "id": 78,
        "question": "Pour gérer une transaction qui implique 3 updates, doit-on utiliser la même instance de `Connection` ?",
        "options": [
            "Non, on peut en utiliser plusieurs si elles pointent vers la même base.",
            "Oui, la transaction est liée à la session (Connection).",
            "Peu importe.",
            "Oui, mais il faut 3 Statements différents."
        ],
        "answer": 1,
        "explanation": "La transaction est un concept de session. Si on change de connexion, on est dans une autre transaction.",
        "chapterId": 3
    },
    {
        "id": 79,
        "question": "Code :\n```java\nps.setDate(1, new java.util.Date());\n```\nCe code compile-t-il ?",
        "options": [
            "Oui.",
            "Non, `PreparedStatement.setDate` attend un `java.sql.Date`, qui est une sous-classe de `java.util.Date`.",
            "Non, il faut utiliser `Calandar`.",
            "Oui mais il lance une exception."
        ],
        "answer": 1,
        "explanation": "Confusion classique des types Date en Java. `java.sql.Date` ne contient que la partie JOUR (pas d'heure), et c'est ce que JDBC attend.",
        "chapterId": 3
    },
    {
        "id": 80,
        "question": "Pourquoi l'utilisation de `SELECT *` est-elle déconseillée dans un DAO de production ?",
        "options": [
            "C'est plus lent.",
            "Si la structure de la table change (ajout de colonne), le mapping des colonnes par index risque de casser ou de ramener des données inutiles.",
            "C'est interdit par JDBC.",
            "Ca ne marche pas avec PreparedStatement."
        ],
        "answer": 1,
        "explanation": "Bonne pratique : toujours lister explicitement les colonnes (`SELECT id, nom, prenom...`).",
        "chapterId": 3
    },
    {
        "id": 81,
        "question": "Code :\n```java\nstmt.executeUpdate(\"INSERT ...\", Statement.RETURN_GENERATED_KEYS);\nResultSet rs = stmt.getGeneratedKeys();\n```\nQue contient `rs` ?",
        "options": [
            "Toute la ligne insérée.",
            "Une seule colonne contenant la valeur de l'ID auto-incrémenté généré par la base.",
            "Rien.",
            "Le nombre de lignes."
        ],
        "answer": 1,
        "explanation": "C'est le mécanisme standard pour récupérer la PK (Primary Key) créée par la base (AUTO_INCREMENT) sans faire un `SELECT MAX(id)` risqué.",
        "chapterId": 3
    },
    {
        "id": 82,
        "question": "Si une `SQLException` survient pendant une transaction (après 2 updates réussis), que doit-on faire dans le bloc `catch` ?",
        "options": [
            "Juste logger l'erreur.",
            "Appeler `con.rollback()` pour annuler les 2 updates précédents et garder la base cohérente.",
            "Fermer l'application.",
            "Relancer la requête."
        ],
        "answer": 1,
        "explanation": "Principe d'atomicité (ACID). Tout ou rien. En cas d'erreur partielle, on annule tout.",
        "chapterId": 3
    },
    {
        "id": 83,
        "question": "L'interface `DataSource` (javax.sql) est préférée à `DriverManager` car :",
        "options": [
            "Elle est plus rapide à l'exécution.",
            "Elle permet d'externaliser la configuration et de gérer un Pool de Connexions (CP) de manière transparente.",
            "Elle ne lance pas d'exceptions.",
            "Elle permet de changer de base sans changer le code."
        ],
        "answer": 1,
        "explanation": "Dans le monde pro (JEE/Spring), on n'utilise jamais DriverManager en direct, mais une DataSource qui gère un pool (HikariCP, DBCP) pour réutiliser les connexions coûteuses.",
        "chapterId": 3
    }
]