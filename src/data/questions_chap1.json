[
    {
        "id": 1,
        "question": "Analysez ce code :\n```c\nint s = socket(AF_INET, SOCK_STREAM, 0);\n```\nJuste après cette ligne, quelle affirmation est VRAIE ?",
        "options": [
            "La socket est prête à recevoir des clients sur le port 80.",
            "La socket est allouée mais 'anonyme' (ni IP, ni port).",
            "La socket est connectée à localhost.",
            "C'est une socket UDP."
        ],
        "answer": 1,
        "explanation": "Piège : `socket()` crée la ressource système (le descripteur), mais ne lui donne aucune identité réseau. Il faut `bind()` pour ça.",
        "chapterId": 1
    },
    {
        "id": 2,
        "question": "Dans le prototype `int socket(int domain, int type, int protocol)`, que provoque l'argument `protocol = 0` ?",
        "options": [
            "Il désactive le contrôle d'erreur.",
            "Il force l'utilisation du protocole UDP par défaut.",
            "Il demande au système de choisir le protocole par défaut associé au `type` demandé.",
            "Il crée une socket brute (RAW) sans couche de transport."
        ],
        "answer": 2,
        "explanation": "0 n'est pas 'nul' ou 'aucun', c'est une valeur sentinelle pour 'choix par défaut du système' (ex: TCP pour SOCK_STREAM).",
        "chapterId": 1
    },
    {
        "id": 3,
        "question": "Concernant `bind()`, quelle distinction Client/Serveur est techniquement exacte selon le texte ?",
        "options": [
            "Le `bind` est interdit pour un client car cela bloquerait le port.",
            "Le `bind` est optionnel pour le serveur s'il utilise le port 80.",
            "Le `bind` est obligatoire pour le serveur, tandis que le client peut s'en passer et profiter d'un 'bind implicite'.",
            "Le client doit faire un `bind` sur l'adresse du serveur avant de se connecter."
        ],
        "answer": 2,
        "explanation": "Le serveur doit être joignable sur un port fixe. Le client peut laisser l'OS choisir (bind implicite).",
        "chapterId": 1
    },
    {
        "id": 4,
        "question": "Quelle structure de données C représente spécifiquement l'adresse IP (et non le couple IP+Port) en IPv4 ?",
        "options": [
            "`struct sockaddr`",
            "`struct sockaddr_in`",
            "`struct in_addr`",
            "`struct addrinfo`"
        ],
        "answer": 2,
        "explanation": "Subtilité : `sockaddr_in` contient le port ET l'IP. L'IP seule est stockée dans la sous-structure `struct in_addr`.",
        "chapterId": 1
    },
    {
        "id": 5,
        "question": "Pourquoi privilégie-t-on le DNS et la résolution de nom à l'initialisation manuelle des structures ?",
        "options": [
            "Car `sockaddr_in` est dépréciée.",
            "Pour éviter la complexité de gestion des formats binaires et l'ordre des octets manuellement.",
            "Car c'est la seule façon d'obtenir une adresse IPv6.",
            "Parce que le DNS est plus rapide que l'affectation statique."
        ],
        "answer": 1,
        "explanation": "Le texte indique que le remplissage manuel est 'complexe' (binaire, endianness), d'où l'usage de noms conviviaux résolu par DNS.",
        "chapterId": 1
    },
    {
        "id": 6,
        "question": "Code :\n```c\nlisten(sockfd, 5);\n```\nQue se passe-t-il si un 6ème client tente de se connecter alors que personne n'a fait `accept()` ?",
        "options": [
            "Le serveur plante.",
            "Le 6ème client est rejeté (ECONNREFUSED) ou mis en attente TCP (selon l'OS), car la file de backlog est pleine.",
            "La fonction `listen` bloque.",
            "Le backlog s'agrandit automatiquement."
        ],
        "answer": 1,
        "explanation": "Le paramètre `backlog` (ici 5) définit la taille de la file d'attente des connexions 'en attente d'acceptation'. Une fois pleine, les suivants sont refusés.",
        "chapterId": 1
    },
    {
        "id": 7,
        "question": "Que définit précisément le paramètre `backlog` de la fonction `listen` ?",
        "options": [
            "Le nombre total de clients connectés simultanément.",
            "La taille du buffer de réception en octets.",
            "Le nombre maximum de connexions 'pendantes' (Reçues mais non encore acceptées).",
            "Le nombre d'échecs de connexion tolérés avant arrêt."
        ],
        "answer": 2,
        "explanation": "Nuance cruciale : Ce n'est pas la limite de connexions actives, mais seulement la limite de la file d'attente d'entrée (handshake fini, en attente de prise en charge).",
        "chapterId": 1
    },
    {
        "id": 8,
        "question": "Quelle constante système plafonne la valeur maximale réelle du `backlog` ?",
        "options": [
            "`MAX_CONNECTIONS`",
            "`SOMAXCONN`",
            "`TCP_MAX_syn_backlog`",
            "`LIMIT_FD`"
        ],
        "answer": 1,
        "explanation": "C'est la constante citée dans le texte qui limite la taille de la file d'attente imposée par le système.",
        "chapterId": 1
    },
    {
        "id": 9,
        "question": "Code :\n```c\nsend(sockfd, buf, len, 0);\n```\nSi le flag est 0, quelle fonction système standard est strictement équivalente ?",
        "options": [
            "`write(sockfd, buf, len)`",
            "`fprintf(sockfd, buf)`",
            "`put(sockfd, buf)`",
            "`ioctl(sockfd, buf)`"
        ],
        "answer": 0,
        "explanation": "Les sockets sont des fichiers (file descriptors). Sans flags spécifiques, `send` se comporte exactement comme `write`.",
        "chapterId": 1
    },
    {
        "id": 10,
        "question": "Quelle différence structurelle majeure distingue une socket TCP d'un Pipe classique ?",
        "options": [
            "Le Pipe est plus rapide.",
            "La socket est bidirectionnelle (lecture/écriture sur le même fd), le Pipe est unidirectionnel.",
            "Le Pipe utilise des paquets, la socket des flux.",
            "La socket n'utilise pas de descripteur de fichier."
        ],
        "answer": 1,
        "explanation": "La bidirectionnalité est la différence clé citée. Le modèle conceptuel évoque 'deux pipes' pour une socket.",
        "chapterId": 1
    },
    {
        "id": 11,
        "question": "Que se passe-t-il au niveau système si une application omet de fermer (`close`) une socket proprement ?",
        "options": [
            "Rien, le Garbage Collector du C s'en occupe.",
            "La socket reste bloquée dans un état transitoire (ex: CLOSE_WAIT) et le port reste indisponible un certain temps.",
            "Le système force une fermeture immédiate sans délai.",
            "L'ordinateur redémarre."
        ],
        "answer": 1,
        "explanation": "C'est un problème critique de gestion de ressources : le port reste bloqué (timeout) si la fermeture n'est pas propre.",
        "chapterId": 1
    },
    {
        "id": 12,
        "question": "Quel événement réseau précis est déclenché par l'appel à `connect()` ?",
        "options": [
            "L'envoi d'un ping ICMP.",
            "Le démarrage du 'Handshake TCP' (poignée de main en 3 étapes).",
            "L'ouverture d'un port d'écoute sur le serveur.",
            "La résolution DNS du nom d'hôte."
        ],
        "answer": 1,
        "explanation": "`connect` est le déclencheur de la connexion active, matérialisé par le handshake TCP.",
        "chapterId": 1
    },
    {
        "id": 13,
        "question": "Si un client appelle `connect()` sans avoir fait de `bind()` au préalable, que fait le système ?",
        "options": [
            "Il retourne une erreur `EINVAL`.",
            "Il utilise le port 0 comme port source réel.",
            "Il attribue automatiquement une IP locale et un port éphémère (Bind implicite).",
            "Il demande à l'utilisateur de saisir un port."
        ],
        "answer": 2,
        "explanation": "C'est le mécanisme de 'Bind implicite' qui dispense le client de configuration manuelle.",
        "chapterId": 1
    },
    {
        "id": 14,
        "question": "Dans quel cas l'erreur `ECONNREFUSED` est-elle levée par `connect()` ?",
        "options": [
            "Lorsque le réseau est débranché physiquement.",
            "Lorsque le serveur distant n'a aucun processus écoutant sur le port cible.",
            "Lorsque le pare-feu laisse passer le paquet mais ne répond pas.",
            "Lorsque l'adresse IP n'existe pas."
        ],
        "answer": 1,
        "explanation": "La nuance est importante : 'Refused' implique que la machine cible a répondu (RST) pour dire 'personne n'écoute ici'.",
        "chapterId": 1
    },
    {
        "id": 15,
        "question": "Le paramètre `addr` passé à `bind(sockfd, addr, ...)` est de type `struct sockaddr *`. Pourquoi utilise-t-on ce type ?",
        "options": [
            "C'est une structure spécifique à IPv4.",
            "C'est un pointeur générique permettant de supporter différentes familles d'adresses (IPv4, IPv6, Unix...).",
            "C'est une erreur de frappe dans le cours.",
            "C'est pour crypter l'adresse mémoire."
        ],
        "answer": 1,
        "explanation": "Le polymorphisme en C : `sockaddr*` sert d'interface générique pour n'importe quelle structure d'adresse spécifique (`sockaddr_in`, `sockaddr_un`, etc.).",
        "chapterId": 1
    },
    {
        "id": 16,
        "question": "Quelle est la valeur de retour de `close(fd)` en cas de succès ?",
        "options": [
            "1",
            "0",
            "-1",
            "NULL"
        ],
        "answer": 1,
        "explanation": "Convention standard Unix : 0 pour succès, -1 pour erreur.",
        "chapterId": 1
    },
    {
        "id": 17,
        "question": "Sur quel descripteur doit-on appeler `close` côté serveur pour arrêter DEFINITIVEMENT d'accepter de nouveaux clients ?",
        "options": [
            "Sur la socket de service (celle rliée au client connecté).",
            "Sur la socket d'écoute (celle utilisée pour `listen`).",
            "Sur le descripteur 0 (stdin).",
            "C'est automatique."
        ],
        "answer": 1,
        "explanation": "La socket d'écoute est la porte d'entrée. La fermer empêche toute nouvelle connexion entrante.",
        "chapterId": 1
    },
    {
        "id": 18,
        "question": "Quelle affirmation sur le mode UDP (Non connecté) est fausse selon le texte ?",
        "options": [
            "Il ne garantit pas l'ordre des données.",
            "Il garantit la réception des données si le réseau est libre.",
            "Il n'assure pas de connexion persistante.",
            "Il envoie des datagrammes."
        ],
        "answer": 1,
        "explanation": "UDP ne garantit JAMAIS la réception (Best Effort), même si le réseau semble libre, des pertes sont possibles sans notification.",
        "chapterId": 1
    },
    {
        "id": 19,
        "question": "Dans l'analogie 'Deux Pipes' pour une socket TCP, que représentent ces deux canaux ?",
        "options": [
            "Un pour les données, un pour les erreurs.",
            "Un pour le flux Client vers Serveur, un pour le flux Serveur vers Client.",
            "Un pour l'IPv4, un pour l'IPv6.",
            "Un pour le header, un pour le body."
        ],
        "answer": 1,
        "explanation": "Cela illustre la communication Full-Duplex (bidirectionnelle simultanée).",
        "chapterId": 1
    },
    {
        "id": 20,
        "question": "Lorsque la variable `errno` vaut `EADDRINUSE` après un `listen` (ou bind), quelle est la cause matérielle ?",
        "options": [
            "La mémoire RAM est pleine.",
            "L'adresse IP est mal formée.",
            "Une autre socket écoute déjà sur le même port (conflit de port).",
            "Le câble réseau est défectueux."
        ],
        "answer": 2,
        "explanation": "C'est l'erreur classique de conflit : le couple IP:Port est déjà pris par un autre processus.",
        "chapterId": 1
    },
    {
        "id": 21,
        "question": "Le paramètre `len` dans `recv(sockfd, buf, len, flags)` indique :",
        "options": [
            "La taille exacte des données que l'on VA recevoir.",
            "La taille totale du fichier à télécharger.",
            "La taille maximale du buffer de réception (capacité d'accueil).",
            "Le nombre de paquets attendus."
        ],
        "answer": 2,
        "explanation": "Important : On indique au système 'je peux stocker au maximum X octets'. On ne connait pas encore la taille des données qui arriveront.",
        "chapterId": 1
    },
    {
        "id": 22,
        "question": "Quellefamille d'adresse doit être passée à `socket()` pour une communication IPv6 ?",
        "options": [
            "`AF_INET`",
            "`AF_INET6`",
            "`AF_UNIX`",
            "`PF_INET`"
        ],
        "answer": 1,
        "explanation": "Simple mais précis : `AF_INET` = IPv4, `AF_INET6` = IPv6.",
        "chapterId": 1
    },
    {
        "id": 23,
        "question": "Par défaut, quel est le comportement temporel de l'appel `connect()` ?",
        "options": [
            "Non-bloquant (asynchrone).",
            "Bloquant (attend la réussite ou l'échec du handshake).",
            "Instantané.",
            "Furtif."
        ],
        "answer": 1,
        "explanation": "Le texte précise que `connect()` est bloquant par défaut, gelant le programme jusqu'à établissement de la connexion.",
        "chapterId": 1
    },
    {
        "id": 24,
        "question": "Quelle est la nature de la connexion côté Serveur ?",
        "options": [
            "Active.",
            "Passive.",
            "Hybride.",
            "Dynamique."
        ],
        "answer": 1,
        "explanation": "Le serveur *attend* d'être contacté. C'est une ouverture passive.",
        "chapterId": 1
    },
    {
        "id": 25,
        "question": "Pour `connect(sockfd, addr, len)`, l'adresse `addr` fournie correspond à :",
        "options": [
            "L'adresse locale de la machine courante.",
            "L'adresse IP et le port du serveur distant.",
            "L'adresse du routeur.",
            "Une adresse mémoire vide à remplir."
        ],
        "answer": 1,
        "explanation": "Contrairement à `bind` (qui définit 'qui je suis'), `connect` définit 'qui je veux appeler' (destination).",
        "chapterId": 1
    },
    {
        "id": 26,
        "question": "Si `recv` est utilisé comme `read` (flags=0), que retourne-t-il si la connexion est fermée proprement par l'autre côté ?",
        "options": [
            "-1",
            "0",
            "EOF",
            "Le nombre d'octets restants."
        ],
        "answer": 1,
        "explanation": "Comme pour les fichiers, 0 signifie 'Fin de fichier' (EOF - End Of File), donc fin de connexion.",
        "chapterId": 1
    },
    {
        "id": 27,
        "question": "Un descripteur de socket créé par `socket()` est-il un fichier physique sur le disque dur ?",
        "options": [
            "Oui, dans /tmp.",
            "Non, c'est une abstraction en mémoire noyau, mais manipulée comme un fichier.",
            "Oui, dans /dev/net.",
            "Seulement en mode UDP."
        ],
        "answer": 1,
        "explanation": "La philosophie 'Tout est fichier' est une abstraction d'interface, pas nécessairement de stockage physique.",
        "chapterId": 1
    },
    {
        "id": 28,
        "question": "Quelle erreur (via errno) indique que le serveur est injoignable (timeout) lors d'un `connect` ?",
        "options": [
            "`ETIMEDOUT`",
            "`ECONNREFUSED`",
            "`ENETUNREACH`",
            "`EBADF`"
        ],
        "answer": 0,
        "explanation": "Distinction : `ECONNREFUSED` = réponse rapide 'Non'. `ETIMEDOUT` = aucune réponse (paquet perdu ou filtré).",
        "chapterId": 1
    },
    {
        "id": 29,
        "question": "A quoi sert le paramètre `flags` dans `send/recv` dans 'les cas simples' selon le texte ?",
        "options": [
            "À définir la priorité du paquet.",
            "Il est rarement utilisé et mis à 0 pour un comportement standard.",
            "À activer le cryptage.",
            "À changer le port de destination."
        ],
        "answer": 1,
        "explanation": "Le texte minimise son usage : 'rarement utilisé dans les cas simples... s'il vaut 0, comportement standard'.",
        "chapterId": 1
    },
    {
        "id": 30,
        "question": "Quelle opération valide définitivement la connexion pour le serveur et crée la socket de service ?",
        "options": [
            "`socket()`",
            "`bind()`",
            "`listen()`",
            "`accept()`"
        ],
        "answer": 3,
        "explanation": "Bien que peu détaillée, le texte mentionne que les demandes sont 'validées par l'application via accept()', ce qui finalise l'entrée.",
        "chapterId": 1
    },
    {
        "id": 31,
        "question": "Code :\n```c\nstruct sockaddr_in addr;\naddr.sin_port = htons(8080);\n```\nPourquoi utiliser `htons` ?",
        "options": [
            "Pour convertir l'entier 8080 (Format Hôte) en format Réseau (Big Endian).",
            "Pour crypter le port.",
            "Pour vérifier si le port est libre.",
            "C'est une fonction d'affichage."
        ],
        "answer": 0,
        "explanation": "Les réseaux (IP) utilisent le Big Endian. Les PC (x86) utilisent le Little Endian. `htons` (Host To Network Short) fait la conversion indispensable.",
        "chapterId": 1
    },
    {
        "id": 32,
        "question": "Dans le code serveur :\n```c\nint newsock = accept(listening_socket, ...);\nif (fork() == 0) {\n   close(listening_socket);\n   // traitement client\n}\n```\nPourquoi le processus fils ferme-t-il `listening_socket` ?",
        "options": [
            "Car il n'en a pas besoin : son rôle est de traiter le client courant (via `newsock`), pas d'accepter les autres.",
            "Pour arrêter le serveur.",
            "C'est une erreur, il ne devrait pas.",
            "Pour libérer de la mémoire RAM."
        ],
        "answer": 0,
        "explanation": "Bonne pratique Unix : le fils hérite de tous les descripteurs. Il doit fermer ceux qui ne lui servent pas pour éviter les fuites ou les conflits.",
        "chapterId": 1
    },
    {
        "id": 33,
        "question": "Si `malloc` échoue, `errno` est positionné. Mais si `socket()` retourne -1, où est le code d'erreur ?",
        "options": [
            "Dans la variable globale `errno` également.",
            "Dans le code de retour directement.",
            "Il n'y en a pas.",
            "Dans stderr."
        ],
        "answer": 0,
        "explanation": "Standard C/Unix : les appels système retournent -1 en cas d'échec et placent la cause exacte dans `errno`.",
        "chapterId": 1
    },
    {
        "id": 34,
        "question": "Code :\n```c\nchar buf[100];\nrecv(s, buf, 100, 0);\n```\nCe code est-il sûr pour afficher la chaîne lue avec `printf(\"%s\", buf)` ?",
        "options": [
            "Oui, absolument.",
            "Non, car TCP ne garantit pas que les données reçues se terminent par '\\0' (null terminator).",
            "Non, car `buf` est trop petit.",
            "Oui, `recv` ajoute toujours un \\0."
        ],
        "answer": 1,
        "explanation": "Piège classique C ! `recv` remplit des octets bruts. Si l'émetteur n'a pas envoyé le \\0, `printf` va lire la mémoire après le buffer et crasher (SegFault).",
        "chapterId": 1
    },
    {
        "id": 35,
        "question": "Quelle fonction permet de convertir \"192.168.1.1\" (String) en structure binaire `in_addr` ?",
        "options": [
            "`inet_pton()` ou `inet_addr()`",
            "`htons()`",
            "`gethostname()`",
            "`atoi()`"
        ],
        "answer": 0,
        "explanation": "`inet_pton` (Pointer to Network) est la version moderne pour transformer une IP texte en bits réseaux.",
        "chapterId": 1
    },
    {
        "id": 36,
        "question": "Un serveur UDP doit-il utiliser `listen()` et `accept()` ?",
        "options": [
            "Oui, comme en TCP.",
            "Non, UDP est sans connexion. On utilise directement `recvfrom()`.",
            "Seulement `listen()`.",
            "Seulement `accept()`."
        ],
        "answer": 1,
        "explanation": "En UDP, pas de handshake. Le serveur attend juste des paquets arrivant sur le port ('Lettre dans la boîte aux lettres').",
        "chapterId": 1
    },
    {
        "id": 37,
        "question": "Code :\n```c\nint opt = 1;\nsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n```\nÀ quoi sert cette ligne souvent vue dans les serveurs ?",
        "options": [
            "À augmenter la vitesse.",
            "À redémarrer le serveur immédiatement sans attendre le timeout du port (TIME_WAIT) après un crash.",
            "À sécuriser la connexion.",
            "À accepter plusieurs clients."
        ],
        "answer": 1,
        "explanation": "Sans `SO_REUSEADDR`, si le serveur est tué, le port reste bloqué par l'OS quelques minutes. Cette option permet de le reprendre de suite.",
        "chapterId": 1
    },
    {
        "id": 38,
        "question": "Dans `struct sockaddr_in`, le champ `sin_family` doit être initialisé à :",
        "options": [
            "AF_INET",
            "SOCK_STREAM",
            "IP_PROTO",
            "Le port"
        ],
        "answer": 0,
        "explanation": "C'est la 'carte d'identité' de la structure, disant 'Je contiens une adresse IPv4'.",
        "chapterId": 1
    },
    {
        "id": 39,
        "question": "Si `connect()` retourne -1 avec `errno = EINPROGRESS`, cela signifie :",
        "options": [
            "Une erreur fatale.",
            "Que la socket est non-bloquante et que la connexion est en cours d'établissement en arrière-plan.",
            "Que le câble est débranché.",
            "Que le serveur est éteint."
        ],
        "answer": 1,
        "explanation": "Concept avancé : Sur une socket non-bloquante, `connect` ne peut pas attendre le handshake, donc il rend la main immédiatement en disant 'C'est en cours'.",
        "chapterId": 1
    },
    {
        "id": 40,
        "question": "La fonction `getaddrinfo` est préférée à `gethostbyname` car :",
        "options": [
            "Elle est compatible IPv4 et IPv6 de manière transparente.",
            "Elle est plus rapide.",
            "Elle est plus facile à écrire.",
            "`gethostbyname` ne marche pas sous Linux."
        ],
        "answer": 0,
        "explanation": "C'est la norme POSIX moderne. Elle gère seule la complexité des deux protocoles IP.",
        "chapterId": 1
    }
]