[
    {
        "id": 154,
        "question": "Analysez ce code :\n```java\nKeyGenerator kg = KeyGenerator.getInstance(\"AES\");\nkg.init(256);\nSecretKey key = kg.generateKey();\n```\nDans un environnement standard, pourquoi ce code pourrait-il poser problème historiquement ?",
        "options": [
            "L'algorithme AES n'existe pas.",
            "Certaines législations (et donc le JDK par défaut) limitaient la taille des clés symétriques à 128 bits.",
            "KeyGenerator ne gère pas les tailles de clés.",
            "Il faut obligatoirement un Provider externe."
        ],
        "answer": 1,
        "explanation": "Bien que moins vrai sur les JDK récents, l'export de cryptographie forte (256 bits) était restreint par les lois américaines, nécessitant des fichiers de police spécifiques.",
        "chapterId": 5
    },
    {
        "id": 155,
        "question": "Quelle est la différence fondamentale dans l'usage de `KeyGenerator` et `KeyPairGenerator` ?",
        "options": [
            "Aucune différence.",
            "`KeyGenerator` pour symétrique (AES), `KeyPairGenerator` pour asymétrique (RSA).",
            "`KeyPairGenerator` est thread-safe, l'autre non.",
            "`KeyGenerator` crée des certificats."
        ],
        "answer": 1,
        "explanation": "Memorisez: 'Pair' = Clé Publique + Privée = Asymétrique.",
        "chapterId": 5
    },
    {
        "id": 156,
        "question": "Regardez ce bout de code :\n```java\nc.init(Cipher.ENCRYPT_MODE, secretKey);\nbyte[] c1 = c.update(msg1);\nbyte[] c2 = c.doFinal(msg2);\n```\nQuelle est la différence principale entre `update` et `doFinal` ?",
        "options": [
            "`update` traite les données intermédiaires (mémoire tampon), `doFinal` termine l'opération (padding).",
            "`update` chiffre, `doFinal` déchiffre.",
            "`update` est pour AES, `doFinal` pour RSA.",
            "C'est pareil."
        ],
        "answer": 0,
        "explanation": "`update` permet de chiffrer un flux en continu morceau par morceau. `doFinal` signale qu'il n'y a plus de données et qu'il faut appliquer le bourrage (Padding) final.",
        "chapterId": 5
    },
    {
        "id": 157,
        "question": "Dans l'architecture JCA, à quoi sert la classe `java.security.Provider` ?",
        "options": [
            "À fournir les accès réseaux.",
            "À faire l'interface entre l'API Java et les implémentations crypto réelles.",
            "À stocker les mots de passe.",
            "C'est une classe dépréciée."
        ],
        "answer": 1,
        "explanation": "Les Providers (ex: SunJCE, BouncyCastle) contiennent le code réel. `Cipher.getInstance()` cherche dans les providers installés.",
        "chapterId": 5
    },
    {
        "id": 158,
        "question": "Quel est le résultat de `key.getEncoded()` sur une `SecretKey` ?",
        "options": [
            "Le hash de la clé.",
            "Les octets bruts de la clé (Raw bytes).",
            "Une chaîne encodée en Base64.",
            "Un objet X509EncodedKeySpec."
        ],
        "answer": 1,
        "explanation": "`getEncoded()` retourne `byte[]`. Pour l'afficher chiffré, il faudrait l'encoder soi-même en Base64.",
        "chapterId": 5
    },
    {
        "id": 159,
        "question": "Analysez ce code :\n```java\nMessageDigest md = MessageDigest.getInstance(\"SHA-256\");\nmd.update(partie1);\nbyte[] hash = md.digest(partie2);\n```\nQue contient le tableau `hash` ?",
        "options": [
            "Le hash de `partie2` uniquement.",
            "Le hash de `partie1` uniquement.",
            "Le hash de la concaténation `partie1 + partie2`.",
            "Une erreur car on ne peut pas mélanger update et digest."
        ],
        "answer": 2,
        "explanation": "`update` accumule les données. `digest(bytes)` fait un dernier update puis calcule le hash final de TOUT ce qui a été accumulé.",
        "chapterId": 5
    },
    {
        "id": 160,
        "question": "Quelle interface Java représente une clé asymétrique privée ?",
        "options": [
            "`java.security.PrivateKey`",
            "`javax.crypto.SecretKey`",
            "`java.security.KeyPair`",
            "`java.security.KeyStore`"
        ],
        "answer": 0,
        "explanation": "Logique de nommage directe. Elle étend `Key`.",
        "chapterId": 5
    },
    {
        "id": 161,
        "question": "Dans quel format standard la méthode `getEncoded()` retourne-t-elle habituellement une `PublicKey` ?",
        "options": [
            "RAW",
            "PKCS#8",
            "X.509 (SubjectPublicKeyInfo)",
            "PKCS#12"
        ],
        "answer": 2,
        "explanation": "Piège mémoriel : Public = X.509, Privé = PKCS#8.",
        "chapterId": 5
    },
    {
        "id": 162,
        "question": "Le code suivant échoue à l'exécution. Pourquoi ?\n```java\nCipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\nc.init(Cipher.DECRYPT_MODE, secretKey);\n// pas d'IV fourni ...\nbyte[] clair = c.doFinal(chiffre);\n```",
        "options": [
            "La clé est invalide.",
            "L'algorithme n'existe pas.",
            "En mode CBC, un Vecteur d'Initialisation (IV) est obligatoire pour déchiffrer.",
            "Le padding est incorrect."
        ],
        "answer": 2,
        "explanation": "Le mode CBC (Chainage de blocs) a besoin de l'état précédent pour commencer. Pour le premier bloc, cet état est l'IV. Sans lui, impossible de déchiffrer.",
        "chapterId": 5
    },
    {
        "id": 163,
        "question": "Quelle classe permet d'assurer l'intégrité ET l'authenticité d'un message via une clé secrète ?",
        "options": [
            "`MessageDigest`",
            "`Mac` (HMAC)",
            "`Signature`",
            "`Cipher`"
        ],
        "answer": 1,
        "explanation": "`MessageDigest` = Intégrité seule (n'importe qui peut le recalculer). `Mac` = Intégrité + Preuve d'origine (car nécessite la clé secrète).",
        "chapterId": 5
    },
    {
        "id": 164,
        "question": "Dans le code suivant :\n```java\nSignature sig = Signature.getInstance(\"SHA256withRSA\");\nsig.initVerify(pubKey);\nsig.update(data);\nboolean ok = sig.verify(signatureBytes);\n```\nSi `ok` vaut `false`, cela signifie :",
        "options": [
            "Que la clé publique est invalide.",
            "Que les données ont été altérées OU que la signature ne correspond pas à la clé privée associée.",
            "Que le programme a planté.",
            "Que l'algorithme n'est pas supporté."
        ],
        "answer": 1,
        "explanation": "C'est le but de la signature : garantir que les données sont intactes et signées par le possesseur de la clé privée.",
        "chapterId": 5
    },
    {
        "id": 165,
        "question": "Peut-on récupérer la clé privée à partir d'un objet `X509Certificate` standard ?",
        "options": [
            "Oui, avec `getPrivateKey()`.",
            "Oui, si on est admin.",
            "Non, jamais. Le certificat est public.",
            "Oui, via le KeyStore associé."
        ],
        "answer": 2,
        "explanation": "Un certificat contient l'identité et la clé PUBLIQUE. La clé privée est gardée secrète par le propriétaire.",
        "chapterId": 5
    },
    {
        "id": 166,
        "question": "Pour charger un `KeyStore` (format PKCS12 ou JKS) depuis un fichier, quel argument est CRITIQUE pour vérifier son intégrité ?",
        "options": [
            "Le nom du fichier.",
            "Le password du KeyStore (char[]).",
            "Le provider.",
            "La date de modification."
        ],
        "answer": 1,
        "explanation": "`store.load(stream, password)`. Le mot de passe sert souvent à vérifier un hash d'intégrité du fichier pour s'assurer qu'il n'a pas été corrompu.",
        "chapterId": 5
    },
    {
        "id": 167,
        "question": "Qu'est-ce qu'un `Salt` (sel) dans le contexte du chiffrement de mot de passe (PBE) ?",
        "options": [
            "Une donnée aléatoire ajoutée au mot de passe avant hachage pour empêcher les attaques par Rainbow Tables.",
            "Un type de clé.",
            "Un algorithme de padding.",
            "Une erreur de codage."
        ],
        "answer": 0,
        "explanation": "Le sel rend unique le hachage de deux mots de passe identiques.",
        "chapterId": 5
    },
    {
        "id": 168,
        "question": "Code :\n```java\nKeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\nkeyGen.init(256, new SecureRandom());\n```\nPourquoi utilise-t-on `SecureRandom` ici ?",
        "options": [
            "Pour que la clé générée soit réellement aléatoire et imprédictible.",
            "C'est juste une convention de nommage.",
            "Pour accélérer la génération.",
            "Car `Random` est déprécié."
        ],
        "answer": 0,
        "explanation": "En sécurité, un générateur pseudo-aléatoire classique (comme `java.util.Random`) est prédictible si on connaît sa graine. `SecureRandom` utilise l'entropie du système pour garantir l'aléatoire.",
        "chapterId": 5
    },
    {
        "id": 169,
        "question": "Quelle exception générique (checked) est la parente de la plupart des erreurs crypto (BadPadding, NoSuchAlgo...) ?",
        "options": [
            "`RuntimeException`",
            "`IOException`",
            "`GeneralSecurityException`",
            "`CryptoException`"
        ],
        "answer": 2,
        "explanation": "`java.security.GeneralSecurityException` regroupe `NoSuchAlgorithmException`, `InvalidKeyException`, etc.",
        "chapterId": 5
    },
    {
        "id": 170,
        "question": "`Mac.getInstance(\"HmacSHA256\")` attend quel type de clé avec `init()` ?",
        "options": [
            "`PublicKey`",
            "`PrivateKey`",
            "`SecretKey`",
            "N'importe quelle clé."
        ],
        "answer": 2,
        "explanation": "HMAC est un algorithme à clé symétrique (partagée).",
        "chapterId": 5
    },
    {
        "id": 171,
        "question": "Pourquoi préfère-t-on souvent une approche hybride (AES + RSA) pour chiffrer des gros fichiers ?",
        "options": [
            "RSA est limité en taille de données et est beaucoup plus lent que AES.",
            "AES ne fonctionne pas sur les gros fichiers.",
            "RSA n'est pas sécurisé pour les fichiers.",
            "C'est obligatoire en Java."
        ],
        "answer": 0,
        "explanation": "RSA (Asymétrique) est très coûteux en calcul et limité par la taille de la clé. AES (Symétrique) est très rapide. On chiffre le fichier en AES, et la clé AES en RSA.",
        "chapterId": 5
    },
    {
        "id": 172,
        "question": "À quoi sert la méthode `Certificate.verify(PublicKey key)` ?",
        "options": [
            "À vérifier que le certificat appartient bien à cette clé publique.",
            "À vérifier que le certificat a bien été SIGNÉ par l'autorité possédant cette clé publique (l'émetteur).",
            "À vérifier la date du certificat.",
            "À vérifier l'identité du porteur."
        ],
        "answer": 1,
        "explanation": "On vérifie la signature de l'émetteur (CA) présente sur le certificat en utilisant la clé publique de cet émetteur.",
        "chapterId": 5
    },
    {
        "id": 173,
        "question": "Dans `KeyStore`, un alias (nom d'entrée) est-il sensible à la casse ?",
        "options": [
            "Oui, \"monCert\" != \"moncert\".",
            "Non, c'est insensible à la casse (implémentation dépendante souvent, mais par défaut en JKS oui/non variable). En fait, la spec dit :",
            "En général Oui (Case Sensitive).",
            "En général Non."
        ],
        "answer": 2,
        "explanation": "Dans la plupart des implémentations (JKS, PKCS12), les alias sont Case Sensitive. C'est un piège fréquent.",
        "chapterId": 5
    },
    {
        "id": 174,
        "question": "Quelle classe utilise-t-on pour transformer un mot de passe (String) en clé secrète pour AES ?",
        "options": [
            "`KeyGenerator`",
            "`SecretKeyFactory` avec `PBEKeySpec`.",
            "`KeyPairGenerator`",
            "`Cipher`"
        ],
        "answer": 1,
        "explanation": "Il faut dériver le mot de passe (PBKDF2 par exemple) via une Factory pour obtenir une clé binaire robuste.",
        "chapterId": 5
    },
    {
        "id": 175,
        "question": "Code :\n```java\ncipher.init(Cipher.ENCRYPT_MODE, key);\nbyte[] out = cipher.doFinal(input);\n```\nSi le mode est `ECB`, le chiffrement est-il déterministe (même entrée = même sortie) ?",
        "options": [
            "Non, il y a toujours un aléatoire.",
            "Oui, absolument (manque de diffusion).",
            "Ça dépend du padding.",
            "Ça dépend de la clé."
        ],
        "answer": 1,
        "explanation": "C'est la faille de ECB (Electronic Code Book). Chaque bloc est chiffré indépendamment. Deux blocs identiques donnent deux chiffrés identiques. Dangereux pour les images ou textes répétitifs.",
        "chapterId": 5
    },
    {
        "id": 176,
        "question": "Quel objet permet de parcourir les certificats d'une chaîne de certification (`CertPath`) ?",
        "options": [
            "`CertificateFactory`",
            "`CertPathValidator`",
            "`KeyManager`",
            "`TrustManager`"
        ],
        "answer": 1,
        "explanation": "Le validateur vérifie la chaîne complète jusqu'à la racine de confiance.",
        "chapterId": 5
    },
    {
        "id": 177,
        "question": "`MessageDigest.isEqual(byte[] a, byte[] b)` est préférable à `Arrays.equals(a, b)` pour comparer des hashs. Pourquoi ?",
        "options": [
            "Elle est plus rapide.",
            "Elle évite les attaques par canal auxiliaire (Timing Attacks) en prenant un temps constant.",
            "Elle supporte le null.",
            "Elle logge les erreurs."
        ],
        "answer": 1,
        "explanation": "`Arrays.equals` s'arrête au premier octet différent. Un attaquant peut mesurer ce temps pour deviner le hash octet par octet. `isEqual` compare tout quoiqu'il arrive.",
        "chapterId": 5
    },
    {
        "id": 178,
        "question": "Si je reçois une `BadPaddingException` lors du déchiffrement (`doFinal`), la cause la plus probable est :",
        "options": [
            "L'algo de padding est mauvais.",
            "La clé utilisée pour déchiffrer n'est pas la bonne.",
            "Le message est trop court.",
            "La mémoire est pleine."
        ],
        "answer": 1,
        "explanation": "Si la clé est fausse, le déchiffrement produit de la bouillie aléatoire. Le dernier bloc ne correspondra pas au format structurel du padding (PKCS5), d'où l'exception.",
        "chapterId": 5
    },
    {
        "id": 179,
        "question": "Comment stocker une clé symétrique dans un KeyStore ?",
        "options": [
            "`setCertificateEntry`",
            "`setKeyEntry` avec `KeyStore.SecretKeyEntry`.",
            "`setKeyEntry` avec un mot de passe de protection.",
            "On ne peut pas, KeyStore est pour RSA."
        ],
        "answer": 2,
        "explanation": "`ks.setKeyEntry(alias, secretKey, password, null)`. Le password sert à chiffrer la clé dans le fichier.",
        "chapterId": 5
    },
    {
        "id": 180,
        "question": "Dans le code : `Cipher.getInstance(\"AES/CBC/PKCS5Padding\")`, que signifie \"CBC\" ?",
        "options": [
            "Cipher Block Chaining : Les blocs sont chaînés pour diffuser l'information.",
            "Code Book Cipher : Chaque bloc est indépendant.",
            "Cryptage Basique Complet.",
            "Control Block Check."
        ],
        "answer": 0,
        "explanation": "C'est le mode de fonctionnement. Contrairement à ECB, CBC mélange le bloc précédent avec le suivant, rendant l'analyse plus difficile.",
        "chapterId": 5
    },
    {
        "id": 181,
        "question": "Pourquoi utiliser `CipherInputStream` ?",
        "options": [
            "Pour chiffrer/déchiffrer des flux de données (fichiers, sockets) sans tout charger en mémoire RAM.",
            "Pour chiffrer plus vite.",
            "Pour gérer les clés.",
            "Pour compresser."
        ],
        "answer": 0,
        "explanation": "Il encapsule un `InputStream` et passe les données à travers un objet `Cipher` au vol.",
        "chapterId": 5
    },
    {
        "id": 182,
        "question": "Quelle classe pour parser un certificat X.509 encodé en Base64 (PEM) ?",
        "options": [
            "`KeyParser`",
            "`CertificateFactory`",
            "`X509Factory`",
            "`PEMParser`"
        ],
        "answer": 1,
        "explanation": "`CertificateFactory.getInstance(\"X.509\").generateCertificate(inputStream)`.",
        "chapterId": 5
    },
    {
        "id": 183,
        "question": "Le mot-clé `transient` peut-il affecter la sécurité d'un objet contenant une clé ?",
        "options": [
            "Non.",
            "Oui, il empêche la sérialisation (écriture sur disque) de champs sensibles comme la clé.",
            "Oui, il chiffre le champ.",
            "Non, c'est pour l'interface graphique."
        ],
        "answer": 1,
        "explanation": "Bonne pratique : ne pas sérialiser les clés secrètes par inadvertance.",
        "chapterId": 5
    },
    {
        "id": 184,
        "question": "L'algorithme \"SHA1withRSA\" est-il recommandé aujourd'hui ?",
        "options": [
            "Oui, c'est le standard.",
            "Non, SHA1 est cassé (collisions). Il faut utiliser SHA256withRSA au minimum.",
            "Oui, pour les cartes à puce uniquement.",
            "Non, RSA est cassé."
        ],
        "answer": 1,
        "explanation": "SHA-1 est obsolète depuis des années. Les signatures générées ne sont plus considérées comme sûres.",
        "chapterId": 5
    },
    {
        "id": 185,
        "question": "L'interface `Key` définit la méthode `getEncoded()`. Que retourne-t-elle ?",
        "options": [
            "Le nom de l'algorithme.",
            "La clé sous sa forme binaire brute (byte[]).",
            "Une chaîne Base64.",
            "L'adresse mémoire de l'objet."
        ],
        "answer": 1,
        "explanation": "C'est la représentation 'primaire' de la clé, permettant de la sauvegarder ou de la transmettre.",
        "chapterId": 5
    },
    {
        "id": 186,
        "question": "Quelle méthode permet de valider si un certificat X509 est valide à la date d'aujourd'hui ?",
        "options": [
            "`checkValidity()`",
            "`isValid()`",
            "`verifyDate()`",
            "`getNotAfter()`"
        ],
        "answer": 0,
        "explanation": "`checkValidity()` (sans arguments) vérifie par rapport à la date système courante.",
        "chapterId": 5
    },
    {
        "id": 187,
        "question": "Peut-on utiliser le même objet `Cipher` pour chiffrer puis déchiffrer ?",
        "options": [
            "Impossible.",
            "Oui, en appelant `init` à nouveau avec le mode inverse (DECRYPT_MODE).",
            "Oui, sans rien faire faire.",
            "Seulement pour RSA."
        ],
        "answer": 1,
        "explanation": "Les objets Cipher sont réutilisables, mais il faut les réinitialiser via `init` pour changer de mode ou de clé.",
        "chapterId": 5
    },
    {
        "id": 188,
        "question": "Un `KeyStore` de type \"JKS\" est-il compatible avec d'autres langages (C++, Python) ?",
        "options": [
            "Oui, c'est un standard.",
            "Non, JKS (Java KeyStore) est spécifique à Java. Il vaut mieux utiliser PKCS12 pour l'interopérabilité.",
            "Oui, avec une librairie.",
            "Non, JKS est crypté."
        ],
        "answer": 1,
        "explanation": "PKCS#12 (.p12) est le standard industriel multi-plateforme. JKS est Java-only.",
        "chapterId": 5
    },
    {
        "id": 189,
        "question": "Quel est l'avantage du mode CBC par rapport au mode ECB ?",
        "options": [
            "Il masque les motifs répétitifs dans les données (comme le fond d'une image).",
            "Il est plus rapide.",
            "Il n'a pas besoin d'IV.",
            "Il est par défaut en Java."
        ],
        "answer": 0,
        "explanation": "ECB (Electronic Code Book) chiffre chaque bloc identique de la même manière. CBC introduit de l'aléatoire via le chaînage, ce qui sécurise mieux les données structurées.",
        "chapterId": 5
    },
    {
        "id": 190,
        "question": "Quelle assertion est VRAIE concernant `KeyPairGenerator.initialized(int keysize)` ?",
        "options": [
            "Plus la taille est grande, plus la génération est rapide.",
            "La taille de clé RSA recommandée aujourd'hui est 1024.",
            "La taille recommandée est au moins 2048, et la génération est coûteuse en CPU.",
            "La taille n'a pas d'impact."
        ],
        "answer": 2,
        "explanation": "Générer des nombres premiers pour RSA 2048 ou 4096 bits prend du temps. 1024 est considéré comme faible.",
        "chapterId": 5
    },
    {
        "id": 191,
        "question": "Si j'appelle `MessageDigest.digest()` deux fois de suite sur le même objet sans remettre de données :",
        "options": [
            "Il retourne le même hash.",
            "Il retourne le hash d'une chaîne vide (ou d'un contenu vide).",
            "Il lève une exception.",
            "Il retourne null."
        ],
        "answer": 1,
        "explanation": "Après le premier `digest()`, le moteur est reset. Le second appel calcule donc le hash de \"rien\" (Empty String Hash).",
        "chapterId": 5
    },
    {
        "id": 192,
        "question": "Code :\n```java\nc.init(Cipher.ENCRYPT_MODE, k, new IvParameterSpec(iv));\n```\nQuelle condition doit respecter `iv` pour la sécurité AES-CBC ?",
        "options": [
            "Il doit être secret.",
            "Il doit être unique et imprédictible pour chaque message.",
            "Il doit être constant.",
            "Il doit être de la même taille que le message."
        ],
        "answer": 1,
        "explanation": "L'IV n'a pas besoin d'être secret (on l'envoie en clair). Par contre, réutiliser le même IV avec la même clé compromet la sécurité (patterns visibles).",
        "chapterId": 5
    },
    {
        "id": 193,
        "question": "Quel Provider Java est connu pour fournir beaucoup plus d'algorithmes que le JDK standard ?",
        "options": [
            "Bouncy Castle",
            "Apache Commons",
            "Log4j",
            "Spring Security"
        ],
        "answer": 0,
        "explanation": "Bouncy Castle est la référence Open Source pour les algos crypto non inclus dans le JDK (ex: certains algos Elliptic Curve, RIPEMD, etc.).",
        "chapterId": 5
    }
]