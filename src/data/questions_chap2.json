[
    {
        "id": 84,
        "question": "Concernant la mémoire partagée dans un processus Java, quelle affirmation est EXACTE ?",
        "options": [
            "Les threads partagent le Tas (Heap) et la Pile (Stack).",
            "Chaque thread possède son propre Tas, mais partage les variables statiques.",
            "Les threads partagent le Tas et les variables statiques, mais chaque thread a sa propre Pile (Stack).",
            "Tout est partagé, il n'y a aucune isolation mémoire entre threads."
        ],
        "answer": 2,
        "explanation": "Piège classique : Les objets (Heap) sont partagés, mais les variables locales (Stack) sont strictement isolées et propres à chaque thread.",
        "chapterId": 2
    },
    {
        "id": 85,
        "question": "Analysez ce code :\n```java\nThread t = new Thread(r);\nt.run();\n```\nQue se passe-t-il exactement ?",
        "options": [
            "Une `IllegalThreadStateException` est levée.",
            "Le code de `run()` s'exécute, mais dans le thread courant (main), PAS dans un nouveau thread.",
            "Rien ne se passe.",
            "Le thread démarre normalement en parallèle."
        ],
        "answer": 1,
        "explanation": "Piège classique : `run()` est une méthode comme une autre. Seul `start()` appelle le système d'exploitation pour 'spawner' un vrai process léger.",
        "chapterId": 2
    },
    {
        "id": 86,
        "question": "Pourquoi l'usage de `Runnable` est-il recommandé par rapport à l'héritage de `Thread` ?",
        "options": [
            "Car `Runnable` possède plus de méthodes que `Thread`.",
            "Car on ne peut pas appeler `start()` sur une sous-classe de `Thread`.",
            "Car Java ne supporte pas l'héritage multiple, donc implémenter `Runnable` laisse la possibilité d'hériter d'une autre classe.",
            "C'est faux, l'héritage est toujours recommandé."
        ],
        "answer": 2,
        "explanation": "C'est une question de design et de limitation du langage. De plus, cela sépare la tâche (Runnable) de l'exécutant (Thread).",
        "chapterId": 2
    },
    {
        "id": 87,
        "question": "Code :\n```java\nsynchronized(obj) {\n    Thread.sleep(1000);\n}\n```\nQue fait le verrou (monitor) sur `obj` pendant la pause ?",
        "options": [
            "Il est relâché le temps de la pause, permettant aux autres d'accéder à `obj`.",
            "Il est conservé par le thread dormant : personne ne peut prendre le verrou.",
            "Il est détruit.",
            "Le code ne compile pas."
        ],
        "answer": 1,
        "explanation": "Différence cruciale avec `wait()` : `sleep()` garde ses verrous ('Il dort poings fermés'). Cela peut bloquer toute l'application.",
        "chapterId": 2
    },
    {
        "id": 88,
        "question": "Dans le code `t.join()`, quel thread est bloqué ?",
        "options": [
            "Le thread `t` (il est mis en pause).",
            "Le thread qui appelle la méthode `join()` (souvent le main).",
            "Tous les threads du groupe.",
            "Le thread système."
        ],
        "answer": 1,
        "explanation": "`t.join()` signifie 'Moi, thread appelant, j'attends que t ait fini'. `t` continue sa vie normalement.",
        "chapterId": 2
    },
    {
        "id": 89,
        "question": "Que fait réellement la méthode `t.interrupt()` ?",
        "options": [
            "Elle tue le thread immédiatement (arrêt forcé).",
            "Elle met le thread en pause.",
            "Elle positionne simplement un drapeau (flag) indiquant que l'interruption est demandée. Le thread doit le gérer.",
            "Elle lance une exception dans le thread appelant."
        ],
        "answer": 2,
        "explanation": "L'interruption est coopérative. Si le thread ignore le flag (ou ne gère pas l'exception InterruptedException), il ne s'arrêtera pas.",
        "chapterId": 2
    },
    {
        "id": 90,
        "question": "Si deux threads exécutent deux méthodes `synchronized` DIFFÉRENTES sur la MÊME instance d'objet :",
        "options": [
            "Ils peuvent s'exécuter en parallèle sans problème.",
            "Ils sont bloqués mutuellement, l'un doit attendre la fin de l'autre.",
            "Seule la méthode la plus prioritaire passe.",
            "Cela dépend si les méthodes sont statiques."
        ],
        "answer": 1,
        "explanation": "Le verrou est sur l'objet (`this`). Un seul thread peut détenir le verrou de l'instance, quel que soit le nombre de méthodes synchronized.",
        "chapterId": 2
    },
    {
        "id": 91,
        "question": "Quelle instruction lève une `IllegalMonitorStateException` ?",
        "options": [
            "Appeler `notify()` dans un bloc `synchronized`.",
            "Appeler `wait()` sans détenir le verrou de l'objet (hors bloc synchronized).",
            "Appeler `sleep()` dans un bloc `synchronized`.",
            "Appeler `start()` deux fois."
        ],
        "answer": 1,
        "explanation": "On ne peut attendre (`wait`) ou notifier sur un objet que si on en possède la clé (le moniteur).",
        "chapterId": 2
    },
    {
        "id": 92,
        "question": "Code :\n```java\nThread t = new Thread(task);\nt.start();\nt.setDaemon(true);\n```\nQuel est le résultat ?",
        "options": [
            "Le thread devient un démon.",
            "Une exception `IllegalThreadStateException` est levée.",
            "Rien, le setDaemon est ignoré.",
            "Le thread s'arrête."
        ],
        "answer": 1,
        "explanation": "On ne peut pas changer la nature (User/Daemon) d'un thread une fois qu'il est vivant (`start()` appelé). Il faut le faire avant.",
        "chapterId": 2
    },
    {
        "id": 93,
        "question": "Que garantit l'appel à `Thread.yield()` ?",
        "options": [
            "Que le thread va s'arrêter pour laisser la place aux autres.",
            "Que le thread va dormir pendant 100ms.",
            "Rien de strict : c'est une simple suggestion au planificateur (scheduler) de passer la main.",
            "Que les threads de priorité inférieure vont s'exécuter."
        ],
        "answer": 2,
        "explanation": "`yield` est une heuristique. L'OS peut choisir de l'ignorer totalement. Ce n'est pas un mécanisme de synchronisation fiable.",
        "chapterId": 2
    },
    {
        "id": 94,
        "question": "Concernant `ThreadGroup.activeCount()`, pourquoi est-ce un 'piège' ?",
        "options": [
            "La méthode retourne toujours 0.",
            "La valeur retournée est une estimation instantanée qui peut être fausse la nanoseconde suivante.",
            "Elle compte aussi les threads arrêtés.",
            "Elle lance une exception."
        ],
        "answer": 1,
        "explanation": "Comme les threads démarrent et meurent en permanence, ce nombre est intrinsèquement imprécis.",
        "chapterId": 2
    },
    {
        "id": 95,
        "question": "Quelle est la règle d'or de Swing avec les Threads ?",
        "options": [
            "Tout code Swing doit être exécuté dans le thread principal (main).",
            "Swing est Thread-Safe, on peut modifier l'UI depuis n'importe où.",
            "Toute modification de l'UI doit se faire exclusivement dans l'EDT (Event Dispatch Thread).",
            "On doit utiliser `synchronized` sur chaque composant Swing."
        ],
        "answer": 2,
        "explanation": "Swing n'est pas Thread-Safe. Modifier un bouton depuis un thread worker peut corrompre l'affichage ou causer des plantages.",
        "chapterId": 2
    },
    {
        "id": 96,
        "question": "Quelle est la différence entre `synchronized void m()` et `static synchronized void m()` ?",
        "options": [
            "Aucune, c'est juste une syntaxe.",
            "La première verrouille l'instance (`this`), la seconde verrouille la classe (`Class object`).",
            "La statique est plus rapide.",
            "La statique empêche l'héritage."
        ],
        "answer": 1,
        "explanation": "Ce sont deux verrous distincts. Un thread peut appeler la méthode d'instance et un autre la méthode statique en même temps sans se bloquer.",
        "chapterId": 2
    },
    {
        "id": 97,
        "question": "Si un thread capture une exception non gérée (RuntimeException) :",
        "options": [
            "Le thread meurt, mais les autres threads continuent leur exécution.",
            "Tout le processus Java (JVM) s'arrête immédiatement.",
            "Le thread redémarre automatiquement.",
            "L'exception est convertie en `InterruptedException`."
        ],
        "answer": 0,
        "explanation": "Une exception non catchée tue le thread concerné. Si ce n'est pas le seul thread user, l'application survit - mais le thread est mort.",
        "chapterId": 2
    },
    {
        "id": 98,
        "question": "Peut-on utiliser `PipedInputStream` sans le connecter à un `PipedOutputStream` ?",
        "options": [
            "Oui, il lira des 0.",
            "Non, cela provoquera une exception ou un blocage.",
            "Oui, il agira comme un ByteArrayInputStream.",
            "Oui, mais seulement en écriture."
        ],
        "answer": 1,
        "explanation": "Les Pipes fonctionnent par paire. Un tube doit avoir deux bouts pour fonctionner simultanément.",
        "chapterId": 2
    },
    {
        "id": 99,
        "question": "À quoi correspond `synchronized` dans le monde théorique système POSIX ?",
        "options": [
            "Aux Sémaphores",
            "Aux Variables de Condition",
            "Aux Mutex (Mutual Exclusion)",
            "Aux Signaux"
        ],
        "answer": 2,
        "explanation": "Le texte fait explicitement le parallèle : synchronized = Mutex.",
        "chapterId": 2
    },
    {
        "id": 100,
        "question": "Pourquoi `stop()` est-elle considérée comme dangereuse est dépréciée ?",
        "options": [
            "Elle est trop lente à s'exécuter.",
            "Elle peut laisser les objets dans un état incohérent en relâchant brutalement les verrous.",
            "Elle ne fonctionne pas sur Linux.",
            "Elle empêche le Garbage Collector de passer."
        ],
        "answer": 1,
        "explanation": "La méthode `stop()` tue sans prévenir, ce qui peut corrompre les données partagées laissées à moitié modifiées.",
        "chapterId": 2
    },
    {
        "id": 101,
        "question": "Quel est le comportement du processus Java lorsqu'il ne reste que des threads Démons ?",
        "options": [
            "Il continue indéfiniment.",
            "Il se termine (sort de la JVM).",
            "Il attend qu'un nouveau thread User soit créé.",
            "Il lance une exception."
        ],
        "answer": 1,
        "explanation": "Les démons sont des threads de service (ex: GC). Si les User threads ont fini, les services n'ont plus de raison d'être.",
        "chapterId": 2
    },
    {
        "id": 102,
        "question": "Comment doit-on utiliser `wait()` correctement pour éviter les réveils intempestifs (spurious wakeups) ?",
        "options": [
            "Dans un bloc `if` qui vérifie la condition.",
            "Dans une boucle `while` qui revérifie la condition après le réveil.",
            "Sans condition, le `notify` garantit que c'est bon.",
            "Avec un timeout obligatoire."
        ],
        "answer": 1,
        "explanation": "Le texte indique 'Toujours utiliser while, jamais if' pour se protéger des cas où le thread est réveillé sans que la condition soit vraie.",
        "chapterId": 2
    },
    {
        "id": 104,
        "question": "Pour mettre à jour l'interface graphique Swing depuis un autre thread, quelle méthode faut-il appeler ?",
        "options": [
            "`SwingUtilities.updateComponent()`",
            "`EventQueue.invokeLater(Runnable)`",
            "`Thread.runOnUI()`",
            "`Component.repaint()`"
        ],
        "answer": 1,
        "explanation": "C'est la méthode canonique pour poster une tâche dans la file d'attente de l'EDT.",
        "chapterId": 2
    },
    {
        "id": 105,
        "question": "À quoi correspondent conceptuellement les méthodes `wait()` / `notify()` en système POSIX ?",
        "options": [
            "Aux Mutex",
            "Aux Variables de Condition",
            "Aux Pipes",
            "Aux Signaux"
        ],
        "answer": 1,
        "explanation": "Le texte fait le parallèle : Synchronized=Mutex, Wait/Notify=Variables de Condition.",
        "chapterId": 2
    },
    {
        "id": 106,
        "question": "Quelle classe de Timer est Thread-Safe et destinée à Swing ?",
        "options": [
            "`java.util.Timer`",
            "`javax.swing.Timer`",
            "`java.time.Timer`",
            "`android.os.CountDownTimer`"
        ],
        "answer": 1,
        "explanation": "Piège QCM : `javax.swing.Timer` exécute ses tâches sur l'EDT, ce qui le rend sûr pour manipuler l'interface.",
        "chapterId": 2
    },
    {
        "id": 107,
        "question": "Quelle méthode permet de réveiller TOUS les threads en attente sur un objet ?",
        "options": [
            "`notify()`",
            "`notifyAll()`",
            "`wakeAll()`",
            "`interruptAll()`"
        ],
        "answer": 1,
        "explanation": "`notifyAll()` réveille tout le monde, ce qui est généralement plus sûr que `notify()` qui en choisit un arbitrairement.",
        "chapterId": 2
    },
    {
        "id": 108,
        "question": "Est-ce qu'un thread qui a appelé `sleep()` perd ses verrous (moniteurs) ?",
        "options": [
            "Oui, toujours.",
            "Non, jamais.",
            "Seulement s'il dort plus de 1 seconde.",
            "Cela dépend de l'OS."
        ],
        "answer": 1,
        "explanation": "C'est la différence fondamentale avec `wait`. `sleep` garde les clés de la maison pendant qu'il dort.",
        "chapterId": 2
    },
    {
        "id": 109,
        "question": "Les PipedInputStream/OutputStream sont conçus pour une communication :",
        "options": [
            "Bidirectionnelle simultanée (Full Duplex)",
            "Unidirectionnelle (Half Duplex)",
            "Sans fil",
            "Entre machines distantes"
        ],
        "answer": 1,
        "explanation": "Le texte précise 'Communication unidirectionnelle' et 'utilisés par paire'.",
        "chapterId": 2
    },
    {
        "id": 110,
        "question": "Quelle méthode de Thread est native (implémentée via le système d'exploitation) ?",
        "options": [
            "`run`",
            "`start` (via `start0`)",
            "`getName`",
            "`setPriority`"
        ],
        "answer": 1,
        "explanation": "Le texte mentionne que certaines méthodes sont natives. La création de thread (`start`) nécessite un appel système lourd.",
        "chapterId": 2
    },
    {
        "id": 111,
        "question": "Si j'appelle `wait(1000)`, le thread se réveille :",
        "options": [
            "Exactement après 1000ms, quoi qu'il arrive.",
            "Au bout de 1000ms OU si on lui notifie (`notify`) avant.",
            "Seulement si un autre thread appelle `notify`.",
            "Jamais, c'est une boucle infinie."
        ],
        "answer": 1,
        "explanation": "C'est une attente avec timeout. Elle prend fin soit par notification, soit par expiration du délai.",
        "chapterId": 2
    },
    {
        "id": 112,
        "question": "Quel est le groupe de thread par défaut d'un nouveau thread ?",
        "options": [
            "System",
            "Root",
            "Le même groupe que le thread créateur (souvent 'main')",
            "DaemonGroup"
        ],
        "answer": 2,
        "explanation": "Le texte précise : 'Tout thread appartient à un groupe... Groupe par défaut : main' (ou celui du parent).",
        "chapterId": 2
    },
    {
        "id": 113,
        "question": "Peut-on appeler `start()` deux fois sur la même instance de Thread ?",
        "options": [
            "Oui, cela redémarre le thread.",
            "Non, cela lève une `IllegalThreadStateException`.",
            "Oui, mais la deuxième fois est ignorée.",
            "Non, cela plante la JVM."
        ],
        "answer": 1,
        "explanation": "Un objet Thread a un cycle de vie unique. Une fois démarré, il ne peut être réutilisé.",
        "chapterId": 2
    },
    {
        "id": 114,
        "question": "Pour envoyer des types primitifs (int, double) dans un Pipe, on encapsule souvent le flux dans :",
        "options": [
            "`ObjectOutputStream`",
            "`DataOutputStream`",
            "`BufferedOutputStream`",
            "`PrintStream`"
        ],
        "answer": 1,
        "explanation": "Le cours mentionne explicitement `DataOutputStream` pour cet usage.",
        "chapterId": 2
    },
    {
        "id": 115,
        "question": "Analysez ce code (Deadlock ?) :\n```java\nsynchronized(A) { synchronized(B) { ... } }\n// vs\nsynchronized(B) { synchronized(A) { ... } }\n```\nSi deux threads exécutent ces blocs en sens inverse, que risque-t-il d'arriver ?",
        "options": [
            "Rien, tout va bien.",
            "Interblocage (Deadlock) : chacun attend la ressource tenue par l'autre.",
            "Famine (Starvation).",
            "Race Condition."
        ],
        "answer": 1,
        "explanation": "C'est la définition classique du Deadlock (Étreinte fatale). Pour l'éviter, il faut toujours acquérir les verrous dans le même ordre.",
        "chapterId": 2
    },
    {
        "id": 116,
        "question": "Code :\n```java\nObject lock = new Object();\nsynchronized(lock) {\n    lock = new Object();\n}\n```\nCe code est-il correct pour la synchronisation ?",
        "options": [
            "Oui.",
            "Non, changer la référence de l'objet de verrouillage pendant le bloc est extrêmement dangereux et casse la synchronisation.",
            "Oui, car synchronized bloque le nom de la variable.",
            "Non, ça ne compile pas."
        ],
        "answer": 1,
        "explanation": "Le verrou est posé sur l'INSTANCE. Si on change la variable `lock` pour pointer vers une nouvelle instance, les autres threads se synchroniseront sur le NOUVEL objet, entrant en collision.",
        "chapterId": 2
    },
    {
        "id": 117,
        "question": "Quelle méthode permet d'attendre la fin d'un groupe de threads ?",
        "options": [
            "`group.join()`",
            "Il n'y en a pas, il faut faire `join()` sur chaque thread manuellement.",
            "`group.awaitTermination()`",
            "`group.stop()`"
        ],
        "answer": 1,
        "explanation": "`ThreadGroup` ne possède pas de méthode `joinAll`. C'est une limite de l'API historique.",
        "chapterId": 2
    },
    {
        "id": 118,
        "question": "Code :\n```java\nprivate volatile boolean running = true;\n```\nÀ quoi sert le mot-clé `volatile` ici ?",
        "options": [
            "À empêcher la modification de la variable.",
            "À garantir que toute modification par un thread est immédiatement visible par les autres (pas de cache CPU local).",
            "À rendre la variable atomique (i++ sûr).",
            "À crypter la variable."
        ],
        "answer": 1,
        "explanation": "`volatile` garantit la visibilité (Memory Barrier), mais pas l'atomicité des opérations composées. Utile pour les flags d'état.",
        "chapterId": 2
    },
    {
        "id": 119,
        "question": "Pourquoi `Stop` et `Suspend` sont-ils dépréciés ?",
        "options": [
            "Ils sont trop lents.",
            "Ils sont 'Unsafe' : Suspend peut causer des Deadlocks (garde les verrous), Stop peut corrompre les données.",
            "Ils ne marchent pas sur Mac.",
            "Ils sont remplacés par `Kill`."
        ],
        "answer": 1,
        "explanation": "Le thread tué ou suspendu ne peut pas nettoyer ses ressources ou relâcher ses verrous proprement.",
        "chapterId": 2
    },
    {
        "id": 120,
        "question": "Code :\n```java\nwait(1000);\n```\nSi personne ne notify, le thread reprend la main après 1s. A-t-il récupéré le verrou ?",
        "options": [
            "Non, il continue sans verrou.",
            "Oui, il DOIT se battre pour récupérer le verrou avant de sortir de la méthode `wait`.",
            "Oui, il l'a automatiquement.",
            "Cela dépend."
        ],
        "answer": 1,
        "explanation": "Important : `wait` (même avec timeout) ne retourne JAMAIS tant qu'il n'a pas ré-acquis le moniteur. Il se remet dans la file d'attente des verrous.",
        "chapterId": 2
    },
    {
        "id": 121,
        "question": "Code :\n```java\npublic synchronized void A() { B(); }\npublic synchronized void B() { ... }\n```\nUn thread peut-il appeler A() (qui appelle B) sans se bloquer lui-même ?",
        "options": [
            "Non, il y a deadlock (il a déjà le verrou).",
            "Oui, car les verrous Java sont Réentrants.",
            "Non, B est privé.",
            "Oui, mais seulement si B n'est pas synchronized."
        ],
        "answer": 1,
        "explanation": "Un thread qui possède déjà un verrou peut ré-entrer dans n'importe quel bloc protégé par ce MÊME verrou. C'est la réentrance.",
        "chapterId": 2
    },
    {
        "id": 122,
        "question": "Dans le modèle Producteur/Consommateur, pourquoi utilise-t-on `BlockingQueue` souvent ?",
        "options": [
            "C'est plus rapide.",
            "Elle gère elle-même toute la synchronisation (wait/notify) de manière Thread-Safe.",
            "Elle permet de trier les éléments.",
            "Elle est infinie."
        ],
        "answer": 1,
        "explanation": "C'est la version 'Haut Niveau' qui évite d'écrire soi-même les blocs synchronized/wait/notify sujets aux erreurs.",
        "chapterId": 2
    },
    {
        "id": 123,
        "question": "L'exception `InterruptedException` est une :",
        "options": [
            "RuntimeException (Unchecked).",
            "Checked Exception (doit être gérée).",
            "Error.",
            "N'existe pas."
        ],
        "answer": 1,
        "explanation": "Java force le développeur à gérer le cas où le thread se fait interrompre. On ne peut pas l'ignorer silencieusement.",
        "chapterId": 2
    },
    {
        "id": 124,
        "question": "Code :\n```java\nThread.currentThread().join();\n```\nQue fait cette ligne ?",
        "options": [
            "Rien.",
            "Le thread s'attend lui-même indéfiniment (Deadlock mono-thread).",
            "Le thread s'arrête.",
            "Le thread rejoint le groupe principal."
        ],
        "answer": 1,
        "explanation": "Logique : 'J'attends que JE finisse'. Comme je suis en train d'attendre, je ne finirai jamais. Bloquage éternel.",
        "chapterId": 2
    }
]