[
    {
        "id": 1,
        "question": "Juste après l'appel à `socket(AF_INET, SOCK_STREAM, 0)`, quel est l'état exact de la socket ?",
        "options": [
            "Elle est connectée à l'hôte local sur un port aléatoire.",
            "Elle est créée, mais anonyme (sans adresse IP ni port) et non connectée.",
            "Elle est automatiquement liée au port 0 en attente de `connect`.",
            "Elle est en mode écoute (listen) en attente de `accept`."
        ],
        "answer": 1,
        "explanation": "La socket est créée (descripteur alloué) mais n'a aucune identité réseau (anonyme) tant que `bind` ou `connect` n'est pas appelé. Elle n'est ni liée ni connectée.",
        "chapterId": 1
    },
    {
        "id": 2,
        "question": "Concernant la primitive `bind()` dans une architecture TCP Client/Serveur, quelle affirmation est strictement vraie ?",
        "options": [
            "Elle est optionnelle pour le serveur mais obligatoire pour le client afin de fixer son port source.",
            "Elle est obligatoire pour le serveur pour définir son écoute, mais le client comportement est indéfini s'il l'utilise.",
            "Elle est obligatoire pour le serveur, tandis que le client peut l'utiliser mais s'en remet généralement au noyau (bind implicite).",
            "Elle est obligatoire pour les deux parties afin de garantir l'unicité du couple {IP, Port}."
        ],
        "answer": 2,
        "explanation": "Le serveur *doit* être joignable sur un port connu. Le client *peut* choisir son port, mais laisse généralement l'OS choisir un port éphémère via un bind implicite.",
        "chapterId": 1
    },
    {
        "id": 3,
        "question": "Dans `listen(sockfd, backlog)`, que représente exactement l'entier `backlog` ?",
        "options": [
            "Le nombre maximum de connexions actives simultanées que le serveur peut gérer.",
            "Le nombre maximum de demandes de connexions en attente (handshake terminé, en attente d'accept).",
            "La taille en octets du buffer de réception pour cette socket.",
            "Le délai d'attente (timeout) en secondes avant de rejeter un client."
        ],
        "answer": 1,
        "explanation": "Le backlog définit la taille de la file d'attente des connexions *pending* (3-way handshake fini) que l'application n'a pas encore acceptées via `accept()`.",
        "chapterId": 1
    },
    {
        "id": 4,
        "question": "Quelle est la relation précise entre `write(fd, buf, len)` et `send(fd, buf, len, flags)` sous UNIX ?",
        "options": [
            "Elles sont strictement identiques, `write` est juste une macro pour `send` avec `flags=0`.",
            "Si `flags=0`, elles effectuent la même opération, mais `send` ne fonctionne que sur des sockets.",
            " `send` est plus rapide que `write` car elle contourne la couche VFS (Virtual File System).",
            " `write` ajoute automatiquement un terminateur nul au buffer, contrairement à `send`."
        ],
        "answer": 1,
        "explanation": "Sur une socket, `send` avec `flags=0` est équivalent à `write`. Cependant `send` est spécifique aux sockets, alors que `write` est générique pour tout fichier.",
        "chapterId": 1
    },
    {
        "id": 5,
        "question": "Que retourne l'appel système `accept(listening_socket, ...)` en cas de succès ?",
        "options": [
            "L'entier `0` pour confirmer que le handshake a réussi.",
            "Le même descripteur `listening_socket`, mais passé en mode connecté.",
            "Un nouveau descripteur de fichier spécifiquement dédié à cette connexion client.",
            "L'adresse IP du client sous forme d'entier."
        ],
        "answer": 2,
        "explanation": "`accept` crée une *nouvelle* socket pour la connexion établie. La socket d'origine reste en mode écoute (LISTEN) pour d'autres clients.",
        "chapterId": 1
    },
    {
        "id": 6,
        "question": "Vous lancez votre serveur et il échoue immédiatement avec l'erreur `EADDRINUSE`. Quelle est la cause la plus probable ?",
        "options": [
            "Le client distant a rejeté la connexion.",
            "Le serveur tente de se lier (bind) à un port déjà occupé par un autre processus ou une socket en attente.",
            "Le câble réseau est débranché.",
            "Les permissions root sont requises pour ouvrir une socket (EACCES)."
        ],
        "answer": 1,
        "explanation": "`EADDRINUSE` signifie que l'adresse (IP + Port) demandée est déjà utilisée localement par une autre socket.",
        "chapterId": 1
    },
    {
        "id": 7,
        "question": "Quel appel système déclenche l'envoi du paquet TCP SYN par le client ?",
        "options": [
            "Au moment de la création de la socket avec `socket()`.",
            "Au moment de l'appel à `bind()`.",
            "Au moment de l'appel à `connect()`.",
            "Lors du premier `send()` de données."
        ],
        "answer": 2,
        "explanation": "C'est `connect()` qui initie le '3-way handshake', commençant par l'envoi du SYN.",
        "chapterId": 1
    },
    {
        "id": 8,
        "question": "Si un client TCP appelle `close()` sur sa socket alors que le serveur ne fait rien, dans quel état finit la socket côté serveur ?",
        "options": [
            "La connexion reste totalement active jusqu'à ce que le serveur ferme aussi.",
            "La socket serveur passe immédiatement à l'état `CLOSED`.",
            "La socket serveur reçoit un EOF mais reste en `ESTABLISHED`.",
            "La connexion entre dans un état de fermeture passive (ex: `CLOSE_WAIT`), attendant que l'application serveur appelle `close`."
        ],
        "answer": 3,
        "explanation": "Le serveur reçoit un paquet FIN. L'OS passe la socket en `CLOSE_WAIT` et notifie l'application (read retourne 0). L'application *doit* fermer pour libérer les ressources.",
        "chapterId": 1
    },
    {
        "id": 9,
        "question": "Quelle combinaison de paramètres crée une socket UDP IPv4 valide ?",
        "options": [
            "`socket(AF_INET, SOCK_STREAM, IPPROTO_UDP)`",
            "`socket(AF_INET6, SOCK_DGRAM, 0)`",
            "`socket(AF_INET, SOCK_DGRAM, 0)`",
            "`socket(AF_UNIX, SOCK_DGRAM, 0)`"
        ],
        "answer": 2,
        "explanation": "`AF_INET` pour IPv4, `SOCK_DGRAM` pour le mode datagramme (UDP). Le 0 sélectionne le protocole par défaut (UDP).",
        "chapterId": 1
    },
    {
        "id": 10,
        "question": "Pourquoi l'erreur `ECONNREFUSED` survient-elle généralement lors d'un `connect()` ?",
        "options": [
            "Le réseau est physiquement déconnecté.",
            "Aucun processus n'écoute sur l'IP et le port cibles (port fermé).",
            "Le pare-feu a droppé le paquet silencieusement.",
            "L'adresse IP de destination est introuvable (Host Unreachable)."
        ],
        "answer": 1,
        "explanation": "`Connection Refused` signifie qu'un paquet RST a été renvoyé par la machine cible, indiquant qu'aucune socket n'écoute sur ce port.",
        "chapterId": 1
    },
    {
        "id": 11,
        "question": "Quel est la conséquence exacte de l'appel `socket()` sur le réseau ?",
        "options": [
            "Il envoie un paquet broadcast pour annoncer la présence.",
            "Il réserve un port auprès du switch réseau.",
            "Il n'a aucun effet sur le réseau, c'est une opération purement locale au noyau.",
            "Il ouvre une session TCP."
        ],
        "answer": 2,
        "explanation": "`socket()` alloue seulement des structures de données dans le noyau du système d'exploitation local. Aucun paquet n'est émis sur le réseau.",
        "chapterId": 1
    },
    {
        "id": 12,
        "question": "Quel est l'effet d'un `bind()` sur le port 0 ?",
        "options": [
            "Cela provoque immédiatement une erreur `EINVAL`.",
            "Cela lie la socket au port 0, qui est réservé et inutilisable.",
            "Cela demande au système d'exploitation d'attribuer automatiquement un port éphémère disponible.",
            "Cela lie la socket à tous les ports disponibles."
        ],
        "answer": 2,
        "explanation": "Binder sur le port 0 est une convention pour demander au noyau de choisir un port libre aléatoire (port éphémère).",
        "chapterId": 1
    },
    {
        "id": 13,
        "question": "Dans le modèle OSI simplifié pour les sockets, quelle structure doit être castée en `(struct sockaddr *)` ?",
        "options": [
            "`struct in_addr`",
            "`struct sockaddr_in`",
            "`struct ip_mreq`",
            "`struct hostent`"
        ],
        "answer": 1,
        "explanation": "Les fonctions sockets attendent un pointeur générique `struct sockaddr *`. On manipule `struct sockaddr_in` (pour IPv4) et on doit la caster lors de l'appel.",
        "chapterId": 1
    },
    {
        "id": 14,
        "question": "Pourquoi le protocole UDP est-il qualifié de 'non fiable' par rapport à TCP ?",
        "options": [
            "Parce qu'il crypte mal les données.",
            "Parce qu'il ne garantit ni l'ordre, ni la livraison, ni la non-duplication des paquets.",
            "Parce qu'il a une limite de taille de 512 octets.",
            "Parce qu'il nécessite une reconnexion fréquente."
        ],
        "answer": 1,
        "explanation": "UDP est un service 'Best Effort'. Il envoie le datagramme mais ne gère pas les accusés de réception (ACK) ni les retransmissions en cas de perte.",
        "chapterId": 1
    },
    {
        "id": 15,
        "question": "Quelle fonction permet de convertir l'endianness d'un entier court (port) de l'hôte vers le réseau ?",
        "options": [
            "`htonl()`",
            "`ntohl()`",
            "`htons()`",
            "`ntohs()`"
        ],
        "answer": 2,
        "explanation": "`h` (host) `to` `n` (network) `s` (short). Les ports sont des entiers sur 16 bits (short).",
        "chapterId": 1
    },
    {
        "id": 44,
        "chapterId": 3,
        "question": "Quel est le rôle principal de `Class.forName('driver...')` ?",
        "options": [
            "Créer la connexion à la BD",
            "Charger le driver JDBC en mémoire",
            "Exécuter des requêtes SQL",
            "Trier les résultats"
        ],
        "answer": 1,
        "explanation": "`Class.forName()` charge dynamiquement la classe du driver et déclenche son auto-enregistrement auprès du `DriverManager`."
    },
    {
        "id": 45,
        "chapterId": 3,
        "question": "Depuis JDBC 4, `Class.forName()` est-il obligatoire ?",
        "options": [
            "Oui, toujours",
            "Non, le chargement est souvent automatique",
            "Oui, si on utilise MySQL",
            "Non, JDBC ne nécessite plus de driver"
        ],
        "answer": 1,
        "explanation": "Les drivers modernes sont détectés automatiquement via le mécanisme SPI de Java."
    },
    {
        "id": 46,
        "chapterId": 3,
        "question": "Quelle classe gère la liste des drivers et fournit les connexions ?",
        "options": [
            "Connection",
            "Driver",
            "DriverManager",
            "DataSource"
        ],
        "answer": 2,
        "explanation": "`DriverManager` est la classe utilitaire qui sélectionne le bon driver en fonction de l'URL JDBC fournie."
    },
    {
        "id": 47,
        "chapterId": 3,
        "question": "`Connection` en JDBC est :",
        "options": [
            "Une classe",
            "Une interface",
            "Une méthode",
            "Une exception"
        ],
        "answer": 1,
        "explanation": "`Connection` est une interface définissant le contrat standard. L'implémentation réelle est fournie par le driver (ex: MySQL)."
    },
    {
        "id": 48,
        "chapterId": 3,
        "question": "Quel est le format typique d'une URL JDBC MySQL ?",
        "options": [
            "http://mysql/db",
            "jdbc:mysql://host:port/db",
            "sql:jdbc:mysql:db",
            "mysql:host:db"
        ],
        "answer": 1,
        "explanation": "Le format standard est `jdbc:<sous-protocole>:<détails>`."
    },
    {
        "id": 49,
        "chapterId": 3,
        "question": "Quelle méthode permet d'obtenir une connexion ?",
        "options": [
            "new Connection()",
            "DriverManager.getConnection()",
            "Statement.connect()",
            "Class.forName()"
        ],
        "answer": 1,
        "explanation": "On ne fait jamais `new Connection()`. C'est `DriverManager` qui fabrique l'objet."
    },
    {
        "id": 50,
        "chapterId": 3,
        "question": "Par défaut, le mode Auto-Commit d'une connexion est :",
        "options": [
            "Désactivé (false)",
            "Activé (true)",
            "Aléatoire",
            "Réservé à l'admin"
        ],
        "answer": 1,
        "explanation": "Par défaut, chaque requête SQL (INSERT/UPDATE...) est validée immédiatement."
    },
    {
        "id": 51,
        "chapterId": 3,
        "question": "Quand `rollback()` a-t-il un effet ?",
        "options": [
            "Toujours",
            "Jamais",
            "Seulement si Auto-Commit est désactivé (false)",
            "Seulement après un SELECT"
        ],
        "answer": 2,
        "explanation": "Si Auto-Commit est true, les transactions sont instantanées. Pour utiliser rollback, il faut gérer la transaction manuellement."
    },
    {
        "id": 52,
        "chapterId": 3,
        "question": "Quelle interface permet d'envoyer des requêtes SQL basiques ?",
        "options": [
            "ResultSet",
            "Statement",
            "Query",
            "Transaction"
        ],
        "answer": 1,
        "explanation": "`Statement` est l'interface de base pour l'exécution d'instructions SQL statiques."
    },
    {
        "id": 53,
        "chapterId": 3,
        "question": "Que retourne `stmt.executeUpdate(...)` ?",
        "options": [
            "Un ResultSet",
            "Un boolean",
            "Un int (nombre de lignes affectées)",
            "Une Connection"
        ],
        "answer": 2,
        "explanation": "Il retourne le nombre de lignes insérées, modifiées ou supprimées."
    },
    {
        "id": 54,
        "chapterId": 3,
        "question": "Que retourne `stmt.executeQuery(...)` ?",
        "options": [
            "Un ResultSet",
            "Un int",
            "Un boolean",
            "Un tableau"
        ],
        "answer": 0,
        "explanation": "Il est utilisé pour les SELECT et retourne toujours un objet `ResultSet`."
    },
    {
        "id": 55,
        "chapterId": 3,
        "question": "La méthode `execute(sql)` peut exécuter :",
        "options": [
            "Seulement des SELECT",
            "Seulement des UPDATE",
            "N'importe quel type de requête SQL",
            "Rien, elle n'existe pas"
        ],
        "answer": 2,
        "explanation": "`execute()` est générique. Elle retourne `true` si le résultat est un ResultSet, `false` sinon."
    },
    {
        "id": 56,
        "chapterId": 3,
        "question": "Pourquoi faut-il appeler `rs.next()` avant de lire des données ?",
        "options": [
            "Pour trier les données",
            "Car le curseur est initialement placé AVANT la première ligne",
            "C'est optionnel",
            "Pour se connecter à la base"
        ],
        "answer": 1,
        "explanation": "Le curseur démarre 'beforeFirst'. Le premier appel à `next()` le place sur la première ligne réelle."
    },
    {
        "id": 57,
        "chapterId": 3,
        "question": "En JDBC, les index des colonnes commencent généralement à :",
        "options": [
            "0",
            "1",
            "-1",
            "Cela dépend du driver"
        ],
        "answer": 1,
        "explanation": "Dans l'API JDBC standard, les index de colonnes sont 1-based (commencent à 1)."
    },
    {
        "id": 58,
        "chapterId": 3,
        "question": "Quel est le risque principal de `Statement` classique ?",
        "options": [
            "Il est trop rapide",
            "L'injection SQL",
            "Il ne supporte pas les SELECT",
            "Il utilise trop de mémoire"
        ],
        "answer": 1,
        "explanation": "En concaténant des chaînes pour créer la requête, on est vulnérable aux injections SQL."
    },
    {
        "id": 59,
        "chapterId": 3,
        "question": "Quelle est la version sécurisée et précompilée de `Statement` ?",
        "options": [
            "SecureStatement",
            "PreparedStatement",
            "CompiledQuery",
            "FocusStatement"
        ],
        "answer": 1,
        "explanation": "`PreparedStatement` permet de séparer le code SQL des données (paramètres), empêchant l'injection."
    },
    {
        "id": 60,
        "chapterId": 3,
        "question": "Dans `PreparedStatement`, par quoi sont remplacés les paramètres ?",
        "options": [
            "Des %",
            "Des $",
            "Des points d'interrogation (?)",
            "Des étoiles (*)"
        ],
        "answer": 2,
        "explanation": "Les placeholders sont des `?`. Exemple : `SELECT * FROM users WHERE id = ?`."
    },
    {
        "id": 61,
        "chapterId": 3,
        "question": "Que signifie DAO ?",
        "options": [
            "Data Access Object",
            "Direct Access Output",
            "Driver Auto Open",
            "Database Abstract Organization"
        ],
        "answer": 0,
        "explanation": "DAO est un motif de conception (pattern) encapsulant l'accès aux données."
    },
    {
        "id": 62,
        "chapterId": 3,
        "question": "Quelle méthode permet d'obtenir les métadonnées (noms des colonnes...) ?",
        "options": [
            "rs.getMetaData()",
            "con.getInfo()",
            "stmt.getDetails()",
            "System.getMeta()"
        ],
        "answer": 0,
        "explanation": "`ResultSetMetaData` s'obtient via `rs.getMetaData()` et décrit la structure des résultats."
    },
    {
        "id": 63,
        "chapterId": 3,
        "question": "Quelle classe Java correspond au type SQL `DATE` ?",
        "options": [
            "java.util.Date",
            "java.sql.Date",
            "java.time.Instant",
            "String"
        ],
        "answer": 1,
        "explanation": "`java.sql.Date` est le wrapper JDBC standard pour les dates (sans partie heure)."
    },
    {
        "id": 64,
        "chapterId": 3,
        "question": "Pourquoi utiliser `Integer` au lieu de `int` dans une classe entité ?",
        "options": [
            "C'est plus rapide",
            "Pour autoriser la valeur `null`",
            "C'est obligatoire en Java",
            "Pour faire des calculs"
        ],
        "answer": 1,
        "explanation": "Les types primitifs (`int`) ne peuvent pas être null. Les bases de données acceptant NULL, les wrappers (`Integer`) sont préférables."
    },
    {
        "id": 65,
        "chapterId": 3,
        "question": "Si `executeUpdate` retourne 0, cela signifie :",
        "options": [
            "Une erreur SQL",
            "Aucune ligne n'a été affectée",
            "La base est vide",
            "La requête est invalide"
        ],
        "answer": 1,
        "explanation": "Cela signifie que la requête a réussi techniquement, mais qu'elle n'a modifié aucune ligne (ex: UPDATE avec WHERE introuvable)."
    },
    {
        "id": 66,
        "chapterId": 3,
        "question": "Que doit-on faire absolument après avoir utilisé une Connection ?",
        "options": [
            "La laisser ouverte pour gagner du temps",
            "La fermer (`close()`)",
            "La supprimer",
            "Redémarrer le serveur"
        ],
        "answer": 1,
        "explanation": "Les connexions sont des ressources limitées et coûteuses. Il faut les libérer pour éviter les fuites."
    },
    {
        "id": 67,
        "chapterId": 3,
        "question": "Dans le pattern DAO, que contient la classe DAO ?",
        "options": [
            "L'interface graphique",
            "Les requêtes SQL et la gestion de connexion",
            "Les règles CSS",
            "Le code HTML"
        ],
        "answer": 1,
        "explanation": "Le DAO isole la couche persistance. L'UI ne doit pas contenir de SQL."
    },
    {
        "id": 68,
        "chapterId": 3,
        "question": "Quelle méthode permet de passer un entier à un PreparedStatement ?",
        "options": [
            "setId()",
            "putInt()",
            "setInt(index, valeur)",
            "addParam()"
        ],
        "answer": 2,
        "explanation": "On utilise les setters typés comme `setInt`, `setString`, etc. en précisant l'index du `?`."
    },
    {
        "id": 69,
        "chapterId": 3,
        "question": "Comment vérifier si un ResultSet contient encore des lignes ?",
        "options": [
            "rs.hasNext()",
            "rs.next() retourne true",
            "rs.isEmpty()",
            "rs.check()"
        ],
        "answer": 1,
        "explanation": "La méthode `next()` déplace le curseur et indique (boolean) s'il y a une ligne valide à lire."
    },
    {
        "id": 70,
        "chapterId": 3,
        "question": "Dans le modèle SearchVM (ViewModel), si un champ est null :",
        "options": [
            "On plante le programme",
            "On cherche les valeurs NULL en base",
            "On ignore ce critère de recherche",
            "On cherche une chaine vide"
        ],
        "answer": 2,
        "explanation": "C'est une convention courante : un champ null dans un filtre de recherche signifie 'peu importe cette valeur'."
    },
    {
        "id": 71,
        "chapterId": 3,
        "question": "`ResultSet` permet-il de revenir en arrière par défaut ?",
        "options": [
            "Oui, avec previous()",
            "Non, c'est un curseur forward-only par défaut",
            "Oui, toujours",
            "Oui, avec back()"
        ],
        "answer": 1,
        "explanation": "Par défaut, le ResultSet est TYPE_FORWARD_ONLY."
    },
    {
        "id": 72,
        "chapterId": 3,
        "question": "Quel objet contient les données d'une ligne de la table 'Car' ?",
        "options": [
            "L'objet Car (Entité)",
            "L'objet Connection",
            "L'objet Driver",
            "L'objet String"
        ],
        "answer": 0,
        "explanation": "L'entité (Entity) est une classe Java simple (POJO) qui mappe la structure de la table."
    },
    {
        "id": 73,
        "chapterId": 3,
        "question": "Quelle exception principale les méthodes JDBC lèvent-elles ?",
        "options": [
            "IOException",
            "SQLException",
            "DatabaseException",
            "NullPointerException"
        ],
        "answer": 1,
        "explanation": "La quasi-totalité des opérations JDBC déclarent lancer `SQLException` (checked exception)."
    },
    {
        "id": 74,
        "chapterId": 3,
        "question": "Peut-on avoir plusieurs `Statement` ouverts sur une même `Connection` ?",
        "options": [
            "Non, un seul à la fois",
            "Oui, c'est possible",
            "Oui, mais seulement en lecture",
            "Non, risque de crash"
        ],
        "answer": 1,
        "explanation": "Une connexion peut fabriquer plusieurs Statements distincts."
    },
    {
        "id": 75,
        "chapterId": 3,
        "question": "Quelle méthode permet de convertir une date SQL en LocalDate ?",
        "options": [
            "toLocalDate()",
            "getDate()",
            "parse()",
            "convert()"
        ],
        "answer": 0,
        "explanation": "Depuis Java 8, `java.sql.Date` possède la méthode de commodité `toLocalDate()`."
    },
    {
        "id": 76,
        "chapterId": 3,
        "question": "Dans le code `Class.forName('xyz')`, quel est le but du bloc `static` du driver ?",
        "options": [
            "Afficher un message",
            "S'enregistrer auprès du DriverManager",
            "Ouvrir la connexion",
            "Créer la table"
        ],
        "answer": 1,
        "explanation": "Le bloc statique du Driver contient l'appel à `DriverManager.registerDriver(new Driver())`."
    },
    {
        "id": 77,
        "chapterId": 3,
        "question": "Si j'utilise `statement.executeQuery` pour un INSERT, que se passe-t-il ?",
        "options": [
            "Cela fonctionne normalement",
            "Une SQLException est levée",
            "Rien ne se passe",
            "La base est supprimée"
        ],
        "answer": 1,
        "explanation": "L'API JDBC lève souvent une exception si on utilise la mauvaise méthode (bien que certains drivers soient permissifs, la spec dit que executeQuery doit retourner un ResultSet)."
    },
    {
        "id": 78,
        "chapterId": 3,
        "question": "SOLID : Quel principe le DAO respecte-t-il particulièrement ?",
        "options": [
            "Single Responsibility Principle (SRP)",
            "Liskov Substitution",
            "Interface Segregation",
            "None"
        ],
        "answer": 0,
        "explanation": "Le DAO isole la responsabilité de l'accès aux données, laissant la logique métier aux autres classes."
    },
    {
        "id": 79,
        "chapterId": 3,
        "question": "Mapping : Une table 'cars' et une table 'engines' liée. L'entité `Car` aura :",
        "options": [
            "Un champ `int engine_id`",
            "Un champ `Engine engine` (objet)",
            "Rien",
            "Une méthode SQL"
        ],
        "answer": 1,
        "explanation": "En POO, on préfère mapper les relations par des références d'objets (composition) plutôt que par des ID étrangers bruts."
    },
    {
        "id": 80,
        "chapterId": 3,
        "question": "Quel est l'avantage de `PreparedStatement` pour la maintenance ?",
        "options": [
            "Le code est plus court",
            "Il sépare la structure de la requête des données variables, améliorant la lisibilité",
            "Il supprime le besoin de connexion",
            "Il génère du HTML"
        ],
        "answer": 1,
        "explanation": "C'est plus propre que la concaténation de chaînes de caractères."
    },
    {
        "id": 81,
        "chapterId": 3,
        "question": "Comment savoir combien de colonnes contient un ResultSet ?",
        "options": [
            "rs.size()",
            "rs.getMetaData().getColumnCount()",
            "rs.length",
            "rs.count()"
        ],
        "answer": 1,
        "explanation": "Il faut passer par les métadonnées."
    },
    {
        "id": 82,
        "chapterId": 3,
        "question": "Que fait `Statement.execute()` si le résultat est un update count ?",
        "options": [
            "Elle retourne true",
            "Elle retourne false",
            "Elle retourne l'entier",
            "Elle plante"
        ],
        "answer": 1,
        "explanation": "Elle retourne `false` si le résultat n'est PAS un ResultSet."
    },
    {
        "id": 83,
        "chapterId": 3,
        "question": "Quelle est la bonne pratique pour gérer les exceptions JDBC ?",
        "options": [
            "Les ignorer (catch vide)",
            "Utiliser try-with-resources pour fermer automatiquement",
            "Ne pas utiliser de try-catch",
            "Relancer en RuntimeException sans logger"
        ],
        "answer": 1,
        "explanation": "`try(Connection c = ...) { ... }` garantit la fermeture propre des ressources même en cas d'erreur."
    },
    {
        "id": 84,
        "chapterId": 2,
        "question": "Qu'est-ce qu'un thread en Java ?",
        "options": [
            "Un processus lourd indépendant",
            "Une unité d'exécution légère au sein d'un processus",
            "Une méthode statique",
            "Un type de variable"
        ],
        "answer": 1,
        "explanation": "Un thread est une unité d'exécution légère qui partage l'espace mémoire du processus parent."
    },
    {
        "id": 85,
        "chapterId": 2,
        "question": "Que partagent les threads d'un même processus ?",
        "options": [
            "La pile d'appels (Stack)",
            "Le tas (Heap) et les variables statiques",
            "Le compteur ordinal (PC)",
            "Rien du tout"
        ],
        "answer": 1,
        "explanation": "Les threads partagent le tas (Heap) où résident les objets. En revanche, chaque thread a sa propre pile (Stack)."
    },
    {
        "id": 86,
        "chapterId": 2,
        "question": "Comment démarrer réellement un thread `t` ?",
        "options": [
            "t.run()",
            "t.start()",
            "t.execute()",
            "t.init()"
        ],
        "answer": 1,
        "explanation": "`start()` crée le nouveau contexte d'exécution système, puis appelle `run()`. Appeler `run()` directement ne crée pas de thread."
    },
    {
        "id": 87,
        "chapterId": 2,
        "question": "Quelle interface doit-on implémenter pour définir une tâche exécutable ?",
        "options": [
            "Executable",
            "Task",
            "Runnable",
            "Callable"
        ],
        "answer": 2,
        "explanation": "L'interface `Runnable` définit la méthode `run()` contenant le code à exécuter."
    },
    {
        "id": 88,
        "chapterId": 2,
        "question": "Que fait `Thread.sleep(1000)` ?",
        "options": [
            "Arrête le thread définitivement",
            "Libère le verrou et attend 1s",
            "Met le thread en pause pendant 1s sans libérer les verrous",
            "Tue le processus"
        ],
        "answer": 2,
        "explanation": "`sleep` met le thread en pause (état TIMED_WAITING) mais NE libère PAS les verrous (moniteurs) détenus."
    },
    {
        "id": 89,
        "chapterId": 2,
        "question": "Quelle méthode permet d'attendre la fin d'un autre thread ?",
        "options": [
            "wait()",
            "stop()",
            "join()",
            "yield()"
        ],
        "answer": 2,
        "explanation": "`join()` bloque le thread appelant jusqu'à ce que le thread cible se termine."
    },
    {
        "id": 90,
        "chapterId": 2,
        "question": "Pourquoi la méthode `stop()` est-elle dépréciée ?",
        "options": [
            "Elle est trop lente",
            "Elle risque de provoquer des interblocages et de laisser les objets dans un état incohérent",
            "Elle ne marche pas sous Linux",
            "Elle ferme l'application"
        ],
        "answer": 1,
        "explanation": "`stop()` tue le thread brutalement, potentiellement au milieu d'une opération critique, corrompant les données."
    },
    {
        "id": 91,
        "chapterId": 2,
        "question": "Comment demander proprement l'arrêt d'un thread ?",
        "options": [
            "t.kill()",
            "t.interrupt()",
            "t.stop()",
            "System.exit(0)"
        ],
        "answer": 1,
        "explanation": "`interrupt()` positionne un drapeau d'interruption. C'est au thread de vérifier ce drapeau et de s'arrêter proprement."
    },
    {
        "id": 92,
        "chapterId": 2,
        "question": "Quel mot-clé assure l'exclusion mutuelle ?",
        "options": [
            "volatile",
            "synchronized",
            "transient",
            "static"
        ],
        "answer": 1,
        "explanation": "`synchronized` permet d'acquérir le verrou (moniteur) d'un objet, empêchant d'autres threads d'entrer dans un bloc synchronisé sur le même objet."
    },
    {
        "id": 93,
        "chapterId": 2,
        "question": "Si j'ai deux méthodes `synchronized` sur le même objet, deux threads peuvent-ils les exécuter en simultané ?",
        "options": [
            "Oui, car ce sont deux méthodes différentes",
            "Non, car le verrou est sur l'objet (this)",
            "Oui, si elles sont void",
            "Cela dépend de l'OS"
        ],
        "answer": 1,
        "explanation": "Le verrou est lié à l'instance de l'objet (`this`). Un seul thread à la fois peut détenir le verrou de cet objet."
    },
    {
        "id": 94,
        "chapterId": 2,
        "question": "Que se passe-t-il si on appelle `wait()` hors d'un bloc `synchronized` ?",
        "options": [
            "Rien",
            "Le thread attend indéfiniment",
            "Une `IllegalMonitorStateException` est levée",
            "Une `InterruptedException` est levée"
        ],
        "answer": 2,
        "explanation": "Pour appeler `wait()`, le thread doit posséder le moniteur de l'objet, donc être dans un bloc `synchronized`."
    },
    {
        "id": 95,
        "chapterId": 2,
        "question": "Quelle est la différence fondamentale entre `wait()` et `sleep()` ?",
        "options": [
            "Aucune",
            "`wait()` libère le verrou, `sleep()` le garde",
            "`sleep()` libère le verrou, `wait()` le garde",
            "`wait()` est plus précis"
        ],
        "answer": 1,
        "explanation": "`wait()` relâche le moniteur pour permettre à d'autres threads (ex: notify) de prendre la main, contrairement à `sleep()`."
    },
    {
        "id": 96,
        "chapterId": 2,
        "question": "À quoi sert `notifyAll()` ?",
        "options": [
            "À afficher une notification à l'utilisateur",
            "À réveiller tous les threads en attente sur cet objet",
            "À réveiller un seul thread aléatoire",
            "À terminer le programme"
        ],
        "answer": 1,
        "explanation": "`notifyAll()` réveille tous les threads en wait() sur le moniteur. C'est souvent plus sûr que `notify()` pour éviter des blocages."
    },
    {
        "id": 97,
        "chapterId": 2,
        "question": "Qu'est-ce qu'un thread Daemon ?",
        "options": [
            "Un thread malveillant",
            "Un thread de service qui ne bloque pas la fin du programme",
            "Un thread prioritaire",
            "Un thread administrateur"
        ],
        "answer": 1,
        "explanation": "La JVM s'arrête dès qu'il ne reste plus que des threads Daemons. Ils servent aux tâches de fond (ex: Garbage Collector)."
    },
    {
        "id": 98,
        "chapterId": 2,
        "question": "Quand peut-on appeler `setDaemon(true)` ?",
        "options": [
            "N'importe quand",
            "Uniquement après start()",
            "Uniquement avant start()",
            "Dans la méthode run()"
        ],
        "answer": 2,
        "explanation": "Le statut Daemon doit être défini avant le démarrage du thread. Sinon, une exception est levée."
    },
    {
        "id": 99,
        "chapterId": 2,
        "question": "Quelle méthode permet de passer la main volontairement ?",
        "options": [
            "Thread.pass()",
            "Thread.yield()",
            "Thread.stop()",
            "Thread.give()"
        ],
        "answer": 1,
        "explanation": "`yield()` suggère au planificateur de passer la main à un autre thread de même priorité."
    },
    {
        "id": 100,
        "chapterId": 2,
        "question": "La priorité d'un thread garantit-elle l'ordre d'exécution ?",
        "options": [
            "Oui, absolument",
            "Non, c'est juste une indication (optimisation) pour le scheduler",
            "Oui, sauf sous Windows",
            "Oui si on est root"
        ],
        "answer": 1,
        "explanation": "Les spécifications Java ne garantissent pas que la priorité sera strictement respectée par l'OS."
    },
    {
        "id": 101,
        "chapterId": 2,
        "question": "Quel stream utiliser pour commmuniquer entre threads ?",
        "options": [
            "FileStream",
            "PipedInputStream / PipedOutputStream",
            "ThreadStream",
            "SocketStream"
        ],
        "answer": 1,
        "explanation": "Les Pipes (tubes) permettent une communication unidirectionnelle entre deux threads."
    },
    {
        "id": 102,
        "chapterId": 2,
        "question": "Dans quel thread doit-on modifier l'interface graphique Swing ?",
        "options": [
            "Le thread main",
            "N'importe quel thread",
            "Le thread EDT (Event Dispatch Thread)",
            "Un thread Daemon"
        ],
        "answer": 2,
        "explanation": "Swing n'est pas Thread-Safe. Toutes les mutations d'UI doivent se faire dans l'EDT via `invokeLater`."
    },
    {
        "id": 103,
        "chapterId": 2,
        "question": "Quelle méthode permet d'exécuter du code dans l'EDT ?",
        "options": [
            "SwingUtilities.run()",
            "EventQueue.invokeLater(Runnable)",
            "Thread.start()",
            "System.run()"
        ],
        "answer": 1,
        "explanation": "`EventQueue.invokeLater` place la tâche dans la file d'attente de l'Event Dispatch Thread."
    },
    {
        "id": 104,
        "chapterId": 2,
        "question": "Quel Timer utiliser pour faire une animation Swing ?",
        "options": [
            "java.util.Timer",
            "javax.swing.Timer",
            "Thread.sleep",
            "Cron"
        ],
        "answer": 1,
        "explanation": "`javax.swing.Timer` exécute ses actions directement dans l'EDT, ce qui permet de modifier l'UI en toute sécurité."
    },
    {
        "id": 105,
        "chapterId": 2,
        "question": "Une méthode statique synchronisée verrouille :",
        "options": [
            "L'instance (this)",
            "La classe (Class object)",
            "Toutes les instances",
            "Rien"
        ],
        "answer": 1,
        "explanation": "`static synchronized` prend le verrou sur l'objet `Class` correspondant, pas sur une instance `this`."
    },
    {
        "id": 106,
        "chapterId": 2,
        "question": "L'interface `Runnable` contient combien de méthodes ?",
        "options": [
            "2 (start et run)",
            "1 (run)",
            "0 (interface marqueur)",
            "Plusieurs"
        ],
        "answer": 1,
        "explanation": "Elle est une interface fonctionnelle avec une seule méthode abstraite : `public void run()`."
    },
    {
        "id": 107,
        "chapterId": 2,
        "question": "Peut-on redémarrer un thread (appeler start 2 fois) ?",
        "options": [
            "Oui, sans problème",
            "Non, cela lève une IllegalThreadStateException",
            "Oui, après un stop()",
            "Seulement s'il est Daemon"
        ],
        "answer": 1,
        "explanation": "Un thread une fois terminé est mort. On ne peut pas le relancer."
    },
    {
        "id": 108,
        "chapterId": 2,
        "question": "A quoi sert `Thread.currentThread()` ?",
        "options": [
            "À créer un thread",
            "À obtenir une référence sur le thread en cours d'exécution",
            "À arrêter le thread courant",
            "À changer de thread"
        ],
        "answer": 1,
        "explanation": "C'est une méthode statique permettant au code de savoir quel thread l'exécute actuellement."
    },
    {
        "id": 109,
        "chapterId": 2,
        "question": "Quelle méthode permet de vérifier si un thread tourne encore ?",
        "options": [
            "check()",
            "isAlive()",
            "isRunning()",
            "status()"
        ],
        "answer": 1,
        "explanation": "`isAlive()` retourne true si le thread a été démarré et n'est pas encore mort."
    },
    {
        "id": 110,
        "chapterId": 2,
        "question": "Le mot-clé `synchronized` est-il hérité par les sous-classes ?",
        "options": [
            "Oui",
            "Non",
            "Uniquement si public",
            "Uniquement si abstract"
        ],
        "answer": 1,
        "explanation": "La synchronisation est une propriété de l'implémentation de la méthode, pas de sa signature. Elle n'est pas héritée."
    },
    {
        "id": 111,
        "chapterId": 2,
        "question": "Qu'est-ce qu'un moniteur réentrant ?",
        "options": [
            "Un thread qui peut entrer plusieurs fois dans un bloc qu'il verrouille déjà",
            "Un thread qui peut entrer dans n'importe quel bloc",
            "Un verrou cassé",
            "Un mécanisme interdit"
        ],
        "answer": 0,
        "explanation": "En Java, si un thread possède un verrou, il peut ré-entrer dans d'autres blocs synchronisés sur ce MÊME verrou sans se bloquer."
    },
    {
        "id": 112,
        "chapterId": 2,
        "question": "Les variables locales d'une méthode sont-elles partagées entre threads ?",
        "options": [
            "Oui",
            "Non, elles sont sur la pile (thread-local)",
            "Oui si elles sont finales",
            "Oui si elles sont objets"
        ],
        "answer": 1,
        "explanation": "Chaque thread a sa propre pile. Les variables locales vivent dans la pile, donc elles sont isolées."
    },
    {
        "id": 113,
        "chapterId": 2,
        "question": "En cas d'exception non gérée dans `run()`, que se passe-t-il ?",
        "options": [
            "Le programme entier plante",
            "Le thread se termine, le reste du programme continue",
            "L'exception est ignorée",
            "Le thread redémarre"
        ],
        "answer": 1,
        "explanation": "La mort d'un thread sur exception ne tue pas tout le processus (sauf si c'était le dernier User Thread ou le main)."
    },
    {
        "id": 114,
        "chapterId": 2,
        "question": "Comment grouper plusieurs threads pour les gérer ensemble ?",
        "options": [
            "ThreadList",
            "ThreadGroup",
            "ThreadCollection",
            "ThreadPool"
        ],
        "answer": 1,
        "explanation": "`ThreadGroup` permet d'organiser les threads en arborescence et d'agir sur eux collectivement (ex: interrupt)."
    },
    {
        "id": 115,
        "chapterId": 2,
        "question": "La méthode `activeCount()` d'un ThreadGroup est :",
        "options": [
            "Exacte",
            "Une estimation",
            "Toujours nulle",
            "Obsolète"
        ],
        "answer": 1,
        "explanation": "Comme les threads naissent et meurent dynamiquement, ce nombre n'est qu'une estimation instantanée."
    },
    {
        "id": 116,
        "chapterId": 2,
        "question": "Pourquoi préférer `Runnable` à l'héritage de `Thread` ?",
        "options": [
            "C'est plus performant",
            "Pour contourner l'héritage unique de Java (une classe peut étendre autre chose et implémenter Runnable)",
            "Thread est déprécié",
            "C'est obligatoire"
        ],
        "answer": 1,
        "explanation": "Cela permet une meilleure séparation des préoccupations (tâche vs exécution) et de garder la possibilité d'hériter d'une autre classe métier."
    },
    {
        "id": 117,
        "chapterId": 2,
        "question": "Quel état n'existe PAS pour un thread Java ?",
        "options": [
            "NEW",
            "RUNNABLE",
            "BLOCKED",
            "PAUSED"
        ],
        "answer": 3,
        "explanation": "L'état 'PAUSED' n'existe pas dans l'enum `Thread.State`. On a WAITING ou TIMED_WAITING."
    },
    {
        "id": 118,
        "chapterId": 2,
        "question": "Si j'appelle `wait()` avec un temps (timeout), le thread :",
        "options": [
            "Se réveille au bout du temps OU si on le notifie",
            "Doit forcément être notifié",
            "Ne peut pas être notifié",
            "Se termine"
        ],
        "answer": 0,
        "explanation": "`wait(timeout)` attend au maximum le temps donné, ou un `notify`/`notifyAll` précoce."
    },
    {
        "id": 119,
        "chapterId": 2,
        "question": "Le scheduler (ordonnanceur) Java est-il préemptif ?",
        "options": [
            "Oui, généralement",
            "Non, coopératif uniquement",
            "Java n'a pas de scheduler",
            "Cela dépend de la JVM et de l'OS"
        ],
        "answer": 3,
        "explanation": "Bien que souvent préemptif sur les OS modernes, la spécification Java ne garantit pas le mode d'ordonnancement (Time Slicing)."
    },
    {
        "id": 120,
        "chapterId": 2,
        "question": "Comment envoyer des types primitifs (int, double) via un Pipe ?",
        "options": [
            "Directement dans PipedInputStream",
            "Via DataInputStream / DataOutputStream qui enveloppent le pipe",
            "Impossible",
            "Via ObjectOutputStream"
        ],
        "answer": 1,
        "explanation": "Les Pipes gèrent des octets. Utiliser `DataOuputStream` permet d'écrire des types structurés Java."
    },
    {
        "id": 121,
        "chapterId": 2,
        "question": "Que se passe-t-il si un Pipe n'est connecté à rien ?",
        "options": [
            "Rien",
            "Blocage ou Exception si on tente d'écrire/lire",
            "Il se connecte tout seul",
            "Il écrit sur la console"
        ],
        "answer": 1,
        "explanation": "Un pipe doit être appairé (connect). Sinon, une exception peut survenir."
    },
    {
        "id": 122,
        "chapterId": 2,
        "question": "Quelle méthode permet d'interrompre tout un groupe de threads ?",
        "options": [
            "group.killAll()",
            "group.interrupt()",
            "group.stop()",
            "group.halt()"
        ],
        "answer": 1,
        "explanation": "La classe `ThreadGroup` possède une méthode `interrupt()` qui appelle `interrupt()` sur tous ses threads membres."
    },
    {
        "id": 123,
        "chapterId": 2,
        "question": "Quelle classe permet d'exécuter une tâche répétitive ?",
        "options": [
            "java.util.Repeat",
            "java.util.Timer",
            "java.lang.Looper",
            "java.io.Repeater"
        ],
        "answer": 1,
        "explanation": "`Timer` permet de planifier des `TimerTask` pour une exécution unique ou répétitive."
    },
    {
        "id": 124,
        "chapterId": 4,
        "question": "Combien de couches comporte le modèle utilisé dans ce cours (TCP/IP simplifié) ?",
        "options": [
            "7 couches (OSI)",
            "4 couches (Application, Transport, Internet, Hôte-Réseau)",
            "5 couches",
            "3 couches"
        ],
        "answer": 1,
        "explanation": "Le modèle TCP/IP simplifié présenté comporte 4 couches : Application, Transport, Internet, Hôte-Réseau."
    },
    {
        "id": 125,
        "chapterId": 4,
        "question": "Quelle est la différence fondamentale entre TCP et UDP concernant la connexion ?",
        "options": [
            "TCP est non connecté, UDP est connecté",
            "TCP est orienté connexion (Handshake), UDP est non connecté",
            "Les deux sont connectés",
            "Aucun n'est connecté"
        ],
        "answer": 1,
        "explanation": "TCP nécessite l'établissement d'une connexion (Handshake) avant d'envoyer des données, contrairement à UDP."
    },
    {
        "id": 126,
        "chapterId": 4,
        "question": "Sur combien de bits est codé un numéro de port ?",
        "options": [
            "8 bits",
            "16 bits",
            "32 bits",
            "64 bits"
        ],
        "answer": 1,
        "explanation": "Un port est un entier non signé de 16 bits, allant de 0 à 65535."
    },
    {
        "id": 127,
        "chapterId": 4,
        "question": "Comment appelle-t-on l'association unique {Adresse IP + Port} ?",
        "options": [
            "Un Packet",
            "Une Socket",
            "Un Thread",
            "Un Stream"
        ],
        "answer": 1,
        "explanation": "Une socket est définie par ce couple qui permet d'identifier un processus spécifique sur une machine spécifique."
    },
    {
        "id": 128,
        "chapterId": 4,
        "question": "Peut-on instancier `InetAddress` via `new InetAddress()` ?",
        "options": [
            "Oui, c'est la méthode standard",
            "Non, elle n'a pas de constructeur public",
            "Oui, mais c'est déprécié",
            "Seulement pour IPv6"
        ],
        "answer": 1,
        "explanation": "`InetAddress` utilise des méthodes de fabrique statiques (Factory Methods) comme `getLocalHost` ou `getByName`."
    },
    {
        "id": 129,
        "chapterId": 4,
        "question": "Quelle méthode permet d'obtenir l'adresse IP d'un nom de domaine (ex: www.google.com) ?",
        "options": [
            "InetAddress.create()",
            "InetAddress.getByName()",
            "DNS.resolve()",
            "Server.find()"
        ],
        "answer": 1,
        "explanation": "`InetAddress.getByName(\"...\")` effectue la résolution DNS pour retourner l'objet adresse correspondant."
    },
    {
        "id": 130,
        "chapterId": 4,
        "question": "Quelle exception est levée si `InetAddress.getByName` ne trouve pas l'hôte ?",
        "options": [
            "IOException",
            "SocketException",
            "UnknownHostException",
            "NullPointerException"
        ],
        "answer": 2,
        "explanation": "Si le DNS ne parvient pas à résoudre le nom, une `UnknownHostException` est levée."
    },
    {
        "id": 131,
        "chapterId": 4,
        "question": "Quel objet Java sert à ATTENDRE les connexions des clients (côté serveur) ?",
        "options": [
            "Socket",
            "ServerSocket",
            "ClientSocket",
            "ConnectionFactory"
        ],
        "answer": 1,
        "explanation": "`ServerSocket` est la classe dédiée à l'écoute d'un port et à l'acceptation des connexions entrantes."
    },
    {
        "id": 132,
        "chapterId": 4,
        "question": "Par défaut, quelle est la taille de la file d'attente (backlog) d'un `ServerSocket` ?",
        "options": [
            "10",
            "50",
            "100",
            "Illimitée"
        ],
        "answer": 1,
        "explanation": "Si on ne spécifie pas le second argument du constructeur, la file des connexions en attente est limitée à 50 par défaut."
    },
    {
        "id": 133,
        "chapterId": 4,
        "question": "La méthode `accept()` de `ServerSocket` est-elle bloquante ?",
        "options": [
            "Non, elle retourne null immédiatement si personne n'est là",
            "Oui, elle bloque jusqu'à ce qu'un client se connecte (ou timeout)",
            "Oui, mais maximum 1 seconde",
            "Non, elle lance un thread"
        ],
        "answer": 1,
        "explanation": "`accept()` met le thread en pause jusqu'à l'arrivée d'une connexion. C'est un appel bloquant."
    },
    {
        "id": 134,
        "chapterId": 4,
        "question": "Que retourne la méthode `ServerSocket.accept()` ?",
        "options": [
            "Un boolean",
            "Une adresse IP",
            "Un objet `Socket` permettant de communiquer avec le client",
            "Un entier"
        ],
        "answer": 2,
        "explanation": "Elle retourne une `Socket` de service dédiée à la communication avec le client qui vient d'arriver."
    },
    {
        "id": 135,
        "chapterId": 4,
        "question": "Quelle exception survient si `new Socket(host, port)` n'arrive pas à se connecter ?",
        "options": [
            "NoRouteToHostException",
            "ConnectException",
            "BindException",
            "InterruptException"
        ],
        "answer": 1,
        "explanation": "`ConnectException` indique que le serveur est éteint ou inaccessible sur ce port (Connection refused)."
    },
    {
        "id": 136,
        "chapterId": 4,
        "question": "Pour envoyer des objets Java sur le réseau, quelle classe utilise-t-on ?",
        "options": [
            "DataOutputStream",
            "ObjectOutputStream",
            "BufferedOutputStream",
            "PrintStream"
        ],
        "answer": 1,
        "explanation": "`ObjectOutputStream` permet de sérialiser des objets Java dans le flux."
    },
    {
        "id": 137,
        "chapterId": 4,
        "question": "Quelle interface doit implémenter une classe pour être envoyée via `ObjectOutputStream` ?",
        "options": [
            "Cloneable",
            "Runnable",
            "Serializable",
            "Remote"
        ],
        "answer": 2,
        "explanation": "L'interface marqueur `java.io.Serializable` est obligatoire pour la sérialisation."
    },
    {
        "id": 138,
        "chapterId": 4,
        "question": "Si j'utilise `BufferedWriter` sans faire `flush()`, que se passe-t-il ?",
        "options": [
            "Les données sont envoyées instantanément",
            "Les données restent dans le tampon et ne partent pas sur le réseau",
            "Une exception est levée",
            "Le socket se ferme"
        ],
        "answer": 1,
        "explanation": "Les flux bufférisés gardent les données en mémoire pour optimiser. `flush()` force l'envoi physique."
    },
    {
        "id": 139,
        "chapterId": 4,
        "question": "Lors d'une communication Java <-> C, peut-on utiliser la sérialisation Java ?",
        "options": [
            "Oui, le C comprend le Java",
            "Non, il faut échanger des octets bruts (Bytes) ou du texte standard",
            "Oui avec un plugin",
            "Oui si la classe est Serializable en C"
        ],
        "answer": 1,
        "explanation": "La sérialisation Java est un format binaire spécifique à la JVM. Le C ne sait pas le lire nativement."
    },
    {
        "id": 140,
        "chapterId": 4,
        "question": "En TCP (flux continu), comment délimiter la fin d'un message textuel ?",
        "options": [
            "C'est automatique",
            "On utilise un caractère de fin (ex: fin de ligne ou $%) ou un entête de taille",
            "On ferme la socket après chaque mot",
            "On attend 1 seconde"
        ],
        "answer": 1,
        "explanation": "Comme c'est un flux (tuyau), il n'y a pas de notion de 'paquet' visible. Il faut définir un protocole de délimitation."
    },
    {
        "id": 141,
        "chapterId": 4,
        "question": "Dans le modèle 'Serveur Multi-Threads à la demande', que fait-on à chaque connexion ?",
        "options": [
            "On traite la requête dans le thread principal",
            "On crée un nouveau Thread dédié au client",
            "On refuse le client",
            "On met le client en attente"
        ],
        "answer": 1,
        "explanation": "Chaque `accept()` est suivi d'un `new ThreadClient(socket).start()`."
    },
    {
        "id": 142,
        "chapterId": 4,
        "question": "Quel est le risque principal du modèle 'Thread à la demande' ?",
        "options": [
            "C'est lent",
            "Saturation mémoire (DoS) si trop de clients arrivent simultanément",
            "C'est trop complexe",
            "Les données se mélangent"
        ],
        "answer": 1,
        "explanation": "Créer un thread par client consomme des ressources. Une attaque massive peut faire crasher le serveur."
    },
    {
        "id": 143,
        "chapterId": 4,
        "question": "Dans le modèle 'Pool de Threads', que fait le ThreadServeur ?",
        "options": [
            "Il traite les clients",
            "Il crée des threads",
            "Il récupère la socket et la dépose dans une File d'Attente",
            "Il ne fait rien"
        ],
        "answer": 2,
        "explanation": "Le ThreadServeur ne fait que `accept()` et `queue.add(socket)`. Ce sont les threads du pool qui consomment la file."
    },
    {
        "id": 144,
        "chapterId": 4,
        "question": "Que se passe-t-il si un Thread du pool veut prendre une connexion mais que la file est vide ?",
        "options": [
            "Il s'arrête",
            "Il se met en attente (wait) jusqu'à ce qu'une connexion arrive",
            "Il lance une exception",
            "Il crée une fausse connexion"
        ],
        "answer": 1,
        "explanation": "C'est le principe Producteur/Consommateur bloquant. `getConnexion()` utilise `wait()`."
    },
    {
        "id": 145,
        "chapterId": 4,
        "question": "Pourquoi utiliser `notify()` (et pas `notifyAll`) dans le pool de threads ?",
        "options": [
            "C'est obligatoire",
            "Car une seule socket ne peut être traitée que par UN seul thread",
            "Car `notifyAll` est déprécié",
            "Pour économiser de la batterie"
        ],
        "answer": 1,
        "explanation": "Lorsqu'on ajoute UNE socket, inutile de réveiller tous les threads, un seul pourra la prendre."
    },
    {
        "id": 146,
        "chapterId": 4,
        "question": "Que se passe-t-il si on fait `socket.accept()` dans le thread de l'interface graphique (EDT) ?",
        "options": [
            "Tout fonctionne bien",
            "L'interface graphique gèle (freeze) jusqu'à la connexion d'un client",
            "Une exception swing est lancée",
            "La fenêtre change de couleur"
        ],
        "answer": 1,
        "explanation": "L'appel étant bloquant, l'EDT ne peut plus redessiner la fenêtre ni gérer les clics."
    },
    {
        "id": 147,
        "chapterId": 4,
        "question": "Comment le Serveur doit-il communiquer avec l'interface graphique Swing ?",
        "options": [
            "En modifiant directement les composants JTable/JLabel",
            "Via une interface Logger (ou callback) utilisant `invokeLater`",
            "Par télépathie",
            "En écrivant dans un fichier texte"
        ],
        "answer": 1,
        "explanation": "Le serveur ne doit pas toucher au GUI directement. Il passe par une abstraction (Logger) qui redirige vers l'EDT."
    },
    {
        "id": 148,
        "chapterId": 4,
        "question": "À quoi sert la classe `DataInputStream` ?",
        "options": [
            "À lire des objets",
            "À lire des types primitifs (int, double, boolean) de manière portable",
            "À lire des fichiers MP3",
            "À lire des images"
        ],
        "answer": 1,
        "explanation": "Elle permet de lire des données binaires (comme `readInt`) encodées de manière indépendante de la plateforme."
    },
    {
        "id": 149,
        "chapterId": 4,
        "question": "Si j'écris `writeInt(42)`, que dois-je appeler en face ?",
        "options": [
            "readDouble()",
            "readByte()",
            "readInt()",
            "readString()"
        ],
        "answer": 2,
        "explanation": "L'ordre et le type de lecture doivent correspondre exactement à l'écriture."
    },
    {
        "id": 150,
        "chapterId": 4,
        "question": "Quelle méthode active le timeout sur une Socket ?",
        "options": [
            "setTimeout()",
            "setSoTimeout()",
            "waitTimeout()",
            "limitTime()"
        ],
        "answer": 1,
        "explanation": "`setSoTimeout(int ms)` définit le temps max d'attente pour `read()` ou `accept()`."
    },
    {
        "id": 151,
        "chapterId": 4,
        "question": "Quel port est généralement associé au protocole HTTP ?",
        "options": [
            "21",
            "25",
            "80",
            "443"
        ],
        "answer": 2,
        "explanation": "Le port standard pour le web non sécurisé est 80. (443 pour HTTPS)."
    },
    {
        "id": 152,
        "chapterId": 4,
        "question": "Un thread démon (Daemon) empêche-t-il la JVM de s'arrêter ?",
        "options": [
            "Oui",
            "Non, la JVM s'arrête s'il ne reste que des Daemons",
            "Cela dépend de sa priorité",
            "Oui s'il est en boucle infinie"
        ],
        "answer": 1,
        "explanation": "Les threads démons sont des threads de service qui sont tués automatiquement à la fin des threads utilisateurs."
    },
    {
        "id": 153,
        "chapterId": 4,
        "question": "Dans l'architecture proposée, à quoi sert l'interface `Protocole` ?",
        "options": [
            "À définir TCP ou UDP",
            "À isoler la logique métier (traiteRequete) du code réseau",
            "À crypter les données",
            "À connecter la base de données"
        ],
        "answer": 1,
        "explanation": "Elle permet de changer le comportement du serveur (ex: Chat, Calcul, Login) sans toucher au code du serveur lui-même."
    },
    {
        "id": 154,
        "chapterId": 4,
        "question": "Qu'est-ce que `InetAddress.getLocalHost()` retourne ?",
        "options": [
            "L'adresse 127.0.0.1 (localhost)",
            "L'adresse IP réelle de la machine sur le réseau (avec son nom d'hôte)",
            "L'adresse du serveur Google",
            "Null"
        ],
        "answer": 1,
        "explanation": "Elle interroge le système pour obtenir l'IP de la carte réseau principale."
    },
    {
        "id": 155,
        "chapterId": 4,
        "question": "Pourquoi mettre `ObjectOutputStream` avant `ObjectInputStream` à la création ?",
        "options": [
            "Pour éviter un blocage (deadlock) lors de l'envoi de l'en-tête de sérialisation",
            "C'est une convention esthétique",
            "Cela n'a aucune importance",
            "Pour aller plus vite"
        ],
        "answer": 0,
        "explanation": "`new ObjectOutputStream` écrit un header immédiatement. Si les deux côtés font `new ObjectInputStream` en premier, ils attendent tous les deux un header qui n'arrive jamais."
    },
    {
        "id": 156,
        "chapterId": 4,
        "question": "Quelle classe permet de lire des lignes de texte entières ?",
        "options": [
            "FileReader",
            "BufferedReader",
            "LineReader",
            "TextInputStream"
        ],
        "answer": 1,
        "explanation": "`BufferedReader` possède la méthode `readLine()` très pratique pour le texte."
    },
    {
        "id": 157,
        "chapterId": 4,
        "question": "Dans le modèle OSI, quelle couche manque dans le modèle 4 couches ?",
        "options": [
            "Application",
            "Transport",
            "Présentation (et Session)",
            "Réseau"
        ],
        "answer": 2,
        "explanation": "Le modèle TCP/IP regroupe Session, Présentation et Application en une seule couche 'Application'."
    },
    {
        "id": 158,
        "chapterId": 4,
        "question": "Quand on sérialise un objet, ses champs `transient` sont-ils envoyés ?",
        "options": [
            "Oui",
            "Non, ils sont ignorés",
            "Seulement s'ils sont publics",
            "Oui mais chiffrés"
        ],
        "answer": 1,
        "explanation": "Le mot-clé `transient` sert justement à exclure un champ de la sérialisation."
    },
    {
        "id": 159,
        "chapterId": 4,
        "question": "La méthode `getAddress()` de `InetAddress` retourne des octets. Quelle est leur particularité en Java ?",
        "options": [
            "Ils sont non signés (0..255)",
            "Ils sont signés (-128..127)",
            "Ce sont des int",
            "Ce sont des char"
        ],
        "answer": 1,
        "explanation": "En Java, le type `byte` est signé. Il faut faire attention lors de l'affichage (souvent `b & 0xFF` pour retrouver 0-255)."
    },
    {
        "id": 160,
        "chapterId": 4,
        "question": "Quel composant Swing est utilisé dans l'exemple LILOC pour afficher les logs ?",
        "options": [
            "JTable",
            "JLabel",
            "JButton",
            "JFrame"
        ],
        "answer": 0,
        "explanation": "L'exemple du cours utilise une `JTable` (modèle `LogTableModel`) pour lister les traces du serveur."
    },
    {
        "id": 161,
        "chapterId": 4,
        "question": "Comment le serveur sait-il qu'un client C a fini son message ?",
        "options": [
            "Grâce à la fin de l'objet Java",
            "Grâce à un caractère délimiteur (ex: $) ou une taille en entête",
            "Il devine",
            "Le client ferme la connexion"
        ],
        "answer": 1,
        "explanation": "En communication bas niveau, c'est au protocole applicatif de définir la structure (Header+Body ou Delimiter)."
    },
    {
        "id": 162,
        "chapterId": 4,
        "question": "Dans un `catch(IOException e)`, que doit-on faire de la socket ?",
        "options": [
            "La laisser ouverte",
            "La fermer proprement (socket.close())",
            "La relancer",
            "Rien"
        ],
        "answer": 1,
        "explanation": "En cas d'erreur de communication, il faut libérer les ressources en fermant la socket."
    },
    {
        "id": 163,
        "chapterId": 4,
        "question": "Une `Socket` est :",
        "options": [
            "Un fichier physique",
            "Une abstraction logicielle représentant une connexion réseau",
            "Une carte mère",
            "Un pilote"
        ],
        "answer": 1,
        "explanation": "C'est l'interface de programmation (API) vers la couche Transport TCP."
    }
]