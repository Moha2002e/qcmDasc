[
    {
        "id": 1,
        "question": "Juste après l'appel à `socket(AF_INET, SOCK_STREAM, 0)`, quel est l'état exact de la socket ?",
        "options": [
            "Elle est connectée à l'hôte local sur un port aléatoire.",
            "Elle est créée, mais anonyme (sans adresse IP ni port) et non connectée.",
            "Elle est automatiquement liée au port 0 en attente de `connect`.",
            "Elle est en mode écoute (listen) en attente de `accept`."
        ],
        "answer": 1,
        "explanation": "La socket est créée (descripteur alloué) mais n'a aucune identité réseau (anonyme) tant que `bind` ou `connect` n'est pas appelé. Elle n'est ni liée ni connectée.",
        "chapterId": 1
    },
    {
        "id": 2,
        "question": "Concernant la primitive `bind()` dans une architecture TCP Client/Serveur, quelle affirmation est strictement vraie ?",
        "options": [
            "Elle est optionnelle pour le serveur mais obligatoire pour le client afin de fixer son port source.",
            "Elle est obligatoire pour le serveur pour définir son écoute, mais le client comportement est indéfini s'il l'utilise.",
            "Elle est obligatoire pour le serveur, tandis que le client peut l'utiliser mais s'en remet généralement au noyau (bind implicite).",
            "Elle est obligatoire pour les deux parties afin de garantir l'unicité du couple {IP, Port}."
        ],
        "answer": 2,
        "explanation": "Le serveur *doit* être joignable sur un port connu. Le client *peut* choisir son port, mais laisse généralement l'OS choisir un port éphémère via un bind implicite.",
        "chapterId": 1
    },
    {
        "id": 3,
        "question": "Dans `listen(sockfd, backlog)`, que représente exactement l'entier `backlog` ?",
        "options": [
            "Le nombre maximum de connexions actives simultanées que le serveur peut gérer.",
            "Le nombre maximum de demandes de connexions en attente (handshake terminé, en attente d'accept).",
            "La taille en octets du buffer de réception pour cette socket.",
            "Le délai d'attente (timeout) en secondes avant de rejeter un client."
        ],
        "answer": 1,
        "explanation": "Le backlog définit la taille de la file d'attente des connexions *pending* (3-way handshake fini) que l'application n'a pas encore acceptées via `accept()`.",
        "chapterId": 1
    },
    {
        "id": 4,
        "question": "Quelle est la relation précise entre `write(fd, buf, len)` et `send(fd, buf, len, flags)` sous UNIX ?",
        "options": [
            "Elles sont strictement identiques, `write` est juste une macro pour `send` avec `flags=0`.",
            "Si `flags=0`, elles effectuent la même opération, mais `send` ne fonctionne que sur des sockets.",
            " `send` est plus rapide que `write` car elle contourne la couche VFS (Virtual File System).",
            " `write` ajoute automatiquement un terminateur nul au buffer, contrairement à `send`."
        ],
        "answer": 1,
        "explanation": "Sur une socket, `send` avec `flags=0` est équivalent à `write`. Cependant `send` est spécifique aux sockets, alors que `write` est générique pour tout fichier.",
        "chapterId": 1
    },
    {
        "id": 5,
        "question": "Que retourne l'appel système `accept(listening_socket, ...)` en cas de succès ?",
        "options": [
            "L'entier `0` pour confirmer que le handshake a réussi.",
            "Le même descripteur `listening_socket`, mais passé en mode connecté.",
            "Un nouveau descripteur de fichier spécifiquement dédié à cette connexion client.",
            "L'adresse IP du client sous forme d'entier."
        ],
        "answer": 2,
        "explanation": "`accept` crée une *nouvelle* socket pour la connexion établie. La socket d'origine reste en mode écoute (LISTEN) pour d'autres clients.",
        "chapterId": 1
    },
    {
        "id": 6,
        "question": "Vous lancez votre serveur et il échoue immédiatement avec l'erreur `EADDRINUSE`. Quelle est la cause la plus probable ?",
        "options": [
            "Le client distant a rejeté la connexion.",
            "Le serveur tente de se lier (bind) à un port déjà occupé par un autre processus ou une socket en attente.",
            "Le câble réseau est débranché.",
            "Les permissions root sont requises pour ouvrir une socket (EACCES)."
        ],
        "answer": 1,
        "explanation": "`EADDRINUSE` signifie que l'adresse (IP + Port) demandée est déjà utilisée localement par une autre socket.",
        "chapterId": 1
    },
    {
        "id": 7,
        "question": "Quel appel système déclenche l'envoi du paquet TCP SYN par le client ?",
        "options": [
            "Au moment de la création de la socket avec `socket()`.",
            "Au moment de l'appel à `bind()`.",
            "Au moment de l'appel à `connect()`.",
            "Lors du premier `send()` de données."
        ],
        "answer": 2,
        "explanation": "C'est `connect()` qui initie le '3-way handshake', commençant par l'envoi du SYN.",
        "chapterId": 1
    },
    {
        "id": 8,
        "question": "Si un client TCP appelle `close()` sur sa socket alors que le serveur ne fait rien, dans quel état finit la socket côté serveur ?",
        "options": [
            "La connexion reste totalement active jusqu'à ce que le serveur ferme aussi.",
            "La socket serveur passe immédiatement à l'état `CLOSED`.",
            "La socket serveur reçoit un EOF mais reste en `ESTABLISHED`.",
            "La connexion entre dans un état de fermeture passive (ex: `CLOSE_WAIT`), attendant que l'application serveur appelle `close`."
        ],
        "answer": 3,
        "explanation": "Le serveur reçoit un paquet FIN. L'OS passe la socket en `CLOSE_WAIT` et notifie l'application (read retourne 0). L'application *doit* fermer pour libérer les ressources.",
        "chapterId": 1
    },
    {
        "id": 9,
        "question": "Quelle combinaison de paramètres crée une socket UDP IPv4 valide ?",
        "options": [
            "`socket(AF_INET, SOCK_STREAM, IPPROTO_UDP)`",
            "`socket(AF_INET6, SOCK_DGRAM, 0)`",
            "`socket(AF_INET, SOCK_DGRAM, 0)`",
            "`socket(AF_UNIX, SOCK_DGRAM, 0)`"
        ],
        "answer": 2,
        "explanation": "`AF_INET` pour IPv4, `SOCK_DGRAM` pour le mode datagramme (UDP). Le 0 sélectionne le protocole par défaut (UDP).",
        "chapterId": 1
    },
    {
        "id": 10,
        "question": "Pourquoi l'erreur `ECONNREFUSED` survient-elle généralement lors d'un `connect()` ?",
        "options": [
            "Le réseau est physiquement déconnecté.",
            "Aucun processus n'écoute sur l'IP et le port cibles (port fermé).",
            "Le pare-feu a droppé le paquet silencieusement.",
            "L'adresse IP de destination est introuvable (Host Unreachable)."
        ],
        "answer": 1,
        "explanation": "`Connection Refused` signifie qu'un paquet RST a été renvoyé par la machine cible, indiquant qu'aucune socket n'écoute sur ce port.",
        "chapterId": 1
    },
    {
        "id": 11,
        "question": "Quel est la conséquence exacte de l'appel `socket()` sur le réseau ?",
        "options": [
            "Il envoie un paquet broadcast pour annoncer la présence.",
            "Il réserve un port auprès du switch réseau.",
            "Il n'a aucun effet sur le réseau, c'est une opération purement locale au noyau.",
            "Il ouvre une session TCP."
        ],
        "answer": 2,
        "explanation": "`socket()` alloue seulement des structures de données dans le noyau du système d'exploitation local. Aucun paquet n'est émis sur le réseau.",
        "chapterId": 1
    },
    {
        "id": 12,
        "question": "Quel est l'effet d'un `bind()` sur le port 0 ?",
        "options": [
            "Cela provoque immédiatement une erreur `EINVAL`.",
            "Cela lie la socket au port 0, qui est réservé et inutilisable.",
            "Cela demande au système d'exploitation d'attribuer automatiquement un port éphémère disponible.",
            "Cela lie la socket à tous les ports disponibles."
        ],
        "answer": 2,
        "explanation": "Binder sur le port 0 est une convention pour demander au noyau de choisir un port libre aléatoire (port éphémère).",
        "chapterId": 1
    },
    {
        "id": 13,
        "question": "Dans le modèle OSI simplifié pour les sockets, quelle structure doit être castée en `(struct sockaddr *)` ?",
        "options": [
            "`struct in_addr`",
            "`struct sockaddr_in`",
            "`struct ip_mreq`",
            "`struct hostent`"
        ],
        "answer": 1,
        "explanation": "Les fonctions sockets attendent un pointeur générique `struct sockaddr *`. On manipule `struct sockaddr_in` (pour IPv4) et on doit la caster lors de l'appel.",
        "chapterId": 1
    },
    {
        "id": 14,
        "question": "Pourquoi le protocole UDP est-il qualifié de 'non fiable' par rapport à TCP ?",
        "options": [
            "Parce qu'il crypte mal les données.",
            "Parce qu'il ne garantit ni l'ordre, ni la livraison, ni la non-duplication des paquets.",
            "Parce qu'il a une limite de taille de 512 octets.",
            "Parce qu'il nécessite une reconnexion fréquente."
        ],
        "answer": 1,
        "explanation": "UDP est un service 'Best Effort'. Il envoie le datagramme mais ne gère pas les accusés de réception (ACK) ni les retransmissions en cas de perte.",
        "chapterId": 1
    },
    {
        "id": 15,
        "question": "Quelle fonction permet de convertir l'endianness d'un entier court (port) de l'hôte vers le réseau ?",
        "options": [
            "`htonl()`",
            "`ntohl()`",
            "`htons()`",
            "`ntohs()`"
        ],
        "answer": 2,
        "explanation": "`h` (host) `to` `n` (network) `s` (short). Les ports sont des entiers sur 16 bits (short).",
        "chapterId": 1
    },
    {
        "id": 16,
        "question": "Quelle est la valeur de retour de `recv` sur une socket bloquante si la connexion est fermée proprement par le pair (FIN) ?",
        "options": [
            "-1",
            "0",
            "1",
            "Une exception"
        ],
        "answer": 1,
        "explanation": "0 est la valeur signifiant EOF (End Of File) sur une socket.",
        "chapterId": 1
    },
    {
        "id": 17,
        "question": "L'option socket `SO_REUSEADDR` est utile pour :",
        "options": [
            "Économiser de la mémoire",
            "Réutiliser le port immédiatement après un arrêt du serveur (TIME_WAIT)",
            "Avoir deux serveurs sur le même port en simultané",
            "Crypter les données"
        ],
        "answer": 1,
        "explanation": "Elle permet de relancer un serveur (`bind`) sans attendre la fin du délai TIME_WAIT de l'ancien processus.",
        "chapterId": 1
    },
    {
        "id": 18,
        "question": "Sur une machine Big Endian, que fait `htonl(1234)` ?",
        "options": [
            "Elle inverse les octets",
            "Elle retourne 1234 inchangé",
            "Elle retourne 0",
            "Elle plante"
        ],
        "answer": 1,
        "explanation": "Comme la machine est déjà dans l'ordre réseau (Big Endian), la fonction est une opération d'identité (ne fait rien).",
        "chapterId": 1
    },
    {
        "id": 19,
        "question": "En programmation socket IPv4, quelle structure spécifique doit-on utiliser pour l'adresse ?",
        "options": [
            "`struct sockaddr`",
            "`struct sockaddr_in`",
            "`struct in_addr`",
            "`struct ip_addr`"
        ],
        "answer": 1,
        "explanation": "`sockaddr` est opaque/générique. `sockaddr_in` expose les champs `sin_port` et `sin_addr` pour IPv4.",
        "chapterId": 1
    },
    {
        "id": 20,
        "question": "Pourquoi `gethostbyname` est-elle considérée comme dangereuse/obsolète ?",
        "options": [
            "Elle est trop lente",
            "Elle n'est pas thread-safe (utilise une zone mémoire statique) et ne supporte pas IPv6",
            "Elle ne marche que sous Linux",
            "Elle nécessite les droits root"
        ],
        "answer": 1,
        "explanation": "Elle retourne un pointeur vers une donnée statique écrasée à chaque appel. Préférer `getaddrinfo`.",
        "chapterId": 1
    },
    {
        "id": 21,
        "question": "Que reçoit le client si le serveur ne tourne pas sur le port cible (TCP) ?",
        "options": [
            "Rien (Timeout)",
            "Un segment RST (Connection Refused)",
            "Un segment FIN",
            "Une connexion réussie"
        ],
        "answer": 1,
        "explanation": "Si aucun processus n'écoute, l'OS du serveur répond immédiatement par un Reset (RST).",
        "chapterId": 1
    },
    {
        "id": 22,
        "question": "Lors d'un appel système (comme `read`), si le processus reçoit un signal, l'appel peut échouer avec l'erreur :",
        "options": [
            "`EAGAIN`",
            "`EINTR`",
            "`EPIPE`",
            "`ESIG`"
        ],
        "answer": 1,
        "explanation": "Interrupted System Call (`EINTR`). Il faut souvent relancer l'appel manuellement.",
        "chapterId": 1
    },
    {
        "id": 23,
        "question": "Un utilisateur non-privilégié peut-il `bind` sur le port 80 ?",
        "options": [
            "Oui",
            "Non, les ports < 1024 sont réservés root",
            "Oui, s'il est admin",
            "Seulement en UDP"
        ],
        "answer": 1,
        "explanation": "Sur les systèmes Unix, les ports privilégiés (< 1024) nécessitent root.",
        "chapterId": 1
    },
    {
        "id": 24,
        "question": "Si j'appelle `accept` sur une socket configurée en NON-BLOCKING et qu'aucun client n'est là :",
        "options": [
            "Le programme attend",
            "La fonction retourne immédiatement avec une erreur (EWOULDBLOCK/EAGAIN)",
            "La socket se ferme",
            "Le programme plante"
        ],
        "answer": 1,
        "explanation": "C'est le principe du non-bloquant : l'appel ne bloque pas mais signale l'absence de données.",
        "chapterId": 1
    },
    {
        "id": 25,
        "question": "Quelle est la différence entre `close()` et `shutdown(SHUT_WR)` ?",
        "options": [
            "Aucune",
            "`shutdown(SHUT_WR)` envoie FIN mais permet de continuer à LIRE le retour du serveur",
            "`close` permet de lire encore",
            "`shutdown` supprime le fichier"
        ],
        "answer": 1,
        "explanation": "`close` termine tout et libère le fd. `shutdown` ferme un canal (ici écriture) tout en laissant l'autre ouvert (lecture).",
        "chapterId": 1
    },
    {
        "id": 26,
        "question": "Quelle est la fonction qui permet de multiplexer plusieurs sockets (attendre sur plusieurs à la fois) ?",
        "options": [
            "`wait`",
            "`select` (ou `poll`/`epoll`)",
            "`fork`",
            "`bind`"
        ],
        "answer": 1,
        "explanation": "`select` permet de surveiller un ensemble de descripteurs pour voir s'ils sont prêts à lire/écrire.",
        "chapterId": 1
    },
    {
        "id": 27,
        "question": "Quelle famille d'adresse désigne IPv6 ?",
        "options": [
            "`AF_INET`",
            "`AF_INET6`",
            "`AF_UNIX`",
            "`AF_PACKET`"
        ],
        "answer": 1,
        "explanation": "`AF_INET` est pour IPv4. `AF_INET6` pour IPv6.",
        "chapterId": 1
    },
    {
        "id": 28,
        "question": "`listen(sockfd, backlog)` bloque-t-il le programme ?",
        "options": [
            "Oui, jusqu'à une connexion",
            "Non, il ne fait que marquer la socket comme passive",
            "Oui, pendant 1 seconde",
            "Seulement si backlog > 0"
        ],
        "answer": 1,
        "explanation": "`listen` est une configuration d'état. C'est `accept` qui bloque.",
        "chapterId": 1
    },
    {
        "id": 29,
        "question": "Peut-on changer la taille des buffers d'émission/réception TCP ?",
        "options": [
            "Non, c'est fixé par l'OS",
            "Oui, avec `setsockopt` (SO_SNDBUF, SO_RCVBUF)",
            "Seulement à la compilation",
            "Oui, avec `bind`"
        ],
        "answer": 1,
        "explanation": "C'est configurable par socket via `setsockopt`.",
        "chapterId": 1
    },
    {
        "id": 30,
        "question": "En TCP, si `send(..., len)` retourne un entier `n < len` :",
        "options": [
            "C'est une erreur grave",
            "C'est normal, le buffer noyau était presque plein, il faut envoyer le reste",
            "La connexion est morte",
            "Les données sont corrompues"
        ],
        "answer": 1,
        "explanation": "`send` ne garantit pas tout envoyer d'un coup. Il faut gérer les écritures partielles.",
        "chapterId": 1
    },
    {
        "id": 44,
        "question": "Que retourne exactement `Class.forName('com.mysql.cj.jdbc.Driver')` ?",
        "options": [
            "Une instance du Driver",
            "Un objet `Class` représentant le driver",
            "Une connexion",
            "Rien (void)"
        ],
        "answer": 1,
        "explanation": "Elle retourne l'objet `Class<?>`. Le driver s'enregistre de lui-même via son bloc statique.",
        "chapterId": 3
    },
    {
        "id": 45,
        "question": "`DriverManager` est :",
        "options": [
            "Une interface",
            "Une classe abstraite",
            "Une classe utilitaire avec méthodes statiques",
            "Un Singleton"
        ],
        "answer": 2,
        "explanation": "On appelle `DriverManager.getConnection()` statiquement. On ne l'instancie pas.",
        "chapterId": 3
    },
    {
        "id": 46,
        "question": "La méthode `DriverManager.getConnection()` retourne :",
        "options": [
            "Un objet de la classe `Connection`",
            "Un objet implémentant l'interface `Connection`",
            "Un `Socket`",
            "Un `Statement`"
        ],
        "answer": 1,
        "explanation": "`Connection` est une interface. Le type réel est une classe du driver (ex: `ConnectionImpl` de MySQL).",
        "chapterId": 3
    },
    {
        "id": 47,
        "question": "Quelle est la faille MAJEURE de l'utilisation de `Statement` avec concaténation de chaînes ?",
        "options": [
            "Performance médiocre",
            "Injection SQL",
            "Fuite de mémoire",
            "Impossible de compiler"
        ],
        "answer": 1,
        "explanation": "L'attaquant peut manipuler la requête SQL en injectant du code malveillant.",
        "chapterId": 3
    },
    {
        "id": 48,
        "question": "Dans 'SELECT * FROM users WHERE name = ?', le '?' est :",
        "options": [
            "Un caractère générique (wildcard)",
            "Un placeholder (paramètre substituable)",
            "Une erreur de syntaxe",
            "Un pointeur"
        ],
        "answer": 1,
        "explanation": "C'est l'emplacement où `PreparedStatement` insérera la valeur de manière sécurisée.",
        "chapterId": 3
    },
    {
        "id": 49,
        "question": "`stmt.executeQuery(sql)` retourne :",
        "options": [
            "Un `int` (nombre de lignes)",
            "Un `ResultSet`",
            "Un `boolean`",
            "Une `List`"
        ],
        "answer": 1,
        "explanation": "Pour un SELECT, on obtient toujours un curseur de résultats (`ResultSet`).",
        "chapterId": 3
    },
    {
        "id": 50,
        "question": "`stmt.executeUpdate(sql)` retourne :",
        "options": [
            "Un `ResultSet`",
            "Un `boolean`",
            "Un `int` indiquant le nombre de lignes modifiées",
            "L'ID généré"
        ],
        "answer": 2,
        "explanation": "Retourne le 'row count' pour INSERT/UPDATE/DELETE.",
        "chapterId": 3
    },
    {
        "id": 51,
        "question": "Si `stmt.execute(sql)` retourne `true`, cela signifie :",
        "options": [
            "La requête a réussi",
            "La requête a retourné un `ResultSet` (c'est un SELECT)",
            "La requête a retourné un compteur de mise à jour",
            "La connexion est active"
        ],
        "answer": 1,
        "explanation": "`execute()` est générique. `true` = ResultSet disponible, `false` = Update Count disponible (ou pas de résultat).",
        "chapterId": 3
    },
    {
        "id": 52,
        "question": "À l'ouverture, le curseur d'un `ResultSet` est positionné :",
        "options": [
            "Sur la première ligne",
            "Avant la première ligne (BeforeFirst)",
            "Sur la dernière ligne",
            "Sur la ligne null"
        ],
        "answer": 1,
        "explanation": "Il faut impérativement appeler `next()` au moins une fois pour lire la première ligne.",
        "chapterId": 3
    },
    {
        "id": 53,
        "question": "Que retourne `rs.next()` ?",
        "options": [
            "Le prochain tuple (objet)",
            "Un `boolean` (true si une ligne existe, false sinon)",
            "Un `int`",
            "Rien"
        ],
        "answer": 1,
        "explanation": "Permet de piloter une boucle `while(rs.next())`.",
        "chapterId": 3
    },
    {
        "id": 54,
        "question": "Pour lire la première colonne d'un ResultSet, on utilise l'index :",
        "options": [
            "0",
            "1",
            "-1",
            "2"
        ],
        "answer": 1,
        "explanation": "En JDBC, contrairement aux tableaux Java, les indices de colonnes commencent à 1.",
        "chapterId": 3
    },
    {
        "id": 55,
        "question": "Si on oublie de fermer une `Connection` :",
        "options": [
            "Le Garbage Collector le fera immédiatement",
            "On risque une fuite de ressources et un blocage du pool de connexions",
            "Ce n'est pas grave",
            "Le programme plante à la sortie"
        ],
        "answer": 1,
        "explanation": "Les ressources externes (sockets DB) ne sont pas gérées automatiquement et rapidement par le GC.",
        "chapterId": 3
    },
    {
        "id": 56,
        "question": "Par défaut, `autoCommit` est à :",
        "options": [
            "`true` (chaque instruction est validée immédiatement)",
            "`false` (il faut commit manuellement)",
            "`null`",
            "Dépend du driver"
        ],
        "answer": 0,
        "explanation": "C'est le mode par défaut dangereux pour les transactions complexes.",
        "chapterId": 3
    },
    {
        "id": 57,
        "question": "Appeler `rollback()` sur une connexion en `autoCommit(true)` :",
        "options": [
            "Annule la dernière requête",
            "Lance une `SQLException`",
            "Ne fait rien",
            "Ferme la connexion"
        ],
        "answer": 1,
        "explanation": "On ne peut pas rollback une transaction qui n'existe pas (car déjà committée ligne par ligne).",
        "chapterId": 3
    },
    {
        "id": 58,
        "question": "Quel est le but PRINCIPAL d'un DAO ?",
        "options": [
            "Afficher les données",
            "Encapsuler la logique d'accès aux données (CRUD) et masquer le SQL",
            "Optimiser la base",
            "Gérer les sessions HTTP"
        ],
        "answer": 1,
        "explanation": "Séparation des préoccupations (Separation of Concerns). Le métier ne doit pas voir le SQL.",
        "chapterId": 3
    },
    {
        "id": 59,
        "question": "Quelle exception DOIT être gérée (catch/throws) avec JDBC ?",
        "options": [
            "`RuntimeException`",
            "`SQLException` (Checked)",
            "`DbException`",
            "`IOException`"
        ],
        "answer": 1,
        "explanation": "JDBC force la gestion des erreurs SQL via une Checked Exception.",
        "chapterId": 3
    },
    {
        "id": 60,
        "question": "Dans `SearchVM`, si `minPrice` est `null`, la requête générée doit :",
        "options": [
            "Inclure `WHERE price = NULL`",
            "Ignorer ce critère (pas de clause pour price)",
            "Chercher `price = 0`",
            "Planter"
        ],
        "answer": 1,
        "explanation": "Un filtre null signifie 'aucune restriction sur ce champ'.",
        "chapterId": 3
    },
    {
        "id": 61,
        "question": "Pourquoi utiliser `PreparedStatement` est-il plus performant ?",
        "options": [
            "Il ne l'est pas",
            "La base peut pré-compiler le plan d'exécution de la requête (Statement Caching)",
            "Il utilise moins de RAM coté Java",
            "Il n'utilise pas le réseau"
        ],
        "answer": 1,
        "explanation": "La structure SQL étant fixe, le SGBD optimise son analyse.",
        "chapterId": 3
    },
    {
        "id": 62,
        "question": "`java.sql.Date` hérite de :",
        "options": [
            "`java.util.Date`",
            "`java.lang.Object`",
            "`java.time.LocalDate`",
            "`java.sql.Timestamp`"
        ],
        "answer": 0,
        "explanation": "C'est un héritage historique maladroit. Il supprime la partie heure/minute/seconde logiquement.",
        "chapterId": 3
    },
    {
        "id": 63,
        "question": "Pour obtenir le nombre de colonnes d'un résultat, on utilise :",
        "options": [
            "`rs.size()`",
            "`rs.getColumnCount()`",
            "`rs.getMetaData().getColumnCount()`",
            "`rs.width()`"
        ],
        "answer": 2,
        "explanation": "Ces informations structurelles sont dans les Métadonnées.",
        "chapterId": 3
    },
    {
        "id": 64,
        "question": "Pourquoi mapper les champs INT SQL en `Integer` Java dans les entités ?",
        "options": [
            "C'est la norme",
            "Pour pouvoir représenter la valeur SQL `NULL`",
            "Pour gagner de la place",
            "C'est obligatoire pour Hibernate"
        ],
        "answer": 1,
        "explanation": "Le type primitif `int` ne peut pas valoir null, or `NULL` est fréquent en BD.",
        "chapterId": 3
    },
    {
        "id": 65,
        "question": "L'URL JDBC commence toujours par :",
        "options": [
            "`http:`",
            "`jdbc:`",
            "`sql:`",
            "`db:`"
        ],
        "answer": 1,
        "explanation": "Protocole `jdbc`, suivi du sous-protocole (ex: `mysql`).",
        "chapterId": 3
    },
    {
        "id": 66,
        "question": "Quelle méthode permet de définir un paramètre entier à l'index 1 ?",
        "options": [
            "`setInt(0, val)`",
            "`setInt(1, val)`",
            "`putInt(1, val)`",
            "`bindParam(1, val)`"
        ],
        "answer": 1,
        "explanation": "`setInt(index, value)`. Rappel : index 1-based.",
        "chapterId": 3
    },
    {
        "id": 67,
        "question": "Quand peut-on appeler `rs.getString()` ?",
        "options": [
            "Tout de suite après `executeQuery`",
            "Seulement après un `rs.next()` qui retourne `true`",
            "Après `rs.close()`",
            "N'importe quand"
        ],
        "answer": 1,
        "explanation": "Si le curseur n'est pas sur une ligne valide, l'appel échoue.",
        "chapterId": 3
    },
    {
        "id": 68,
        "question": "Quel est le type de curseur par défaut d'un `ResultSet` ?",
        "options": [
            "`TYPE_FORWARD_ONLY` (on ne peut qu'avancer)",
            "`TYPE_SCROLL_INSENSITIVE` (on peut reculer)",
            "`TYPE_SCROLL_SENSITIVE`",
            "`CONCUR_UPDATABLE`"
        ],
        "answer": 0,
        "explanation": "Optimisé pour la lecture séquentielle rapide.",
        "chapterId": 3
    },
    {
        "id": 69,
        "question": "`Class.forName()` est-il obligatoire en JDBC 4.0+ (Java 6+) ?",
        "options": [
            "Oui",
            "Non, le chargement est automatique via SPI si le JAR est présent",
            "Seulement pour Oracle",
            "Non, JDBC est déprécié"
        ],
        "answer": 1,
        "explanation": "`DriverManager` détecte les implementations de `Driver` dans le classpath.",
        "chapterId": 3
    },
    {
        "id": 70,
        "question": "La méthode `executeBatch()` :",
        "options": [
            "Exécute une seule commande",
            "Exécute un lot de commandes groupées pour la performance",
            "Annule la transaction",
            "Ferme la connexion"
        ],
        "answer": 1,
        "explanation": "Permet d'envoyer plusieurs INSERT/UPDATE en un seul aller-retour réseau.",
        "chapterId": 3
    },
    {
        "id": 71,
        "question": "Pour gérer l'ID auto-incrémenté lors d'un `INSERT` :",
        "options": [
            "On le passe dans la requête",
            "On utilise `Statement.RETURN_GENERATED_KEYS`",
            "On fait un SELECT MAX(id) avant",
            "On ne peut pas le récupérer"
        ],
        "answer": 1,
        "explanation": "`conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)` permet de récupérer l'ID créé.",
        "chapterId": 3
    },
    {
        "id": 72,
        "question": "Une transaction assure les propriétés ACID. Que signifie le 'A' ?",
        "options": [
            "Asynchronous",
            "Atomic (Tout ou rien)",
            "Automatic",
            "Available"
        ],
        "answer": 1,
        "explanation": "Atomicité : la transaction s'exécute entièrement ou pas du tout.",
        "chapterId": 3
    },
    {
        "id": 73,
        "question": "Si `rs.next()` retourne `false`, que se passe-t-il si appelle `rs.getString(1)` ?",
        "options": [
            "Ça retourne null",
            "Ça retourne la dernière valeur",
            "Une `SQLException` est levée",
            "Ça retourne vide"
        ],
        "answer": 2,
        "explanation": "Le curseur est 'AfterLast', plus aucune donnée n'est accessible.",
        "chapterId": 3
    },
    {
        "id": 84,
        "question": "Concernant la mémoire partagée dans un processus Java, quelle affirmation est EXACTE ?",
        "options": [
            "Les threads partagent le Tas (Heap) et la Pile (Stack).",
            "Chaque thread possède son propre Tas, mais partage les variables statiques.",
            "Les threads partagent le Tas et les variables statiques, mais chaque thread a sa propre Pile (Stack).",
            "Tout est partagé, il n'y a aucune isolation mémoire entre threads."
        ],
        "answer": 2,
        "explanation": "Piège classique : Les objets (Heap) sont partagés, mais les variables locales (Stack) sont strictement isolées et propres à chaque thread.",
        "chapterId": 2
    },
    {
        "id": 85,
        "question": "Que se passe-t-il exactement si on exécute `monThread.run()` au lieu de `monThread.start()` ?",
        "options": [
            "Une `IllegalThreadStateException` est levée.",
            "Le code de `run()` s'exécute, mais dans le thread courant (appelant), sans créer de nouveau thread.",
            "Rien ne se passe, la méthode est ignorée.",
            "Le thread démarre normalement."
        ],
        "answer": 1,
        "explanation": "`run()` est une méthode normale. Seul `start()` demande à l'OS de créer un nouveau contexte d'exécution (pile, registres) pour le thread.",
        "chapterId": 2
    },
    {
        "id": 86,
        "question": "Pourquoi l'usage de `Runnable` est-il recommandé par rapport à l'héritage de `Thread` ?",
        "options": [
            "Car `Runnable` possède plus de méthodes que `Thread`.",
            "Car on ne peut pas appeler `start()` sur une sous-classe de `Thread`.",
            "Car Java ne supporte pas l'héritage multiple, donc implémenter `Runnable` laisse la possibilité d'hériter d'une autre classe.",
            "C'est faux, l'héritage est toujours recommandé."
        ],
        "answer": 2,
        "explanation": "C'est une question de design et de limitation du langage. De plus, cela sépare la tâche (Runnable) de l'exécutant (Thread).",
        "chapterId": 2
    },
    {
        "id": 87,
        "question": "Quelle est la différence CRITIQUE entre `Thread.sleep(1000)` et `obj.wait(1000)` concernant les verrous ?",
        "options": [
            "Aucune, les deux mettent en pause.",
            "`sleep` relâche le verrou (moniteur), tandis que `wait` le garde.",
            "`wait` relâche le verrou associé à l'objet, tandis que `sleep` garde tous les verrous acquis.",
            "`sleep` est plus précis que `wait`."
        ],
        "answer": 2,
        "explanation": "C'est le piège le plus fréquent. `sleep` dort 'poings fermés' (garde les verrous), alors que `wait` lâche le verrou pour laisser les autres travailler.",
        "chapterId": 2
    },
    {
        "id": 88,
        "question": "Dans le code `t.join()`, quel thread est bloqué ?",
        "options": [
            "Le thread `t` (il est mis en pause).",
            "Le thread qui appelle la méthode `join()` (souvent le main).",
            "Tous les threads du groupe.",
            "Le thread système."
        ],
        "answer": 1,
        "explanation": "`t.join()` signifie 'Moi, thread appelant, j'attends que t ait fini'. `t` continue sa vie normalement.",
        "chapterId": 2
    },
    {
        "id": 89,
        "question": "Que fait réellement la méthode `t.interrupt()` ?",
        "options": [
            "Elle tue le thread immédiatement (arrêt forcé).",
            "Elle met le thread en pause.",
            "Elle positionne simplement un drapeau (flag) indiquant que l'interruption est demandée. Le thread doit le gérer.",
            "Elle lance une exception dans le thread appelant."
        ],
        "answer": 2,
        "explanation": "L'interruption est coopérative. Si le thread ignore le flag (ou ne gère pas l'exception InterruptedException), il ne s'arrêtera pas.",
        "chapterId": 2
    },
    {
        "id": 90,
        "question": "Si deux threads exécutent deux méthodes `synchronized` DIFFÉRENTES sur la MÊME instance d'objet :",
        "options": [
            "Ils peuvent s'exécuter en parallèle sans problème.",
            "Ils sont bloqués mutuellement, l'un doit attendre la fin de l'autre.",
            "Seule la méthode la plus prioritaire passe.",
            "Cela dépend si les méthodes sont statiques."
        ],
        "answer": 1,
        "explanation": "Le verrou est sur l'objet (`this`). Un seul thread peut détenir le verrou de l'instance, quel que soit le nombre de méthodes synchronized.",
        "chapterId": 2
    },
    {
        "id": 91,
        "question": "Quelle instruction lève une `IllegalMonitorStateException` ?",
        "options": [
            "Appeler `notify()` dans un bloc `synchronized`.",
            "Appeler `wait()` sans détenir le verrou de l'objet (hors bloc synchronized).",
            "Appeler `sleep()` dans un bloc `synchronized`.",
            "Appeler `start()` deux fois."
        ],
        "answer": 1,
        "explanation": "On ne peut attendre (`wait`) ou notifier sur un objet que si on en possède la clé (le moniteur).",
        "chapterId": 2
    },
    {
        "id": 92,
        "question": "Analysez ce code : `t.start(); t.setDaemon(true);`",
        "options": [
            "Le thread devient un démon correctement.",
            "Le thread s'arrête.",
            "Une exception `IllegalThreadStateException` est levée dans le thread appelant.",
            "Le thread est mis en pause."
        ],
        "answer": 2,
        "explanation": "Le statut Daemon doit OBLIGATOIREMENT être défini *avant* le démarrage du thread (`start`).",
        "chapterId": 2
    },
    {
        "id": 93,
        "question": "Que garantit l'appel à `Thread.yield()` ?",
        "options": [
            "Que le thread va s'arrêter pour laisser la place aux autres.",
            "Que le thread va dormir pendant 100ms.",
            "Rien de strict : c'est une simple suggestion au planificateur (scheduler) de passer la main.",
            "Que les threads de priorité inférieure vont s'exécuter."
        ],
        "answer": 2,
        "explanation": "`yield` est une heuristique. L'OS peut choisir de l'ignorer totalement. Ce n'est pas un mécanisme de synchronisation fiable.",
        "chapterId": 2
    },
    {
        "id": 94,
        "question": "Concernant `ThreadGroup.activeCount()`, pourquoi est-ce un 'piège' ?",
        "options": [
            "La méthode retourne toujours 0.",
            "La valeur retournée est une estimation instantanée qui peut être fausse la nanoseconde suivante.",
            "Elle compte aussi les threads arrêtés.",
            "Elle lance une exception."
        ],
        "answer": 1,
        "explanation": "Comme les threads démarrent et meurent en permanence, ce nombre est intrinsèquement imprécis.",
        "chapterId": 2
    },
    {
        "id": 95,
        "question": "Quelle est la règle d'or de Swing avec les Threads ?",
        "options": [
            "Tout code Swing doit être exécuté dans le thread principal (main).",
            "Swing est Thread-Safe, on peut modifier l'UI depuis n'importe où.",
            "Toute modification de l'UI doit se faire exclusivement dans l'EDT (Event Dispatch Thread).",
            "On doit utiliser `synchronized` sur chaque composant Swing."
        ],
        "answer": 2,
        "explanation": "Swing n'est pas Thread-Safe. Modifier un bouton depuis un thread worker peut corrompre l'affichage ou causer des plantages.",
        "chapterId": 2
    },
    {
        "id": 96,
        "question": "Quelle est la différence entre `synchronized void m()` et `static synchronized void m()` ?",
        "options": [
            "Aucune, c'est juste une syntaxe.",
            "La première verrouille l'instance (`this`), la seconde verrouille la classe (`Class object`).",
            "La statique est plus rapide.",
            "La statique empêche l'héritage."
        ],
        "answer": 1,
        "explanation": "Ce sont deux verrous distincts. Un thread peut appeler la méthode d'instance et un autre la méthode statique en même temps sans se bloquer.",
        "chapterId": 2
    },
    {
        "id": 97,
        "question": "Si un thread capture une exception non gérée (RuntimeException) :",
        "options": [
            "Le thread meurt, mais les autres threads continuent leur exécution.",
            "Tout le processus Java (JVM) s'arrête immédiatement.",
            "Le thread redémarre automatiquement.",
            "L'exception est convertie en `InterruptedException`."
        ],
        "answer": 0,
        "explanation": "Une exception non catchée tue le thread concerné. Si ce n'est pas le seul thread user, l'application survit.",
        "chapterId": 2
    },
    {
        "id": 98,
        "question": "Peut-on utiliser `PipedInputStream` sans le connecter à un `PipedOutputStream` ?",
        "options": [
            "Oui, il lira des 0.",
            "Non, cela provoquera une exception ou un blocage.",
            "Oui, il agira comme un ByteArrayInputStream.",
            "Oui, mais seulement en écriture."
        ],
        "answer": 1,
        "explanation": "Les Pipes fonctionnent par paire. Un tube doit avoir deux bouts pour fonctionner.",
        "chapterId": 2
    },
    {
        "id": 99,
        "question": "À quoi correspond `synchronized` dans le monde système POSIX ?",
        "options": [
            "Aux Sémaphores",
            "Aux Pipes",
            "Aux Mutex (Mutual Exclusion)",
            "Aux signaux"
        ],
        "answer": 2,
        "explanation": "Le bloc synchronized agit comme un verrou d'exclusion mutuelle (Mutex) : un seul peut entrer.",
        "chapterId": 2
    },
    {
        "id": 100,
        "question": "Pourquoi `stop()` est-elle dangereuse et dépréciée ?",
        "options": [
            "Elle ne ferme pas les fichiers.",
            "Elle relâche brutalement tous les verrous, laissant les objets dans des états incohérents.",
            "Elle consomme trop de CPU.",
            "Elle ne marche que sur Windows."
        ],
        "answer": 1,
        "explanation": "Si un thread modifiait une liste en 3 étapes et est tué à l'étape 2, la liste est corrompue pour tout le monde.",
        "chapterId": 2
    },
    {
        "id": 101,
        "question": "Un thread 'User' (non-daemon) peut-il empêcher l'application de s'arrêter ?",
        "options": [
            "Non, seul le main compte.",
            "Oui, la JVM ne s'arrête que si tous les threads User sont terminés.",
            "Non, si le main finit, tout finit.",
            "Oui, mais seulement s'il est prioritaire."
        ],
        "answer": 1,
        "explanation": "C'est la différence avec les démons. Un thread User actif maintient la JVM en vie, même si le `main` est fini.",
        "chapterId": 2
    },
    {
        "id": 102,
        "question": "Que retourne `Thread.currentThread().isAlive()` ?",
        "options": [
            "False",
            "Toujours True (puisqu'il exécute cette ligne)",
            "Null",
            "Cela dépend de l'état WAITING"
        ],
        "answer": 1,
        "explanation": "Si le thread est capable d'exécuter du code, c'est qu'il est vivant.",
        "chapterId": 2
    },
    {
        "id": 103,
        "question": "Pour mettre à jour une barre de progression Swing depuis un calcul long, j'utilise :",
        "options": [
            "progressBar.setValue(n) directement.",
            "`SwingUtilities.invokeLater(() -> progressBar.setValue(n))`",
            "Thread.yield()",
            "new Thread(() -> progressBar.setValue(n)).start()"
        ],
        "answer": 1,
        "explanation": "Il faut encapsuler la modification de l'UI dans un Runnable envoyé à l'EDT via `invokeLater`.",
        "chapterId": 2
    },
    {
        "id": 104,
        "question": "Est-il garanti qu'un thread de priorité MAX_PRIORITY s'exécutera avant un MIN_PRIORITY ?",
        "options": [
            "Oui, c'est la norme Java.",
            "Non, la gestion des priorités dépend de l'OS et n'est pas garantie stricte.",
            "Oui, sauf sur Linux.",
            "Non, les priorités sont ignorées par toutes les JVM modernes."
        ],
        "answer": 1,
        "explanation": "C'est une 'indication' d'importance. Sur certains systèmes, cela ne change presque rien. Ne jamais baser la logique du programme dessus.",
        "chapterId": 2
    },
    {
        "id": 105,
        "question": "L'interface `Callable` se différencie de `Runnable` car :",
        "options": [
            "Elle est statique",
            "Elle retourne un résultat (Future) et peut lancer une exception",
            "Elle est plus rapide",
            "Elle est obsolète"
        ],
        "answer": 1,
        "explanation": "`Runnable.run` est void. `Callable.call` retourne `V` et déclare `throws Exception`.",
        "chapterId": 2
    },
    {
        "id": 106,
        "question": "Quel risque principal court-on avec l'usage abusif ou mal ordonné de `synchronized` ?",
        "options": [
            "Famine (Starvation)",
            "Deadlock (Interblocage)",
            "StackOverflow",
            "NullPointerException"
        ],
        "answer": 1,
        "explanation": "Si deux threads attendent chacun le verrou de l'autre, ils se bloquent indéfiniment.",
        "chapterId": 2
    },
    {
        "id": 107,
        "question": "Dans un pool de threads, si tous les threads sont occupés et que la file est pleine :",
        "options": [
            "La tâche est rejetée (RejectedExecutionException)",
            "Un nouveau thread est créé (illimité)",
            "Le thread appelant exécute la tâche (CallerRunsPolicy)",
            "Cela dépend de la politique de rejet configurée"
        ],
        "answer": 3,
        "explanation": "Le `ThreadPoolExecutor` a un `RejectedExecutionHandler`. Par défaut, il lance une exception (`AbortPolicy`).",
        "chapterId": 2
    },
    {
        "id": 108,
        "question": "Quelle méthode permet de réveiller un thread en `sleep` ?",
        "options": [
            "wake()",
            "notify()",
            "interrupt()",
            "start()"
        ],
        "answer": 2,
        "explanation": "`sleep()` lance `InterruptedException` si le thread est interrompu pendant son sommeil.",
        "chapterId": 2
    },
    {
        "id": 109,
        "question": "Quelle classe permet d'avoir une variable dont la valeur est propre à chaque thread ?",
        "options": [
            "`ThreadLocal`",
            "`Volatile`",
            "`AtomicVariable`",
            "`GlobalVar`"
        ],
        "answer": 0,
        "explanation": "`ThreadLocal<T>` fournit un espace de stockage distinct pour chaque thread qui y accède.",
        "chapterId": 2
    },
    {
        "id": 110,
        "question": "Quelle structure de données est Thread-Safe par défaut ?",
        "options": [
            "`ArrayList`",
            "`HashMap`",
            "`Vector`",
            "`HashSet`"
        ],
        "answer": 2,
        "explanation": "`Vector` (et `Hashtable`) sont les anciennes collections synchronisées. `ArrayList` ne l'est pas.",
        "chapterId": 2
    },
    {
        "id": 111,
        "question": "Le mot-clé `volatile` garantit :",
        "options": [
            "L'atomicité des opérations (ex: ++)",
            "La visibilité des changements de valeur entre threads immédiatement",
            "Le verrouillage de l'objet",
            "La persistance disque"
        ],
        "answer": 1,
        "explanation": "`volatile` assure que toute lecture voit la dernière écriture (Happens-Before), mais ne gère pas les conflits d'écriture concurrents (pas d'exclusion mutuelle).",
        "chapterId": 2
    },
    {
        "id": 112,
        "question": "Pour attendre qu'un `CountDownLatch` atteigne zéro, on appelle :",
        "options": [
            "`wait()`",
            "`join()`",
            "`await()`",
            "`sleep()`"
        ],
        "answer": 2,
        "explanation": "`await()` bloque le thread jusqu'à ce que le décompte soit fini.",
        "chapterId": 2
    },
    {
        "id": 113,
        "question": "Si le thread `main` se termine, les threads Daemons :",
        "options": [
            "Se terminent immédiatement",
            "Continuent de s'exécuter jusqu'à la fin",
            "Se mettent en pause",
            "Lancent une exception"
        ],
        "answer": 0,
        "explanation": "La JVM s'arrête s'il ne reste que des Daemons.",
        "chapterId": 2
    },
    { "id": 124, "question": "La méthode `ServerSocket.accept()` retourne :", "options": ["Un boolean", "Un `ServerSocket`", "Une `Socket`", "Rien"], "answer": 2, "explanation": "Elle retourne une `Socket` de communication fraîchement créée, dédiée à ce client spécifique.", "chapterId": 4 },
    { "id": 125, "question": "Que signifie TCP ?", "options": ["Transfer Control Protocol", "Transmission Control Protocol", "Transport Connected Protocol", "Total Connection Process"], "answer": 1, "explanation": "Transmission Control Protocol.", "chapterId": 4 },
    { "id": 126, "question": "Si j'écris `new ServerSocket(80)`, combien de clients simultanés peuvent se connecter ?", "options": ["50", "1", "Illimité (dépend de l'OS)", "80"], "answer": 0, "explanation": "Le constructeur par défaut définit la taille de la file d'attente (backlog) à 50. Au-delà, ils sont rejetés.", "chapterId": 4 },
    { "id": 127, "question": "UDP est dit 'non connecté', cela signifie :", "options": ["On ne peut pas envoyer de données", "Il n'y a pas de phase d'établissement (Handshake) avant l'envoi", "L'adresse IP est inutile", "C'est du Wifi"], "answer": 1, "explanation": "Les paquets (Datagrammes) sont envoyés directement sans vérifier si l'autre est prêt.", "chapterId": 4 },
    { "id": 128, "question": "Dans le modèle OSI, la couche Transport correspond à la couche n° :", "options": ["3", "4", "7", "2"], "answer": 1, "explanation": "Couche 4 (Transport). En dessous : Réseau (3). Au dessus : Session (5).", "chapterId": 4 },
    { "id": 129, "question": "Quel flux utiliser pour envoyer des objets Java `Serializable` ?", "options": ["`DataOutputStream`", "`ObjectOutputStream`", "`BufferedOutputStream`", "`PrintWriter`"], "answer": 1, "explanation": "C'est le seul capable de sérialiser des graphes d'objets.", "chapterId": 4 },
    { "id": 130, "question": "Si un serveur lit avec `readInt()`, le client DOIT envoyer avec :", "options": ["`printInt()`", "`write(int)`", "`writeInt()`", "`sendInt()`"], "answer": 2, "explanation": "`DataOutputStream.writeInt` envoie 4 octets. `write(int)` n'en envoie qu'un seul (le moins significatif) !", "chapterId": 4 },
    { "id": 131, "question": "Quelle exception est levée si le délai `setSoTimeout` est dépassé lors d'un `read` ?", "options": ["`TimeoutException`", "`SocketTimeoutException`", "`InterruptedIOException`", "`TimeLimitExceeded`"], "answer": 1, "explanation": "C'est une sous-classe de `InterruptedIOException`.", "chapterId": 4 },
    { "id": 132, "question": "Dans le modèle 'Worker Pool', la méthode `getConnexion()` de la file d'attente est :", "options": ["Non bloquante", "Bloquante (wait)", "Asynchrone", "Récursive"], "answer": 1, "explanation": "Elle met le thread worker en sommeil tant qu'il n'y a pas de travail.", "chapterId": 4 },
    { "id": 133, "question": "Pourquoi l'ordre `new OOS` puis `new OIS` est-il recommandé ?", "options": ["Pour faire joli", "Car `new OIS` bloque en attendant le header que `new OOS` écrit", "Car `OIS` est plus lent", "Ça n'a pas d'importance"], "answer": 1, "explanation": "Si les deux côtés font `new OIS` en premier, ils se bloquent mutuellement (Deadlock d'initialisation).", "chapterId": 4 },
    { "id": 134, "question": "Un port TCP peut-il avoir le même numéro qu'un port UDP sur la même machine ?", "options": ["Non, conflit", "Oui, ce sont des espaces de nommage distincts", "Seulement si IP différente", "Oui mais c'est buggé"], "answer": 1, "explanation": "L'OS gère deux tables de ports séparées pour TCP et UDP.", "chapterId": 4 },
    { "id": 135, "question": "La classe `InetAddress` protège contre ?", "options": ["Le spoofing", "Rien du tout", "Les malwares", "L'instanciation directe (constructeur privé)"], "answer": 3, "explanation": "On n'appelle pas `new`, on passe par des Factory Methods.", "chapterId": 4 },
    { "id": 136, "question": "Si je fais `bw.write('A');` sans `bw.flush()`, quand 'A' est-il envoyé ?", "options": ["Tout de suite", "Quand le buffer est plein ou à la fermeture du flux", "Jamais", "Au bout de 1s"], "answer": 1, "explanation": "C'est le principe du buffering. `flush()` force l'envoi immédiat.", "chapterId": 4 },
    { "id": 137, "question": "Le thread `EDT` (Event Dispatch Thread) de Swing ne doit JAMAIS :", "options": ["Modifier l'IHM", "Être bloqué par une opération longue (I/O réseau)", "Lancer des événements", "Être nommé"], "answer": 1, "explanation": "Sinon l'interface graphique gèle (freeze).", "chapterId": 4 },
    { "id": 138, "question": "Que vaut `activeCount()` sur un `ThreadGroup` ?", "options": ["Le nombre exact de threads", "Une estimation du nombre de threads actifs", "Le nombre de processus", "L'ID du groupe"], "answer": 1, "explanation": "C'est une estimation car des threads peuvent mourir/naître pendant le comptage.", "chapterId": 4 },
    { "id": 139, "question": "Pour fermer proprement une connexion :", "options": ["Il suffit de tuer le processus", "On ferme les flux puis la socket", "On met la socket à null", "On coupe le wifi"], "answer": 1, "explanation": "Fermer le flux de sortie ferme généralement la socket, mais `socket.close()` est la méthode explicite.", "chapterId": 4 },
    { "id": 140, "question": "Quelle classe permet de lire ligne par ligne proprement ?", "options": ["`BufferedReader`", "`FileReader`", "`LineInputStream`", "`StringReader`"], "answer": 0, "explanation": "Méthode `readLine()`.", "chapterId": 4 },
    { "id": 141, "question": "Si une classe contient un champ `Thread`, est-elle Serializable ?", "options": ["Oui", "Non, `Thread` n'est pas Serializable", "Oui si le thread est daemon", "Oui si transient"], "answer": 1, "explanation": "Un Thread est lié à l'OS, on ne peut pas le sérialiser. Il faut le marquer `transient`.", "chapterId": 4 },
    { "id": 142, "question": "L'adresse locale (loopback) est généralement :", "options": ["192.168.1.1", "127.0.0.1", "0.0.0.0", "255.255.255.255"], "answer": 1, "explanation": "localhost.", "chapterId": 4 },
    { "id": 143, "question": "`bind()` sert à :", "options": ["Se connecter", "Associer une socket à une IP et un port local", "Écouter", "Accepter"], "answer": 1, "explanation": "C'est l'étape avant `listen()` pour un serveur.", "chapterId": 4 },
    { "id": 144, "question": "Si le client envoie 'Hello' mais que le serveur lit un Objet :", "options": ["Ça marche", "StreamCorruptedException", "ClassCastException", "EOFException"], "answer": 1, "explanation": "Le flux d'objets attend un header magique spécifique. Du texte brut corrompt ce flux.", "chapterId": 4 },
    { "id": 145, "question": "Quel est l'intérêt du mot clé `synchronized` dans la file d'attente du Pool ?", "options": ["Rendre la méthode plus rapide", "Assurer l'exclusion mutuelle et la cohérence mémoire entre threads", "Empêcher le compilateur d'optimiser", "Aucun"], "answer": 1, "explanation": "Sans ça, deux threads pourraient prendre la même connexion.", "chapterId": 4 },
    { "id": 146, "question": "`notify()` réveille :", "options": ["Tous les threads", "Un seul thread choisi arbitrairement par le scheduler", "Le thread le plus prioritaire", "Le thread main"], "answer": 1, "explanation": "Il faut utiliser `notifyAll()` si on veut tous les réveiller (mais ici un seul suffit).", "chapterId": 4 },
    { "id": 147, "question": "Le garbage collector ferme-t-il les sockets oubliées ?", "options": ["Oui, tout de suite", "Oui, mais on ne sait pas quand (risqué)", "Non, jamais", "Seulement en debug"], "answer": 1, "explanation": "Il faut toujours utiliser `close()` dans un `finally` ou try-with-resources.", "chapterId": 4 },
    { "id": 148, "question": "Quel composant permet d'éviter de bloquer l'EDT Swing lors d'un accès réseau ?", "options": ["`SwingWorker` (ou un Thread séparé)", "`JPanel`", "`ActionListener`", "`Timer`"], "answer": 0, "explanation": "Il permet d'exécuter une tâche en arrière-plan et de mettre à jour l'UI à la fin.", "chapterId": 4 },
    { "id": 149, "question": "Un `DataInputStream` lit :", "options": ["Des octets bruts uniquement", "Des types primitifs Java (int, long...) portables", "Du XML", "Des objets"], "answer": 1, "explanation": "Il gère l'endianness standard du réseau (Big Endian) pour les primitifs.", "chapterId": 4 },
    { "id": 150, "question": "L'interface `Serializable` a combien de méthodes ?", "options": ["0 (marqueur)", "1 (serialize)", "2 (read/write)", "10"], "answer": 0, "explanation": "C'est une interface marqueur vide.", "chapterId": 4 },
    { "id": 151, "question": "`InetAddress.getAllByName(host)` retourne :", "options": ["Une seule IP", "Un tableau d'IPs (équilibrage de charge)", "Une exception", "Le DNS"], "answer": 1, "explanation": "Un nom de domaine peut pointer vers plusieurs IP (Round Robin DNS).", "chapterId": 4 },
    { "id": 152, "question": "Si j'utilise `ObjectOutputStream` sur un socket, le pair doit utiliser :", "options": ["`DataInputStream`", "`ObjectInputStream`", "`FileInputStream`", "`Reader`"], "answer": 1, "explanation": "Symétrie obligatoire des flux.", "chapterId": 4 },
    { "id": 153, "question": "Quelle est la limite théorique du nombre de ports TCP ?", "options": ["1024", "65535", "4 milliards", "Infini"], "answer": 1, "explanation": "Limité par le champ de 16 bits de l'en-tête TCP (2^16 - 1).", "chapterId": 4 }
]