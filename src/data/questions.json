[
    {
        "id": 1,
        "question": "Juste après l'appel à `socket(AF_INET, SOCK_STREAM, 0)`, quel est l'état exact de la socket ?",
        "options": [
            "Elle est connectée à l'hôte local sur un port aléatoire.",
            "Elle est créée, mais anonyme (sans adresse IP ni port) et non connectée.",
            "Elle est automatiquement liée au port 0 en attente de `connect`.",
            "Elle est en mode écoute (listen) en attente de `accept`."
        ],
        "answer": 1,
        "explanation": "La socket est créée (descripteur alloué) mais n'a aucune identité réseau (anonyme) tant que `bind` ou `connect` n'est pas appelé. Elle n'est ni liée ni connectée.",
        "chapterId": 1
    },
    {
        "id": 2,
        "question": "Concernant la primitive `bind()` dans une architecture TCP Client/Serveur, quelle affirmation est strictement vraie ?",
        "options": [
            "Elle est optionnelle pour le serveur mais obligatoire pour le client afin de fixer son port source.",
            "Elle est obligatoire pour le serveur pour définir son écoute, mais le client comportement est indéfini s'il l'utilise.",
            "Elle est obligatoire pour le serveur, tandis que le client peut l'utiliser mais s'en remet généralement au noyau (bind implicite).",
            "Elle est obligatoire pour les deux parties afin de garantir l'unicité du couple {IP, Port}."
        ],
        "answer": 2,
        "explanation": "Le serveur *doit* être joignable sur un port connu. Le client *peut* choisir son port, mais laisse généralement l'OS choisir un port éphémère via un bind implicite.",
        "chapterId": 1
    },
    {
        "id": 3,
        "question": "Dans `listen(sockfd, backlog)`, que représente exactement l'entier `backlog` ?",
        "options": [
            "Le nombre maximum de connexions actives simultanées que le serveur peut gérer.",
            "Le nombre maximum de demandes de connexions en attente (handshake terminé, en attente d'accept).",
            "La taille en octets du buffer de réception pour cette socket.",
            "Le délai d'attente (timeout) en secondes avant de rejeter un client."
        ],
        "answer": 1,
        "explanation": "Le backlog définit la taille de la file d'attente des connexions *pending* (3-way handshake fini) que l'application n'a pas encore acceptées via `accept()`.",
        "chapterId": 1
    },
    {
        "id": 4,
        "question": "Quelle est la relation précise entre `write(fd, buf, len)` et `send(fd, buf, len, flags)` sous UNIX ?",
        "options": [
            "Elles sont strictement identiques, `write` est juste une macro pour `send` avec `flags=0`.",
            "Si `flags=0`, elles effectuent la même opération, mais `send` ne fonctionne que sur des sockets.",
            " `send` est plus rapide que `write` car elle contourne la couche VFS (Virtual File System).",
            " `write` ajoute automatiquement un terminateur nul au buffer, contrairement à `send`."
        ],
        "answer": 1,
        "explanation": "Sur une socket, `send` avec `flags=0` est équivalent à `write`. Cependant `send` est spécifique aux sockets, alors que `write` est générique pour tout fichier.",
        "chapterId": 1
    },
    {
        "id": 5,
        "question": "Que retourne l'appel système `accept(listening_socket, ...)` en cas de succès ?",
        "options": [
            "L'entier `0` pour confirmer que le handshake a réussi.",
            "Le même descripteur `listening_socket`, mais passé en mode connecté.",
            "Un nouveau descripteur de fichier spécifiquement dédié à cette connexion client.",
            "L'adresse IP du client sous forme d'entier."
        ],
        "answer": 2,
        "explanation": "`accept` crée une *nouvelle* socket pour la connexion établie. La socket d'origine reste en mode écoute (LISTEN) pour d'autres clients.",
        "chapterId": 1
    },
    {
        "id": 6,
        "question": "Vous lancez votre serveur et il échoue immédiatement avec l'erreur `EADDRINUSE`. Quelle est la cause la plus probable ?",
        "options": [
            "Le client distant a rejeté la connexion.",
            "Le serveur tente de se lier (bind) à un port déjà occupé par un autre processus ou une socket en attente.",
            "Le câble réseau est débranché.",
            "Les permissions root sont requises pour ouvrir une socket (EACCES)."
        ],
        "answer": 1,
        "explanation": "`EADDRINUSE` signifie que l'adresse (IP + Port) demandée est déjà utilisée localement par une autre socket.",
        "chapterId": 1
    },
    {
        "id": 7,
        "question": "Quel appel système déclenche l'envoi du paquet TCP SYN par le client ?",
        "options": [
            "Au moment de la création de la socket avec `socket()`.",
            "Au moment de l'appel à `bind()`.",
            "Au moment de l'appel à `connect()`.",
            "Lors du premier `send()` de données."
        ],
        "answer": 2,
        "explanation": "C'est `connect()` qui initie le '3-way handshake', commençant par l'envoi du SYN.",
        "chapterId": 1
    },
    {
        "id": 8,
        "question": "Si un client TCP appelle `close()` sur sa socket alors que le serveur ne fait rien, dans quel état finit la socket côté serveur ?",
        "options": [
            "La connexion reste totalement active jusqu'à ce que le serveur ferme aussi.",
            "La socket serveur passe immédiatement à l'état `CLOSED`.",
            "La socket serveur reçoit un EOF mais reste en `ESTABLISHED`.",
            "La connexion entre dans un état de fermeture passive (ex: `CLOSE_WAIT`), attendant que l'application serveur appelle `close`."
        ],
        "answer": 3,
        "explanation": "Le serveur reçoit un paquet FIN. L'OS passe la socket en `CLOSE_WAIT` et notifie l'application (read retourne 0). L'application *doit* fermer pour libérer les ressources.",
        "chapterId": 1
    },
    {
        "id": 9,
        "question": "Quelle combinaison de paramètres crée une socket UDP IPv4 valide ?",
        "options": [
            "`socket(AF_INET, SOCK_STREAM, IPPROTO_UDP)`",
            "`socket(AF_INET6, SOCK_DGRAM, 0)`",
            "`socket(AF_INET, SOCK_DGRAM, 0)`",
            "`socket(AF_UNIX, SOCK_DGRAM, 0)`"
        ],
        "answer": 2,
        "explanation": "`AF_INET` pour IPv4, `SOCK_DGRAM` pour le mode datagramme (UDP). Le 0 sélectionne le protocole par défaut (UDP).",
        "chapterId": 1
    },
    {
        "id": 10,
        "question": "Pourquoi l'erreur `ECONNREFUSED` survient-elle généralement lors d'un `connect()` ?",
        "options": [
            "Le réseau est physiquement déconnecté.",
            "Aucun processus n'écoute sur l'IP et le port cibles (port fermé).",
            "Le pare-feu a droppé le paquet silencieusement.",
            "L'adresse IP de destination est introuvable (Host Unreachable)."
        ],
        "answer": 1,
        "explanation": "`Connection Refused` signifie qu'un paquet RST a été renvoyé par la machine cible, indiquant qu'aucune socket n'écoute sur ce port.",
        "chapterId": 1
    },
    {
        "id": 11,
        "question": "Quel est la conséquence exacte de l'appel `socket()` sur le réseau ?",
        "options": [
            "Il envoie un paquet broadcast pour annoncer la présence.",
            "Il réserve un port auprès du switch réseau.",
            "Il n'a aucun effet sur le réseau, c'est une opération purement locale au noyau.",
            "Il ouvre une session TCP."
        ],
        "answer": 2,
        "explanation": "`socket()` alloue seulement des structures de données dans le noyau du système d'exploitation local. Aucun paquet n'est émis sur le réseau.",
        "chapterId": 1
    },
    {
        "id": 12,
        "question": "Quel est l'effet d'un `bind()` sur le port 0 ?",
        "options": [
            "Cela provoque immédiatement une erreur `EINVAL`.",
            "Cela lie la socket au port 0, qui est réservé et inutilisable.",
            "Cela demande au système d'exploitation d'attribuer automatiquement un port éphémère disponible.",
            "Cela lie la socket à tous les ports disponibles."
        ],
        "answer": 2,
        "explanation": "Binder sur le port 0 est une convention pour demander au noyau de choisir un port libre aléatoire (port éphémère).",
        "chapterId": 1
    },
    {
        "id": 13,
        "question": "Dans le modèle OSI simplifié pour les sockets, quelle structure doit être castée en `(struct sockaddr *)` ?",
        "options": [
            "`struct in_addr`",
            "`struct sockaddr_in`",
            "`struct ip_mreq`",
            "`struct hostent`"
        ],
        "answer": 1,
        "explanation": "Les fonctions sockets attendent un pointeur générique `struct sockaddr *`. On manipule `struct sockaddr_in` (pour IPv4) et on doit la caster lors de l'appel.",
        "chapterId": 1
    },
    {
        "id": 14,
        "question": "Pourquoi le protocole UDP est-il qualifié de 'non fiable' par rapport à TCP ?",
        "options": [
            "Parce qu'il crypte mal les données.",
            "Parce qu'il ne garantit ni l'ordre, ni la livraison, ni la non-duplication des paquets.",
            "Parce qu'il a une limite de taille de 512 octets.",
            "Parce qu'il nécessite une reconnexion fréquente."
        ],
        "answer": 1,
        "explanation": "UDP est un service 'Best Effort'. Il envoie le datagramme mais ne gère pas les accusés de réception (ACK) ni les retransmissions en cas de perte.",
        "chapterId": 1
    },
    {
        "id": 15,
        "question": "Quelle fonction permet de convertir l'endianness d'un entier court (port) de l'hôte vers le réseau ?",
        "options": [
            "`htonl()`",
            "`ntohl()`",
            "`htons()`",
            "`ntohs()`"
        ],
        "answer": 2,
        "explanation": "`h` (host) `to` `n` (network) `s` (short). Les ports sont des entiers sur 16 bits (short).",
        "chapterId": 1
    },
    { "id": 16, "question": "Quelle est la valeur de retour de `recv` sur une socket bloquante si la connexion est fermée proprement par le pair (FIN) ?", "options": ["-1", "0", "1", "Une exception"], "answer": 1, "explanation": "0 est la valeur signifiant EOF (End Of File) sur une socket.", "chapterId": 1 },
    { "id": 17, "question": "L'option socket `SO_REUSEADDR` est utile pour :", "options": ["Économiser de la mémoire", "Réutiliser le port immédiatement après un arrêt du serveur (TIME_WAIT)", "Avoir deux serveurs sur le même port en simultané", "Crypter les données"], "answer": 1, "explanation": "Elle permet de relancer un serveur (`bind`) sans attendre la fin du délai TIME_WAIT de l'ancien processus.", "chapterId": 1 },
    { "id": 18, "question": "Sur une machine Big Endian, que fait `htonl(1234)` ?", "options": ["Elle inverse les octets", "Elle retourne 1234 inchangé", "Elle retourne 0", "Elle plante"], "answer": 1, "explanation": "Comme la machine est déjà dans l'ordre réseau (Big Endian), la fonction est une opération d'identité (ne fait rien).", "chapterId": 1 },
    { "id": 19, "question": "En programmation socket IPv4, quelle structure spécifique doit-on utiliser pour l'adresse ?", "options": ["`struct sockaddr`", "`struct sockaddr_in`", "`struct in_addr`", "`struct ip_addr`"], "answer": 1, "explanation": "`sockaddr` est opaque/générique. `sockaddr_in` expose les champs `sin_port` et `sin_addr` pour IPv4.", "chapterId": 1 },
    { "id": 20, "question": "Pourquoi `gethostbyname` est-elle considérée comme dangereuse/obsolète ?", "options": ["Elle est trop lente", "Elle n'est pas thread-safe (utilise une zone mémoire statique) et ne supporte pas IPv6", "Elle ne marche que sous Linux", "Elle nécessite les droits root"], "answer": 1, "explanation": "Elle retourne un pointeur vers une donnée statique écrasée à chaque appel. Préférer `getaddrinfo`.", "chapterId": 1 },
    { "id": 21, "question": "Que reçoit le client si le serveur ne tourne pas sur le port cible (TCP) ?", "options": ["Rien (Timeout)", "Un segment RST (Connection Refused)", "Un segment FIN", "Une connexion réussie"], "answer": 1, "explanation": "Si aucun processus n'écoute, l'OS du serveur répond immédiatement par un Reset (RST).", "chapterId": 1 },
    { "id": 22, "question": "Lors d'un appel système (comme `read`), si le processus reçoit un signal, l'appel peut échouer avec l'erreur :", "options": ["`EAGAIN`", "`EINTR`", "`EPIPE`", "`ESIG`"], "answer": 1, "explanation": "Interrupted System Call (`EINTR`). Il faut souvent relancer l'appel manuellement.", "chapterId": 1 },
    { "id": 23, "question": "Un utilisateur non-privilégié peut-il `bind` sur le port 80 ?", "options": ["Oui", "Non, les ports < 1024 sont réservés root", "Oui, s'il est admin", "Seulement en UDP"], "answer": 1, "explanation": "Sur les systèmes Unix, les ports privilégiés (< 1024) nécessitent root.", "chapterId": 1 },
    { "id": 24, "question": "Si j'appelle `accept` sur une socket configurée en NON-BLOCKING et qu'aucun client n'est là :", "options": ["Le programme attend", "La fonction retourne immédiatement avec une erreur (EWOULDBLOCK/EAGAIN)", "La socket se ferme", "Le programme plante"], "answer": 1, "explanation": "C'est le principe du non-bloquant : l'appel ne bloque pas mais signale l'absence de données.", "chapterId": 1 },
    { "id": 25, "question": "Quelle est la différence entre `close()` et `shutdown(SHUT_WR)` ?", "options": ["Aucune", "`shutdown(SHUT_WR)` envoie FIN mais permet de continuer à LIRE le retour du serveur", "`close` permet de lire encore", "`shutdown` supprime le fichier"], "answer": 1, "explanation": "`close` termine tout et libère le fd. `shutdown` ferme un canal (ici écriture) tout en laissant l'autre ouvert (lecture).", "chapterId": 1 },
    { "id": 26, "question": "Quelle est la fonction qui permet de multiplexer plusieurs sockets (attendre sur plusieurs à la fois) ?", "options": ["`wait`", "`select` (ou `poll`/`epoll`)", "`fork`", "`bind`"], "answer": 1, "explanation": "`select` permet de surveiller un ensemble de descripteurs pour voir s'ils sont prêts à lire/écrire.", "chapterId": 1 },
    { "id": 27, "question": "Quelle famille d'adresse désigne IPv6 ?", "options": ["`AF_INET`", "`AF_INET6`", "`AF_UNIX`", "`AF_PACKET`"], "answer": 1, "explanation": "`AF_INET` est pour IPv4. `AF_INET6` pour IPv6.", "chapterId": 1 },
    { "id": 28, "question": "`listen(sockfd, backlog)` bloque-t-il le programme ?", "options": ["Oui, jusqu'à une connexion", "Non, il ne fait que marquer la socket comme passive", "Oui, pendant 1 seconde", "Seulement si backlog > 0"], "answer": 1, "explanation": "`listen` est une configuration d'état. C'est `accept` qui bloque.", "chapterId": 1 },
    { "id": 29, "question": "Peut-on changer la taille des buffers d'émission/réception TCP ?", "options": ["Non, c'est fixé par l'OS", "Oui, avec `setsockopt` (SO_SNDBUF, SO_RCVBUF)", "Seulement à la compilation", "Oui, avec `bind`"], "answer": 1, "explanation": "C'est configurable par socket via `setsockopt`.", "chapterId": 1 },
    { "id": 30, "question": "En TCP, si `send(..., len)` retourne un entier `n < len` :", "options": ["C'est une erreur grave", "C'est normal, le buffer noyau était presque plein, il faut envoyer le reste", "La connexion est morte", "Les données sont corrompues"], "answer": 1, "explanation": "`send` ne garantit pas tout envoyer d'un coup. Il faut gérer les écritures partielles.", "chapterId": 1 },
    { "id": 31, "question": "Le descripteur de fichier (fd) standard `0` correspond à :", "options": ["Stdout", "Stderr", "Stdin", "Socket"], "answer": 2, "explanation": "0: Entrée standard, 1: Sortie standard, 2: Erreur standard.", "chapterId": 1 },
    { "id": 32, "question": "Peut-on appeler `connect` sur une socket UDP ?", "options": ["Non, jamais", "Oui, pour enregistrer l'adresse de destination par défaut et filtrer les paquets reçus", "Oui, cela transforme l'UDP en TCP", "Cela plante"], "answer": 1, "explanation": "Cela ne crée pas de connexion réseau, mais configure la socket pour ne parler qu'à cette adresse (et permet d'utiliser `send`/`recv` au lieu de `sendto`/`recvfrom`).", "chapterId": 1 },
    { "id": 33, "question": "Quelle fonction convertit une IP texte '192.168.1.1' en binaire ?", "options": ["`inet_ntoa`", "`inet_pton` (ou `inet_aton`)", "`htonl`", "`getnameinfo`"], "answer": 1, "explanation": "`p` (presentation) `to` `n` (network). `inet_ntoa` fait l'inverse.", "chapterId": 1 },
    { "id": 34, "question": "Quelle commande permet de lister les connexions TCP actives ?", "options": ["`ls`", "`netstat` (ou `ss`)", "`ping`", "`ifconfig`"], "answer": 1, "explanation": "`netstat -tn` ou `ss -tn` affiche les sockets TCP.", "chapterId": 1 },
    { "id": 35, "question": "Quel flag de `recv` permet de lire les données sans les retirer du buffer (Peek) ?", "options": ["`MSG_OOB`", "`MSG_PEEK`", "`MSG_WAITALL`", "`MSG_DONTROUTE`"], "answer": 1, "explanation": "`MSG_PEEK` permet de 'regarder' ce qui est arrivé sans consommer les données.", "chapterId": 1 },
    { "id": 36, "question": "La plage des ports 'Bien Connus' (Well Known Ports) est :", "options": ["0-1023", "1024-49151", "49152-65535", "0-100"], "answer": 0, "explanation": "Administrés par l'IANA, ils requièrent souvent des privilèges système.", "chapterId": 1 },
    { "id": 37, "question": "L'adresse 127.0.0.1 signifie :", "options": ["Le réseau local", "La machine elle-même (localhost/loopback)", "Le routeur", "L'adresse de broadcast"], "answer": 1, "explanation": "C'est l'interface de bouclage, les paquets ne sortent pas sur le réseau physique.", "chapterId": 1 },
    { "id": 38, "question": "Comment le serveur obtient-il l'IP du client connecté ?", "options": ["Elle est stockée dans la structure passée au `bind`", "Elle est remplie dans la structure `sockaddr` passée à `accept`", "Le client l'envoie par message texte", "Il ne peut pas"], "answer": 1, "explanation": "`accept(sockfd, &addr, &len)` remplit `addr` avec les infos du client.", "chapterId": 1 },
    { "id": 39, "question": "Pourquoi existe-t-il `htonl` et `ntohl` ?", "options": ["Pour crypter", "Pour gérer la différence d'ordre des octets (Endianness) entre processeurs différents", "Pour compresser", "C'est historique"], "answer": 1, "explanation": "Le réseau est Big Endian. Les PC (x86) sont Little Endian. Il faut convertir.", "chapterId": 1 },
    { "id": 40, "question": "L'erreur `EPIPE` (Broken Pipe) survient quand :", "options": ["On lit sur une socket fermée", "On écrit sur une socket dont le lecteur a fermé sa connexion", "Le réseau est lent", "Le câble est débranché"], "answer": 1, "explanation": "Si le pair a fermé et qu'on insiste pour écrire, le noyau envoie `SIGPIPE` et retourne `EPIPE`.", "chapterId": 1 },
    {
        "id": 44,
        "chapterId": 3,
        "question": "Quel est le rôle principal de `Class.forName('driver...')` ?",
        "options": [
            "Créer la connexion à la BD",
            "Charger le driver JDBC en mémoire",
            "Exécuter des requêtes SQL",
            "Trier les résultats"
        ],
        "answer": 1,
        "explanation": "`Class.forName()` charge dynamiquement la classe du driver et déclenche son auto-enregistrement auprès du `DriverManager`."
    },
    {
        "id": 45,
        "chapterId": 3,
        "question": "Depuis JDBC 4, `Class.forName()` est-il obligatoire ?",
        "options": [
            "Oui, toujours",
            "Non, le chargement est souvent automatique",
            "Oui, si on utilise MySQL",
            "Non, JDBC ne nécessite plus de driver"
        ],
        "answer": 1,
        "explanation": "Les drivers modernes sont détectés automatiquement via le mécanisme SPI de Java."
    },
    {
        "id": 46,
        "chapterId": 3,
        "question": "Quelle classe gère la liste des drivers et fournit les connexions ?",
        "options": [
            "Connection",
            "Driver",
            "DriverManager",
            "DataSource"
        ],
        "answer": 2,
        "explanation": "`DriverManager` est la classe utilitaire qui sélectionne le bon driver en fonction de l'URL JDBC fournie."
    },
    {
        "id": 47,
        "chapterId": 3,
        "question": "`Connection` en JDBC est :",
        "options": [
            "Une classe",
            "Une interface",
            "Une méthode",
            "Une exception"
        ],
        "answer": 1,
        "explanation": "`Connection` est une interface définissant le contrat standard. L'implémentation réelle est fournie par le driver (ex: MySQL)."
    },
    {
        "id": 48,
        "chapterId": 3,
        "question": "Quel est le format typique d'une URL JDBC MySQL ?",
        "options": [
            "http://mysql/db",
            "jdbc:mysql://host:port/db",
            "sql:jdbc:mysql:db",
            "mysql:host:db"
        ],
        "answer": 1,
        "explanation": "Le format standard est `jdbc:<sous-protocole>:<détails>`."
    },
    {
        "id": 49,
        "chapterId": 3,
        "question": "Quelle méthode permet d'obtenir une connexion ?",
        "options": [
            "new Connection()",
            "DriverManager.getConnection()",
            "Statement.connect()",
            "Class.forName()"
        ],
        "answer": 1,
        "explanation": "On ne fait jamais `new Connection()`. C'est `DriverManager` qui fabrique l'objet."
    },
    {
        "id": 50,
        "chapterId": 3,
        "question": "Par défaut, le mode Auto-Commit d'une connexion est :",
        "options": [
            "Désactivé (false)",
            "Activé (true)",
            "Aléatoire",
            "Réservé à l'admin"
        ],
        "answer": 1,
        "explanation": "Par défaut, chaque requête SQL (INSERT/UPDATE...) est validée immédiatement."
    },
    {
        "id": 51,
        "chapterId": 3,
        "question": "Quand `rollback()` a-t-il un effet ?",
        "options": [
            "Toujours",
            "Jamais",
            "Seulement si Auto-Commit est désactivé (false)",
            "Seulement après un SELECT"
        ],
        "answer": 2,
        "explanation": "Si Auto-Commit est true, les transactions sont instantanées. Pour utiliser rollback, il faut gérer la transaction manuellement."
    },
    {
        "id": 52,
        "chapterId": 3,
        "question": "Quelle interface permet d'envoyer des requêtes SQL basiques ?",
        "options": [
            "ResultSet",
            "Statement",
            "Query",
            "Transaction"
        ],
        "answer": 1,
        "explanation": "`Statement` est l'interface de base pour l'exécution d'instructions SQL statiques."
    },
    {
        "id": 53,
        "chapterId": 3,
        "question": "Que retourne `stmt.executeUpdate(...)` ?",
        "options": [
            "Un ResultSet",
            "Un boolean",
            "Un int (nombre de lignes affectées)",
            "Une Connection"
        ],
        "answer": 2,
        "explanation": "Il retourne le nombre de lignes insérées, modifiées ou supprimées."
    },
    {
        "id": 54,
        "chapterId": 3,
        "question": "Que retourne `stmt.executeQuery(...)` ?",
        "options": [
            "Un ResultSet",
            "Un int",
            "Un boolean",
            "Un tableau"
        ],
        "answer": 0,
        "explanation": "Il est utilisé pour les SELECT et retourne toujours un objet `ResultSet`."
    },
    {
        "id": 55,
        "chapterId": 3,
        "question": "La méthode `execute(sql)` peut exécuter :",
        "options": [
            "Seulement des SELECT",
            "Seulement des UPDATE",
            "N'importe quel type de requête SQL",
            "Rien, elle n'existe pas"
        ],
        "answer": 2,
        "explanation": "`execute()` est générique. Elle retourne `true` si le résultat est un ResultSet, `false` sinon."
    },
    {
        "id": 56,
        "chapterId": 3,
        "question": "Pourquoi faut-il appeler `rs.next()` avant de lire des données ?",
        "options": [
            "Pour trier les données",
            "Car le curseur est initialement placé AVANT la première ligne",
            "C'est optionnel",
            "Pour se connecter à la base"
        ],
        "answer": 1,
        "explanation": "Le curseur démarre 'beforeFirst'. Le premier appel à `next()` le place sur la première ligne réelle."
    },
    {
        "id": 57,
        "chapterId": 3,
        "question": "En JDBC, les index des colonnes commencent généralement à :",
        "options": [
            "0",
            "1",
            "-1",
            "Cela dépend du driver"
        ],
        "answer": 1,
        "explanation": "Dans l'API JDBC standard, les index de colonnes sont 1-based (commencent à 1)."
    },
    {
        "id": 58,
        "chapterId": 3,
        "question": "Quel est le risque principal de `Statement` classique ?",
        "options": [
            "Il est trop rapide",
            "L'injection SQL",
            "Il ne supporte pas les SELECT",
            "Il utilise trop de mémoire"
        ],
        "answer": 1,
        "explanation": "En concaténant des chaînes pour créer la requête, on est vulnérable aux injections SQL."
    },
    {
        "id": 59,
        "chapterId": 3,
        "question": "Quelle est la version sécurisée et précompilée de `Statement` ?",
        "options": [
            "SecureStatement",
            "PreparedStatement",
            "CompiledQuery",
            "FocusStatement"
        ],
        "answer": 1,
        "explanation": "`PreparedStatement` permet de séparer le code SQL des données (paramètres), empêchant l'injection."
    },
    {
        "id": 60,
        "chapterId": 3,
        "question": "Dans `PreparedStatement`, par quoi sont remplacés les paramètres ?",
        "options": [
            "Des %",
            "Des $",
            "Des points d'interrogation (?)",
            "Des étoiles (*)"
        ],
        "answer": 2,
        "explanation": "Les placeholders sont des `?`. Exemple : `SELECT * FROM users WHERE id = ?`."
    },
    {
        "id": 61,
        "chapterId": 3,
        "question": "Que signifie DAO ?",
        "options": [
            "Data Access Object",
            "Direct Access Output",
            "Driver Auto Open",
            "Database Abstract Organization"
        ],
        "answer": 0,
        "explanation": "DAO est un motif de conception (pattern) encapsulant l'accès aux données."
    },
    {
        "id": 62,
        "chapterId": 3,
        "question": "Quelle méthode permet d'obtenir les métadonnées (noms des colonnes...) ?",
        "options": [
            "rs.getMetaData()",
            "con.getInfo()",
            "stmt.getDetails()",
            "System.getMeta()"
        ],
        "answer": 0,
        "explanation": "`ResultSetMetaData` s'obtient via `rs.getMetaData()` et décrit la structure des résultats."
    },
    {
        "id": 63,
        "chapterId": 3,
        "question": "Quelle classe Java correspond au type SQL `DATE` ?",
        "options": [
            "java.util.Date",
            "java.sql.Date",
            "java.time.Instant",
            "String"
        ],
        "answer": 1,
        "explanation": "`java.sql.Date` est le wrapper JDBC standard pour les dates (sans partie heure)."
    },
    {
        "id": 64,
        "chapterId": 3,
        "question": "Pourquoi utiliser `Integer` au lieu de `int` dans une classe entité ?",
        "options": [
            "C'est plus rapide",
            "Pour autoriser la valeur `null`",
            "C'est obligatoire en Java",
            "Pour faire des calculs"
        ],
        "answer": 1,
        "explanation": "Les types primitifs (`int`) ne peuvent pas être null. Les bases de données acceptant NULL, les wrappers (`Integer`) sont préférables."
    },
    {
        "id": 65,
        "chapterId": 3,
        "question": "Si `executeUpdate` retourne 0, cela signifie :",
        "options": [
            "Une erreur SQL",
            "Aucune ligne n'a été affectée",
            "La base est vide",
            "La requête est invalide"
        ],
        "answer": 1,
        "explanation": "Cela signifie que la requête a réussi techniquement, mais qu'elle n'a modifié aucune ligne (ex: UPDATE avec WHERE introuvable)."
    },
    {
        "id": 66,
        "chapterId": 3,
        "question": "Que doit-on faire absolument après avoir utilisé une Connection ?",
        "options": [
            "La laisser ouverte pour gagner du temps",
            "La fermer (`close()`)",
            "La supprimer",
            "Redémarrer le serveur"
        ],
        "answer": 1,
        "explanation": "Les connexions sont des ressources limitées et coûteuses. Il faut les libérer pour éviter les fuites."
    },
    {
        "id": 67,
        "chapterId": 3,
        "question": "Dans le pattern DAO, que contient la classe DAO ?",
        "options": [
            "L'interface graphique",
            "Les requêtes SQL et la gestion de connexion",
            "Les règles CSS",
            "Le code HTML"
        ],
        "answer": 1,
        "explanation": "Le DAO isole la couche persistance. L'UI ne doit pas contenir de SQL."
    },
    {
        "id": 68,
        "chapterId": 3,
        "question": "Quelle méthode permet de passer un entier à un PreparedStatement ?",
        "options": [
            "setId()",
            "putInt()",
            "setInt(index, valeur)",
            "addParam()"
        ],
        "answer": 2,
        "explanation": "On utilise les setters typés comme `setInt`, `setString`, etc. en précisant l'index du `?`."
    },
    {
        "id": 69,
        "chapterId": 3,
        "question": "Comment vérifier si un ResultSet contient encore des lignes ?",
        "options": [
            "rs.hasNext()",
            "rs.next() retourne true",
            "rs.isEmpty()",
            "rs.check()"
        ],
        "answer": 1,
        "explanation": "La méthode `next()` déplace le curseur et indique (boolean) s'il y a une ligne valide à lire."
    },
    {
        "id": 70,
        "chapterId": 3,
        "question": "Dans le modèle SearchVM (ViewModel), si un champ est null :",
        "options": [
            "On plante le programme",
            "On cherche les valeurs NULL en base",
            "On ignore ce critère de recherche",
            "On cherche une chaine vide"
        ],
        "answer": 2,
        "explanation": "C'est une convention courante : un champ null dans un filtre de recherche signifie 'peu importe cette valeur'."
    },
    {
        "id": 71,
        "chapterId": 3,
        "question": "`ResultSet` permet-il de revenir en arrière par défaut ?",
        "options": [
            "Oui, avec previous()",
            "Non, c'est un curseur forward-only par défaut",
            "Oui, toujours",
            "Oui, avec back()"
        ],
        "answer": 1,
        "explanation": "Par défaut, le ResultSet est TYPE_FORWARD_ONLY."
    },
    {
        "id": 72,
        "chapterId": 3,
        "question": "Quel objet contient les données d'une ligne de la table 'Car' ?",
        "options": [
            "L'objet Car (Entité)",
            "L'objet Connection",
            "L'objet Driver",
            "L'objet String"
        ],
        "answer": 0,
        "explanation": "L'entité (Entity) est une classe Java simple (POJO) qui mappe la structure de la table."
    },
    {
        "id": 73,
        "chapterId": 3,
        "question": "Quelle exception principale les méthodes JDBC lèvent-elles ?",
        "options": [
            "IOException",
            "SQLException",
            "DatabaseException",
            "NullPointerException"
        ],
        "answer": 1,
        "explanation": "La quasi-totalité des opérations JDBC déclarent lancer `SQLException` (checked exception)."
    },
    {
        "id": 74,
        "chapterId": 3,
        "question": "Peut-on avoir plusieurs `Statement` ouverts sur une même `Connection` ?",
        "options": [
            "Non, un seul à la fois",
            "Oui, c'est possible",
            "Oui, mais seulement en lecture",
            "Non, risque de crash"
        ],
        "answer": 1,
        "explanation": "Une connexion peut fabriquer plusieurs Statements distincts."
    },
    {
        "id": 75,
        "chapterId": 3,
        "question": "Quelle méthode permet de convertir une date SQL en LocalDate ?",
        "options": [
            "toLocalDate()",
            "getDate()",
            "parse()",
            "convert()"
        ],
        "answer": 0,
        "explanation": "Depuis Java 8, `java.sql.Date` possède la méthode de commodité `toLocalDate()`."
    },
    {
        "id": 76,
        "chapterId": 3,
        "question": "Dans le code `Class.forName('xyz')`, quel est le but du bloc `static` du driver ?",
        "options": [
            "Afficher un message",
            "S'enregistrer auprès du DriverManager",
            "Ouvrir la connexion",
            "Créer la table"
        ],
        "answer": 1,
        "explanation": "Le bloc statique du Driver contient l'appel à `DriverManager.registerDriver(new Driver())`."
    },
    {
        "id": 77,
        "chapterId": 3,
        "question": "Si j'utilise `statement.executeQuery` pour un INSERT, que se passe-t-il ?",
        "options": [
            "Cela fonctionne normalement",
            "Une SQLException est levée",
            "Rien ne se passe",
            "La base est supprimée"
        ],
        "answer": 1,
        "explanation": "L'API JDBC lève souvent une exception si on utilise la mauvaise méthode (bien que certains drivers soient permissifs, la spec dit que executeQuery doit retourner un ResultSet)."
    },
    {
        "id": 78,
        "chapterId": 3,
        "question": "SOLID : Quel principe le DAO respecte-t-il particulièrement ?",
        "options": [
            "Single Responsibility Principle (SRP)",
            "Liskov Substitution",
            "Interface Segregation",
            "None"
        ],
        "answer": 0,
        "explanation": "Le DAO isole la responsabilité de l'accès aux données, laissant la logique métier aux autres classes."
    },
    {
        "id": 79,
        "chapterId": 3,
        "question": "Mapping : Une table 'cars' et une table 'engines' liée. L'entité `Car` aura :",
        "options": [
            "Un champ `int engine_id`",
            "Un champ `Engine engine` (objet)",
            "Rien",
            "Une méthode SQL"
        ],
        "answer": 1,
        "explanation": "En POO, on préfère mapper les relations par des références d'objets (composition) plutôt que par des ID étrangers bruts."
    },
    {
        "id": 80,
        "chapterId": 3,
        "question": "Quel est l'avantage de `PreparedStatement` pour la maintenance ?",
        "options": [
            "Le code est plus court",
            "Il sépare la structure de la requête des données variables, améliorant la lisibilité",
            "Il supprime le besoin de connexion",
            "Il génère du HTML"
        ],
        "answer": 1,
        "explanation": "C'est plus propre que la concaténation de chaînes de caractères."
    },
    {
        "id": 81,
        "chapterId": 3,
        "question": "Comment savoir combien de colonnes contient un ResultSet ?",
        "options": [
            "rs.size()",
            "rs.getMetaData().getColumnCount()",
            "rs.length",
            "rs.count()"
        ],
        "answer": 1,
        "explanation": "Il faut passer par les métadonnées."
    },
    {
        "id": 82,
        "chapterId": 3,
        "question": "Que fait `Statement.execute()` si le résultat est un update count ?",
        "options": [
            "Elle retourne true",
            "Elle retourne false",
            "Elle retourne l'entier",
            "Elle plante"
        ],
        "answer": 1,
        "explanation": "Elle retourne `false` si le résultat n'est PAS un ResultSet."
    },
    {
        "id": 83,
        "chapterId": 3,
        "question": "Quelle est la bonne pratique pour gérer les exceptions JDBC ?",
        "options": [
            "Les ignorer (catch vide)",
            "Utiliser try-with-resources pour fermer automatiquement",
            "Ne pas utiliser de try-catch",
            "Relancer en RuntimeException sans logger"
        ],
        "answer": 1,
        "explanation": "`try(Connection c = ...) { ... }` garantit la fermeture propre des ressources même en cas d'erreur."
    },
    {
        "id": 84,
        "question": "Concernant la mémoire partagée dans un processus Java, quelle affirmation est EXACTE ?",
        "options": [
            "Les threads partagent le Tas (Heap) et la Pile (Stack).",
            "Chaque thread possède son propre Tas, mais partage les variables statiques.",
            "Les threads partagent le Tas et les variables statiques, mais chaque thread a sa propre Pile (Stack).",
            "Tout est partagé, il n'y a aucune isolation mémoire entre threads."
        ],
        "answer": 2,
        "explanation": "Piège classique : Les objets (Heap) sont partagés, mais les variables locales (Stack) sont strictement isolées et propres à chaque thread.",
        "chapterId": 2
    },
    {
        "id": 85,
        "question": "Que se passe-t-il exactement si on exécute `monThread.run()` au lieu de `monThread.start()` ?",
        "options": [
            "Une `IllegalThreadStateException` est levée.",
            "Le code de `run()` s'exécute, mais dans le thread courant (appelant), sans créer de nouveau thread.",
            "Rien ne se passe, la méthode est ignorée.",
            "Le thread démarre normalement."
        ],
        "answer": 1,
        "explanation": "`run()` est une méthode normale. Seul `start()` demande à l'OS de créer un nouveau contexte d'exécution (pile, registres) pour le thread.",
        "chapterId": 2
    },
    {
        "id": 86,
        "question": "Pourquoi l'usage de `Runnable` est-il recommandé par rapport à l'héritage de `Thread` ?",
        "options": [
            "Car `Runnable` possède plus de méthodes que `Thread`.",
            "Car on ne peut pas appeler `start()` sur une sous-classe de `Thread`.",
            "Car Java ne supporte pas l'héritage multiple, donc implémenter `Runnable` laisse la possibilité d'hériter d'une autre classe.",
            "C'est faux, l'héritage est toujours recommandé."
        ],
        "answer": 2,
        "explanation": "C'est une question de design et de limitation du langage. De plus, cela sépare la tâche (Runnable) de l'exécutant (Thread).",
        "chapterId": 2
    },
    {
        "id": 87,
        "question": "Quelle est la différence CRITIQUE entre `Thread.sleep(1000)` et `obj.wait(1000)` concernant les verrous ?",
        "options": [
            "Aucune, les deux mettent en pause.",
            "`sleep` relâche le verrou (moniteur), tandis que `wait` le garde.",
            "`wait` relâche le verrou associé à l'objet, tandis que `sleep` garde tous les verrous acquis.",
            "`sleep` est plus précis que `wait`."
        ],
        "answer": 2,
        "explanation": "C'est le piège le plus fréquent. `sleep` dort 'poings fermés' (garde les verrous), alors que `wait` lâche le verrou pour laisser les autres travailler.",
        "chapterId": 2
    },
    {
        "id": 88,
        "question": "Dans le code `t.join()`, quel thread est bloqué ?",
        "options": [
            "Le thread `t` (il est mis en pause).",
            "Le thread qui appelle la méthode `join()` (souvent le main).",
            "Tous les threads du groupe.",
            "Le thread système."
        ],
        "answer": 1,
        "explanation": "`t.join()` signifie 'Moi, thread appelant, j'attends que t ait fini'. `t` continue sa vie normalement.",
        "chapterId": 2
    },
    {
        "id": 89,
        "question": "Que fait réellement la méthode `t.interrupt()` ?",
        "options": [
            "Elle tue le thread immédiatement (arrêt forcé).",
            "Elle met le thread en pause.",
            "Elle positionne simplement un drapeau (flag) indiquant que l'interruption est demandée. Le thread doit le gérer.",
            "Elle lance une exception dans le thread appelant."
        ],
        "answer": 2,
        "explanation": "L'interruption est coopérative. Si le thread ignore le flag (ou ne gère pas l'exception InterruptedException), il ne s'arrêtera pas.",
        "chapterId": 2
    },
    {
        "id": 90,
        "question": "Si deux threads exécutent deux méthodes `synchronized` DIFFÉRENTES sur la MÊME instance d'objet :",
        "options": [
            "Ils peuvent s'exécuter en parallèle sans problème.",
            "Ils sont bloqués mutuellement, l'un doit attendre la fin de l'autre.",
            "Seule la méthode la plus prioritaire passe.",
            "Cela dépend si les méthodes sont statiques."
        ],
        "answer": 1,
        "explanation": "Le verrou est sur l'objet (`this`). Un seul thread peut détenir le verrou de l'instance, quel que soit le nombre de méthodes synchronized.",
        "chapterId": 2
    },
    {
        "id": 91,
        "question": "Quelle instruction lève une `IllegalMonitorStateException` ?",
        "options": [
            "Appeler `notify()` dans un bloc `synchronized`.",
            "Appeler `wait()` sans détenir le verrou de l'objet (hors bloc synchronized).",
            "Appeler `sleep()` dans un bloc `synchronized`.",
            "Appeler `start()` deux fois."
        ],
        "answer": 1,
        "explanation": "On ne peut attendre (`wait`) ou notifier sur un objet que si on en possède la clé (le moniteur).",
        "chapterId": 2
    },
    {
        "id": 92,
        "question": "Analysez ce code : `t.start(); t.setDaemon(true);`",
        "options": [
            "Le thread devient un démon correctement.",
            "Le thread s'arrête.",
            "Une exception `IllegalThreadStateException` est levée dans le thread appelant.",
            "Le thread est mis en pause."
        ],
        "answer": 2,
        "explanation": "Le statut Daemon doit OBLIGATOIREMENT être défini *avant* le démarrage du thread (`start`).",
        "chapterId": 2
    },
    {
        "id": 93,
        "question": "Que garantit l'appel à `Thread.yield()` ?",
        "options": [
            "Que le thread va s'arrêter pour laisser la place aux autres.",
            "Que le thread va dormir pendant 100ms.",
            "Rien de strict : c'est une simple suggestion au planificateur (scheduler) de passer la main.",
            "Que les threads de priorité inférieure vont s'exécuter."
        ],
        "answer": 2,
        "explanation": "`yield` est une heuristique. L'OS peut choisir de l'ignorer totalement. Ce n'est pas un mécanisme de synchronisation fiable.",
        "chapterId": 2
    },
    {
        "id": 94,
        "question": "Concernant `ThreadGroup.activeCount()`, pourquoi est-ce un 'piège' ?",
        "options": [
            "La méthode retourne toujours 0.",
            "La valeur retournée est une estimation instantanée qui peut être fausse la nanoseconde suivante.",
            "Elle compte aussi les threads arrêtés.",
            "Elle lance une exception."
        ],
        "answer": 1,
        "explanation": "Comme les threads démarrent et meurent en permanence, ce nombre est intrinsèquement imprécis.",
        "chapterId": 2
    },
    {
        "id": 95,
        "question": "Quelle est la règle d'or de Swing avec les Threads ?",
        "options": [
            "Tout code Swing doit être exécuté dans le thread principal (main).",
            "Swing est Thread-Safe, on peut modifier l'UI depuis n'importe où.",
            "Toute modification de l'UI doit se faire exclusivement dans l'EDT (Event Dispatch Thread).",
            "On doit utiliser `synchronized` sur chaque composant Swing."
        ],
        "answer": 2,
        "explanation": "Swing n'est pas Thread-Safe. Modifier un bouton depuis un thread worker peut corrompre l'affichage ou causer des plantages.",
        "chapterId": 2
    },
    {
        "id": 96,
        "question": "Quelle est la différence entre `synchronized void m()` et `static synchronized void m()` ?",
        "options": [
            "Aucune, c'est juste une syntaxe.",
            "La première verrouille l'instance (`this`), la seconde verrouille la classe (`Class object`).",
            "La statique est plus rapide.",
            "La statique empêche l'héritage."
        ],
        "answer": 1,
        "explanation": "Ce sont deux verrous distincts. Un thread peut appeler la méthode d'instance et un autre la méthode statique en même temps sans se bloquer.",
        "chapterId": 2
    },
    {
        "id": 97,
        "question": "Si un thread capture une exception non gérée (RuntimeException) :",
        "options": [
            "Le thread meurt, mais les autres threads continuent leur exécution.",
            "Tout le processus Java (JVM) s'arrête immédiatement.",
            "Le thread redémarre automatiquement.",
            "L'exception est convertie en `InterruptedException`."
        ],
        "answer": 0,
        "explanation": "Une exception non catchée tue le thread concerné. Si ce n'est pas le seul thread user, l'application survit.",
        "chapterId": 2
    },
    {
        "id": 98,
        "question": "Peut-on utiliser `PipedInputStream` sans le connecter à un `PipedOutputStream` ?",
        "options": [
            "Oui, il lira des 0.",
            "Non, cela provoquera une exception ou un blocage.",
            "Oui, il agira comme un ByteArrayInputStream.",
            "Oui, mais seulement en écriture."
        ],
        "answer": 1,
        "explanation": "Les Pipes fonctionnent par paire. Un tube doit avoir deux bouts pour fonctionner.",
        "chapterId": 2
    },
    {
        "id": 99,
        "question": "À quoi correspond `synchronized` dans le monde système POSIX ?",
        "options": [
            "Aux Sémaphores",
            "Aux Pipes",
            "Aux Mutex (Mutual Exclusion)",
            "Aux signaux"
        ],
        "answer": 2,
        "explanation": "Le bloc synchronized agit comme un verrou d'exclusion mutuelle (Mutex) : un seul peut entrer.",
        "chapterId": 2
    },
    {
        "id": 100,
        "question": "Pourquoi `stop()` est-elle dangereuse et dépréciée ?",
        "options": [
            "Elle ne ferme pas les fichiers.",
            "Elle relâche brutalement tous les verrous, laissant les objets dans des états incohérents.",
            "Elle consomme trop de CPU.",
            "Elle ne marche que sur Windows."
        ],
        "answer": 1,
        "explanation": "Si un thread modifiait une liste en 3 étapes et est tué à l'étape 2, la liste est corrompue pour tout le monde.",
        "chapterId": 2
    },
    {
        "id": 101,
        "question": "Un thread 'User' (non-daemon) peut-il empêcher l'application de s'arrêter ?",
        "options": [
            "Non, seul le main compte.",
            "Oui, la JVM ne s'arrête que si tous les threads User sont terminés.",
            "Non, si le main finit, tout finit.",
            "Oui, mais seulement s'il est prioritaire."
        ],
        "answer": 1,
        "explanation": "C'est la différence avec les démons. Un thread User actif maintient la JVM en vie, même si le `main` est fini.",
        "chapterId": 2
    },
    {
        "id": 102,
        "question": "Que retourne `Thread.currentThread().isAlive()` ?",
        "options": [
            "False",
            "Toujours True (puisqu'il exécute cette ligne)",
            "Null",
            "Cela dépend de l'état WAITING"
        ],
        "answer": 1,
        "explanation": "Si le thread est capable d'exécuter du code, c'est qu'il est vivant.",
        "chapterId": 2
    },
    {
        "id": 103,
        "question": "Pour mettre à jour une barre de progression Swing depuis un calcul long, j'utilise :",
        "options": [
            "progressBar.setValue(n) directement.",
            "`SwingUtilities.invokeLater(() -> progressBar.setValue(n))`",
            "Thread.yield()",
            "new Thread(() -> progressBar.setValue(n)).start()"
        ],
        "answer": 1,
        "explanation": "Il faut encapsuler la modification de l'UI dans un Runnable envoyé à l'EDT via `invokeLater`.",
        "chapterId": 2
    },
    {
        "id": 104,
        "question": "Est-il garanti qu'un thread de priorité MAX_PRIORITY s'exécutera avant un MIN_PRIORITY ?",
        "options": [
            "Oui, c'est la norme Java.",
            "Non, la gestion des priorités dépend de l'OS et n'est pas garantie stricte.",
            "Oui, sauf sur Linux.",
            "Non, les priorités sont ignorées par toutes les JVM modernes."
        ],
        "answer": 1,
        "explanation": "C'est une 'indication' d'importance. Sur certains systèmes, cela ne change presque rien. Ne jamais baser la logique du programme dessus.",
        "chapterId": 2
    },
    { "id": 105, "question": "L'interface `Callable` se différencie de `Runnable` car :", "options": ["Elle est statique", "Elle retourne un résultat (Future) et peut lancer une exception", "Elle est plus rapide", "Elle est obsolète"], "answer": 1, "explanation": "`Runnable.run` est void. `Callable.call` retourne `V` et déclare `throws Exception`.", "chapterId": 2 },
    { "id": 106, "question": "Quel risque principal court-on avec l'usage abusif ou mal ordonné de `synchronized` ?", "options": ["Famine (Starvation)", "Deadlock (Interblocage)", "StackOverflow", "NullPointerException"], "answer": 1, "explanation": "Si deux threads attendent chacun le verrou de l'autre, ils se bloquent indéfiniment.", "chapterId": 2 },
    { "id": 107, "question": "Dans un pool de threads, si tous les threads sont occupés et que la file est pleine :", "options": ["La tâche est rejetée (RejectedExecutionException)", "Un nouveau thread est créé (illimité)", "Le thread appelant exécute la tâche (CallerRunsPolicy)", "Cela dépend de la politique de rejet configurée"], "answer": 3, "explanation": "Le `ThreadPoolExecutor` a un `RejectedExecutionHandler`. Par défaut, il lance une exception (`AbortPolicy`).", "chapterId": 2 },
    { "id": 108, "question": "Quelle méthode permet de réveiller un thread en `sleep` ?", "options": ["wake()", "notify()", "interrupt()", "start()"], "answer": 2, "explanation": "`sleep()` lance `InterruptedException` si le thread est interrompu pendant son sommeil.", "chapterId": 2 },
    { "id": 109, "question": "Quelle classe permet d'avoir une variable dont la valeur est propre à chaque thread ?", "options": ["`ThreadLocal`", "`Volatile`", "`AtomicVariable`", "`GlobalVar`"], "answer": 0, "explanation": "`ThreadLocal<T>` fournit un espace de stockage distinct pour chaque thread qui y accède.", "chapterId": 2 },
    { "id": 110, "question": "Quelle structure de données est Thread-Safe par défaut ?", "options": ["`ArrayList`", "`HashMap`", "`Vector`", "`HashSet`"], "answer": 2, "explanation": "`Vector` (et `Hashtable`) sont les anciennes collections synchronisées. `ArrayList` ne l'est pas.", "chapterId": 2 },
    { "id": 111, "question": "Le mot-clé `volatile` garantit :", "options": ["L'atomicité des opérations (ex: ++)", "La visibilité des changements de valeur entre threads immédiatement", "Le verrouillage de l'objet", "La persistance disque"], "answer": 1, "explanation": "`volatile` assure que toute lecture voit la dernière écriture (Happens-Before), mais ne gère pas les conflits d'écriture concurrents (pas d'exclusion mutuelle).", "chapterId": 2 },
    { "id": 112, "question": "Pour attendre qu'un `CountDownLatch` atteigne zéro, on appelle :", "options": ["`wait()`", "`join()`", "`await()`", "`sleep()`"], "answer": 2, "explanation": "`await()` bloque le thread jusqu'à ce que le décompte soit fini.", "chapterId": 2 },
    { "id": 113, "question": "Si le thread `main` se termine, les threads Daemons :", "options": ["Se terminent immédiatement", "Continuent de s'exécuter jusqu'à la fin", "Se mettent en pause", "Lancent une exception"], "answer": 0, "explanation": "La JVM s'arrête s'il ne reste que des Daemons.", "chapterId": 2 },
    { "id": 114, "question": "La méthode `Future.get()` :", "options": ["Est non-bloquante", "Bloque jusqu'à ce que le résultat soit disponible", "Retourne null si pas prêt", "Annule la tâche"], "answer": 1, "explanation": "Elle attend la fin du calcul asynchrone.", "chapterId": 2 },
    { "id": 115, "question": "Quel est l'avantage du verrou `ReentrantLock` sur `synchronized` ?", "options": ["Il est automatique", "Il permet le `tryLock()` (tentative non bloquante) et la gestion de l'équité (fairness)", "Il est plus lent", "Il n'a aucun avantage"], "answer": 1, "explanation": "Il offre plus de contrôle (polling, timeout, interruptible lock waits).", "chapterId": 2 },
    { "id": 116, "question": "`AtomicInteger` utilise-t-il des verrous (locks) ?", "options": ["Oui", "Non, il utilise des instructions CPU CAS (Compare-And-Swap)", "Oui, synchronized", "Non, il est unsafe"], "answer": 1, "explanation": "C'est une opération non-bloquante matérielle, plus performante qu'un verrou complet.", "chapterId": 2 },
    { "id": 117, "question": "L'inanition (Starvation) survient quand :", "options": ["Un thread mange trop de mémoire", "Un thread n'obtient jamais l'accès au CPU/Verrou car d'autres plus prioritaires le monopolisent", "Il y a un Deadlock", "Le programme est vide"], "answer": 1, "explanation": "Contrairement au deadlock (personne ne bouge), ici ça bouge mais certains sont exclus indéfiniment.", "chapterId": 2 },
    { "id": 118, "question": "Que retourne `Runtime.getRuntime().availableProcessors()` ?", "options": ["Le nombre de threads en cours", "Le nombre de cœurs logiques disponibles pour la JVM", "La charge CPU", "La mémoire libre"], "answer": 1, "explanation": "Utile pour dimensionner les ThreadPools.", "chapterId": 2 },
    { "id": 119, "question": "La classe `Semaphore` avec 3 permis permet :", "options": ["À 3 threads d'accéder à la ressource simultanément", "À 1 thread d'accéder 3 fois", "De bloquer 3 threads", "Rien"], "answer": 0, "explanation": "C'est un mécanisme de contrôle de flux pour limiter la concurrence.", "chapterId": 2 },
    { "id": 120, "question": "Le phénomène de 'Spurious Wakeup' impose de :", "options": ["Ne jamais utiliser `wait`", "Utiliser `wait` dans une boucle `while(condition)` et non un `if`", "Augmenter la RAM", "Utiliser `sleep` à la place"], "answer": 1, "explanation": "Un thread peut se réveiller sans raison apparente (niveau OS). Il faut revérifier la condition.", "chapterId": 2 },
    { "id": 121, "question": "Pourquoi `ConcurrentHashMap` est-elle plus performante que `Hashtable` ?", "options": ["Elle n'est pas synchronisée", "Elle utilise un verrouillage par segment (Lock Striping) ou CAS, réduisant la contention", "Elle est en C++", "Elle est plus petite"], "answer": 1, "explanation": "Au lieu de verrouiller toute la map pour chaque opération, elle ne verrouille qu'une partie.", "chapterId": 2 },
    { "id": 122, "question": "La méthode `run()` peut-elle être appelée directement ?", "options": ["Oui, mais cela ne lance pas de thread (exécution synchrone)", "Non, c'est interdit", "Oui, cela lance un thread", "Seulement dans le constructeur"], "answer": 0, "explanation": "C'est une erreur classique. Le code s'exécute, mais dans le thread appelant.", "chapterId": 2 },
    { "id": 123, "question": "Pour exécuter une tâche périodique moderne (post Java 5), on préfère :", "options": ["`Timer`", "`ScheduledExecutorService`", "`Thread.sleep` en boucle", "`Cron`"], "answer": 1, "explanation": "`ScheduledExecutorService` est plus robuste (gère mieux les exceptions et le multi-threading) que `Timer`.", "chapterId": 2 },
    {
        "id": 124,
        "chapterId": 4,
        "question": "Combien de couches comporte le modèle utilisé dans ce cours (TCP/IP simplifié) ?",
        "options": [
            "7 couches (OSI)",
            "4 couches (Application, Transport, Internet, Hôte-Réseau)",
            "5 couches",
            "3 couches"
        ],
        "answer": 1,
        "explanation": "Le modèle TCP/IP simplifié présenté comporte 4 couches : Application, Transport, Internet, Hôte-Réseau."
    },
    {
        "id": 125,
        "chapterId": 4,
        "question": "Quelle est la différence fondamentale entre TCP et UDP concernant la connexion ?",
        "options": [
            "TCP est non connecté, UDP est connecté",
            "TCP est orienté connexion (Handshake), UDP est non connecté",
            "Les deux sont connectés",
            "Aucun n'est connecté"
        ],
        "answer": 1,
        "explanation": "TCP nécessite l'établissement d'une connexion (Handshake) avant d'envoyer des données, contrairement à UDP."
    },
    {
        "id": 126,
        "chapterId": 4,
        "question": "Sur combien de bits est codé un numéro de port ?",
        "options": [
            "8 bits",
            "16 bits",
            "32 bits",
            "64 bits"
        ],
        "answer": 1,
        "explanation": "Un port est un entier non signé de 16 bits, allant de 0 à 65535."
    },
    {
        "id": 127,
        "chapterId": 4,
        "question": "Comment appelle-t-on l'association unique {Adresse IP + Port} ?",
        "options": [
            "Un Packet",
            "Une Socket",
            "Un Thread",
            "Un Stream"
        ],
        "answer": 1,
        "explanation": "Une socket est définie par ce couple qui permet d'identifier un processus spécifique sur une machine spécifique."
    },
    {
        "id": 128,
        "chapterId": 4,
        "question": "Peut-on instancier `InetAddress` via `new InetAddress()` ?",
        "options": [
            "Oui, c'est la méthode standard",
            "Non, elle n'a pas de constructeur public",
            "Oui, mais c'est déprécié",
            "Seulement pour IPv6"
        ],
        "answer": 1,
        "explanation": "`InetAddress` utilise des méthodes de fabrique statiques (Factory Methods) comme `getLocalHost` ou `getByName`."
    },
    {
        "id": 129,
        "chapterId": 4,
        "question": "Quelle méthode permet d'obtenir l'adresse IP d'un nom de domaine (ex: www.google.com) ?",
        "options": [
            "InetAddress.create()",
            "InetAddress.getByName()",
            "DNS.resolve()",
            "Server.find()"
        ],
        "answer": 1,
        "explanation": "`InetAddress.getByName(\"...\")` effectue la résolution DNS pour retourner l'objet adresse correspondant."
    },
    {
        "id": 130,
        "chapterId": 4,
        "question": "Quelle exception est levée si `InetAddress.getByName` ne trouve pas l'hôte ?",
        "options": [
            "IOException",
            "SocketException",
            "UnknownHostException",
            "NullPointerException"
        ],
        "answer": 2,
        "explanation": "Si le DNS ne parvient pas à résoudre le nom, une `UnknownHostException` est levée."
    },
    {
        "id": 131,
        "chapterId": 4,
        "question": "Quel objet Java sert à ATTENDRE les connexions des clients (côté serveur) ?",
        "options": [
            "Socket",
            "ServerSocket",
            "ClientSocket",
            "ConnectionFactory"
        ],
        "answer": 1,
        "explanation": "`ServerSocket` est la classe dédiée à l'écoute d'un port et à l'acceptation des connexions entrantes."
    },
    {
        "id": 132,
        "chapterId": 4,
        "question": "Par défaut, quelle est la taille de la file d'attente (backlog) d'un `ServerSocket` ?",
        "options": [
            "10",
            "50",
            "100",
            "Illimitée"
        ],
        "answer": 1,
        "explanation": "Si on ne spécifie pas le second argument du constructeur, la file des connexions en attente est limitée à 50 par défaut."
    },
    {
        "id": 133,
        "chapterId": 4,
        "question": "La méthode `accept()` de `ServerSocket` est-elle bloquante ?",
        "options": [
            "Non, elle retourne null immédiatement si personne n'est là",
            "Oui, elle bloque jusqu'à ce qu'un client se connecte (ou timeout)",
            "Oui, mais maximum 1 seconde",
            "Non, elle lance un thread"
        ],
        "answer": 1,
        "explanation": "`accept()` met le thread en pause jusqu'à l'arrivée d'une connexion. C'est un appel bloquant."
    },
    {
        "id": 134,
        "chapterId": 4,
        "question": "Que retourne la méthode `ServerSocket.accept()` ?",
        "options": [
            "Un boolean",
            "Une adresse IP",
            "Un objet `Socket` permettant de communiquer avec le client",
            "Un entier"
        ],
        "answer": 2,
        "explanation": "Elle retourne une `Socket` de service dédiée à la communication avec le client qui vient d'arriver."
    },
    {
        "id": 135,
        "chapterId": 4,
        "question": "Quelle exception survient si `new Socket(host, port)` n'arrive pas à se connecter ?",
        "options": [
            "NoRouteToHostException",
            "ConnectException",
            "BindException",
            "InterruptException"
        ],
        "answer": 1,
        "explanation": "`ConnectException` indique que le serveur est éteint ou inaccessible sur ce port (Connection refused)."
    },
    {
        "id": 136,
        "chapterId": 4,
        "question": "Pour envoyer des objets Java sur le réseau, quelle classe utilise-t-on ?",
        "options": [
            "DataOutputStream",
            "ObjectOutputStream",
            "BufferedOutputStream",
            "PrintStream"
        ],
        "answer": 1,
        "explanation": "`ObjectOutputStream` permet de sérialiser des objets Java dans le flux."
    },
    {
        "id": 137,
        "chapterId": 4,
        "question": "Quelle interface doit implémenter une classe pour être envoyée via `ObjectOutputStream` ?",
        "options": [
            "Cloneable",
            "Runnable",
            "Serializable",
            "Remote"
        ],
        "answer": 2,
        "explanation": "L'interface marqueur `java.io.Serializable` est obligatoire pour la sérialisation."
    },
    {
        "id": 138,
        "chapterId": 4,
        "question": "Si j'utilise `BufferedWriter` sans faire `flush()`, que se passe-t-il ?",
        "options": [
            "Les données sont envoyées instantanément",
            "Les données restent dans le tampon et ne partent pas sur le réseau",
            "Une exception est levée",
            "Le socket se ferme"
        ],
        "answer": 1,
        "explanation": "Les flux bufférisés gardent les données en mémoire pour optimiser. `flush()` force l'envoi physique."
    },
    {
        "id": 139,
        "chapterId": 4,
        "question": "Lors d'une communication Java <-> C, peut-on utiliser la sérialisation Java ?",
        "options": [
            "Oui, le C comprend le Java",
            "Non, il faut échanger des octets bruts (Bytes) ou du texte standard",
            "Oui avec un plugin",
            "Oui si la classe est Serializable en C"
        ],
        "answer": 1,
        "explanation": "La sérialisation Java est un format binaire spécifique à la JVM. Le C ne sait pas le lire nativement."
    },
    {
        "id": 140,
        "chapterId": 4,
        "question": "En TCP (flux continu), comment délimiter la fin d'un message textuel ?",
        "options": [
            "C'est automatique",
            "On utilise un caractère de fin (ex: fin de ligne ou $%) ou un entête de taille",
            "On ferme la socket après chaque mot",
            "On attend 1 seconde"
        ],
        "answer": 1,
        "explanation": "Comme c'est un flux (tuyau), il n'y a pas de notion de 'paquet' visible. Il faut définir un protocole de délimitation."
    },
    {
        "id": 141,
        "chapterId": 4,
        "question": "Dans le modèle 'Serveur Multi-Threads à la demande', que fait-on à chaque connexion ?",
        "options": [
            "On traite la requête dans le thread principal",
            "On crée un nouveau Thread dédié au client",
            "On refuse le client",
            "On met le client en attente"
        ],
        "answer": 1,
        "explanation": "Chaque `accept()` est suivi d'un `new ThreadClient(socket).start()`."
    },
    {
        "id": 142,
        "chapterId": 4,
        "question": "Quel est le risque principal du modèle 'Thread à la demande' ?",
        "options": [
            "C'est lent",
            "Saturation mémoire (DoS) si trop de clients arrivent simultanément",
            "C'est trop complexe",
            "Les données se mélangent"
        ],
        "answer": 1,
        "explanation": "Créer un thread par client consomme des ressources. Une attaque massive peut faire crasher le serveur."
    },
    {
        "id": 143,
        "chapterId": 4,
        "question": "Dans le modèle 'Pool de Threads', que fait le ThreadServeur ?",
        "options": [
            "Il traite les clients",
            "Il crée des threads",
            "Il récupère la socket et la dépose dans une File d'Attente",
            "Il ne fait rien"
        ],
        "answer": 2,
        "explanation": "Le ThreadServeur ne fait que `accept()` et `queue.add(socket)`. Ce sont les threads du pool qui consomment la file."
    },
    {
        "id": 144,
        "chapterId": 4,
        "question": "Que se passe-t-il si un Thread du pool veut prendre une connexion mais que la file est vide ?",
        "options": [
            "Il s'arrête",
            "Il se met en attente (wait) jusqu'à ce qu'une connexion arrive",
            "Il lance une exception",
            "Il crée une fausse connexion"
        ],
        "answer": 1,
        "explanation": "C'est le principe Producteur/Consommateur bloquant. `getConnexion()` utilise `wait()`."
    },
    {
        "id": 145,
        "chapterId": 4,
        "question": "Pourquoi utiliser `notify()` (et pas `notifyAll`) dans le pool de threads ?",
        "options": [
            "C'est obligatoire",
            "Car une seule socket ne peut être traitée que par UN seul thread",
            "Car `notifyAll` est déprécié",
            "Pour économiser de la batterie"
        ],
        "answer": 1,
        "explanation": "Lorsqu'on ajoute UNE socket, inutile de réveiller tous les threads, un seul pourra la prendre."
    },
    {
        "id": 146,
        "chapterId": 4,
        "question": "Que se passe-t-il si on fait `socket.accept()` dans le thread de l'interface graphique (EDT) ?",
        "options": [
            "Tout fonctionne bien",
            "L'interface graphique gèle (freeze) jusqu'à la connexion d'un client",
            "Une exception swing est lancée",
            "La fenêtre change de couleur"
        ],
        "answer": 1,
        "explanation": "L'appel étant bloquant, l'EDT ne peut plus redessiner la fenêtre ni gérer les clics."
    },
    {
        "id": 147,
        "chapterId": 4,
        "question": "Comment le Serveur doit-il communiquer avec l'interface graphique Swing ?",
        "options": [
            "En modifiant directement les composants JTable/JLabel",
            "Via une interface Logger (ou callback) utilisant `invokeLater`",
            "Par télépathie",
            "En écrivant dans un fichier texte"
        ],
        "answer": 1,
        "explanation": "Le serveur ne doit pas toucher au GUI directement. Il passe par une abstraction (Logger) qui redirige vers l'EDT."
    },
    {
        "id": 148,
        "chapterId": 4,
        "question": "À quoi sert la classe `DataInputStream` ?",
        "options": [
            "À lire des objets",
            "À lire des types primitifs (int, double, boolean) de manière portable",
            "À lire des fichiers MP3",
            "À lire des images"
        ],
        "answer": 1,
        "explanation": "Elle permet de lire des données binaires (comme `readInt`) encodées de manière indépendante de la plateforme."
    },
    {
        "id": 149,
        "chapterId": 4,
        "question": "Si j'écris `writeInt(42)`, que dois-je appeler en face ?",
        "options": [
            "readDouble()",
            "readByte()",
            "readInt()",
            "readString()"
        ],
        "answer": 2,
        "explanation": "L'ordre et le type de lecture doivent correspondre exactement à l'écriture."
    },
    {
        "id": 150,
        "chapterId": 4,
        "question": "Quelle méthode active le timeout sur une Socket ?",
        "options": [
            "setTimeout()",
            "setSoTimeout()",
            "waitTimeout()",
            "limitTime()"
        ],
        "answer": 1,
        "explanation": "`setSoTimeout(int ms)` définit le temps max d'attente pour `read()` ou `accept()`."
    },
    {
        "id": 151,
        "chapterId": 4,
        "question": "Quel port est généralement associé au protocole HTTP ?",
        "options": [
            "21",
            "25",
            "80",
            "443"
        ],
        "answer": 2,
        "explanation": "Le port standard pour le web non sécurisé est 80. (443 pour HTTPS)."
    },
    {
        "id": 152,
        "chapterId": 4,
        "question": "Un thread démon (Daemon) empêche-t-il la JVM de s'arrêter ?",
        "options": [
            "Oui",
            "Non, la JVM s'arrête s'il ne reste que des Daemons",
            "Cela dépend de sa priorité",
            "Oui s'il est en boucle infinie"
        ],
        "answer": 1,
        "explanation": "Les threads démons sont des threads de service qui sont tués automatiquement à la fin des threads utilisateurs."
    },
    {
        "id": 153,
        "chapterId": 4,
        "question": "Dans l'architecture proposée, à quoi sert l'interface `Protocole` ?",
        "options": [
            "À définir TCP ou UDP",
            "À isoler la logique métier (traiteRequete) du code réseau",
            "À crypter les données",
            "À connecter la base de données"
        ],
        "answer": 1,
        "explanation": "Elle permet de changer le comportement du serveur (ex: Chat, Calcul, Login) sans toucher au code du serveur lui-même."
    },
    {
        "id": 154,
        "chapterId": 4,
        "question": "Qu'est-ce que `InetAddress.getLocalHost()` retourne ?",
        "options": [
            "L'adresse 127.0.0.1 (localhost)",
            "L'adresse IP réelle de la machine sur le réseau (avec son nom d'hôte)",
            "L'adresse du serveur Google",
            "Null"
        ],
        "answer": 1,
        "explanation": "Elle interroge le système pour obtenir l'IP de la carte réseau principale."
    },
    {
        "id": 155,
        "chapterId": 4,
        "question": "Pourquoi mettre `ObjectOutputStream` avant `ObjectInputStream` à la création ?",
        "options": [
            "Pour éviter un blocage (deadlock) lors de l'envoi de l'en-tête de sérialisation",
            "C'est une convention esthétique",
            "Cela n'a aucune importance",
            "Pour aller plus vite"
        ],
        "answer": 0,
        "explanation": "`new ObjectOutputStream` écrit un header immédiatement. Si les deux côtés font `new ObjectInputStream` en premier, ils attendent tous les deux un header qui n'arrive jamais."
    },
    {
        "id": 156,
        "chapterId": 4,
        "question": "Quelle classe permet de lire des lignes de texte entières ?",
        "options": [
            "FileReader",
            "BufferedReader",
            "LineReader",
            "TextInputStream"
        ],
        "answer": 1,
        "explanation": "`BufferedReader` possède la méthode `readLine()` très pratique pour le texte."
    },
    {
        "id": 157,
        "chapterId": 4,
        "question": "Dans le modèle OSI, quelle couche manque dans le modèle 4 couches ?",
        "options": [
            "Application",
            "Transport",
            "Présentation (et Session)",
            "Réseau"
        ],
        "answer": 2,
        "explanation": "Le modèle TCP/IP regroupe Session, Présentation et Application en une seule couche 'Application'."
    },
    {
        "id": 158,
        "chapterId": 4,
        "question": "Quand on sérialise un objet, ses champs `transient` sont-ils envoyés ?",
        "options": [
            "Oui",
            "Non, ils sont ignorés",
            "Seulement s'ils sont publics",
            "Oui mais chiffrés"
        ],
        "answer": 1,
        "explanation": "Le mot-clé `transient` sert justement à exclure un champ de la sérialisation."
    },
    {
        "id": 159,
        "chapterId": 4,
        "question": "La méthode `getAddress()` de `InetAddress` retourne des octets. Quelle est leur particularité en Java ?",
        "options": [
            "Ils sont non signés (0..255)",
            "Ils sont signés (-128..127)",
            "Ce sont des int",
            "Ce sont des char"
        ],
        "answer": 1,
        "explanation": "En Java, le type `byte` est signé. Il faut faire attention lors de l'affichage (souvent `b & 0xFF` pour retrouver 0-255)."
    },
    {
        "id": 160,
        "chapterId": 4,
        "question": "Quel composant Swing est utilisé dans l'exemple LILOC pour afficher les logs ?",
        "options": [
            "JTable",
            "JLabel",
            "JButton",
            "JFrame"
        ],
        "answer": 0,
        "explanation": "L'exemple du cours utilise une `JTable` (modèle `LogTableModel`) pour lister les traces du serveur."
    },
    {
        "id": 161,
        "chapterId": 4,
        "question": "Comment le serveur sait-il qu'un client C a fini son message ?",
        "options": [
            "Grâce à la fin de l'objet Java",
            "Grâce à un caractère délimiteur (ex: $) ou une taille en entête",
            "Il devine",
            "Le client ferme la connexion"
        ],
        "answer": 1,
        "explanation": "En communication bas niveau, c'est au protocole applicatif de définir la structure (Header+Body ou Delimiter)."
    },
    {
        "id": 162,
        "chapterId": 4,
        "question": "Dans un `catch(IOException e)`, que doit-on faire de la socket ?",
        "options": [
            "La laisser ouverte",
            "La fermer proprement (socket.close())",
            "La relancer",
            "Rien"
        ],
        "answer": 1,
        "explanation": "En cas d'erreur de communication, il faut libérer les ressources en fermant la socket."
    },
    {
        "id": 163,
        "chapterId": 4,
        "question": "Une `Socket` est :",
        "options": [
            "Un fichier physique",
            "Une abstraction logicielle représentant une connexion réseau",
            "Une carte mère",
            "Un pilote"
        ],
        "answer": 1,
        "explanation": "C'est l'interface de programmation (API) vers la couche Transport TCP."
    }
]