[
    {
        "id": 1,
        "question": "Qu'est-ce qu'une socket ?",
        "options": [
            "Un câble physique",
            "Un point de communication bidirectionnel",
            "Un type de variable en C",
            "Un protocole Internet"
        ],
        "answer": 1,
        "explanation": "Une socket est un point de communication (endpoint) permettant l'échange de données entre processus."
    },
    {
        "id": 2,
        "question": "Quel mode de communication le protocole TCP utilise-t-il ?",
        "options": [
            "Mode non connecté (datagramme)",
            "Mode déconnecté",
            "Mode connecté (stream)",
            "Mode aléatoire"
        ],
        "answer": 2,
        "explanation": "TCP (Transmission Control Protocol) utilise le mode connecté (SOCK_STREAM), garantissant fiabilité et ordre."
    },
    {
        "id": 3,
        "question": "Quel couple identifie de manière unique une socket en mode connecté ?",
        "options": [
            "{Adresse MAC, Port}",
            "{Adresse IP, Protocole}",
            "{Adresse IP, Port}",
            "{Nom d'hôte, Adresse IP}"
        ],
        "answer": 2,
        "explanation": "En mode connecté, une socket est identifiée par le couple unique {Adresse IP, Port}."
    },
    {
        "id": 4,
        "question": "Quelle primitive crée une socket ?",
        "options": [
            "make_socket()",
            "create()",
            "open()",
            "socket()"
        ],
        "answer": 3,
        "explanation": "La fonction `socket()` est l'appel système permettant de créer une nouvelle socket."
    },
    {
        "id": 5,
        "question": "Quel paramètre de `socket()` spécifie IPv4 ?",
        "options": [
            "AF_INET6",
            "AF_UNIX",
            "AF_INET",
            "SOCK_INET"
        ],
        "answer": 2,
        "explanation": "`AF_INET` est la famille d'adresses correspondant aux adresses Internet IPv4."
    },
    {
        "id": 6,
        "question": "Quel type de socket correspond au mode UDP ?",
        "options": [
            "SOCK_STREAM",
            "SOCK_RAW",
            "SOCK_DGRAM",
            "SOCK_PACKET"
        ],
        "answer": 2,
        "explanation": "`SOCK_DGRAM` (Datagram) est utilisé pour le mode non connecté (UDP)."
    },
    {
        "id": 7,
        "question": "Que retourne `socket()` en cas d'erreur ?",
        "options": [
            "0",
            "NULL",
            "-1",
            "false"
        ],
        "answer": 2,
        "explanation": "La fonction retourne -1 en cas d'erreur et met à jour la variable globale `errno`."
    },
    {
        "id": 8,
        "question": "Après création par `socket()`, l'état initial de la socket est :",
        "options": [
            "Connectée",
            "Liée à un port 80",
            "Anonyme (ni IP ni port)",
            "En écoute"
        ],
        "answer": 2,
        "explanation": "Juste après `socket()`, la socket existe mais n'est attachée à aucune adresse ni port (elle est anonyme)."
    },
    {
        "id": 9,
        "question": "Quelle fonction associe une socket à une adresse IP et un port ?",
        "options": [
            "connect()",
            "link()",
            "bind()",
            "listen()"
        ],
        "answer": 2,
        "explanation": "`bind()` est utilisée pour 'lier' la socket à une adresse locale spécifique."
    },
    {
        "id": 10,
        "question": "Qui doit OBLIGATOIREMENT utiliser `bind()` ?",
        "options": [
            "Le Client",
            "Le Serveur",
            "Les deux",
            "Aucun des deux"
        ],
        "answer": 1,
        "explanation": "Le serveur doit utiliser `bind()` pour être joignable sur un port connu. Le client peut laisser le système choisir."
    },
    {
        "id": 11,
        "question": "Quelle structure C contient l'adresse IPv4 d'une socket ?",
        "options": [
            "struct sockaddr_un",
            "struct in_addr",
            "struct sockaddr_in",
            "struct ip_addr"
        ],
        "answer": 2,
        "explanation": "`struct sockaddr_in` est la structure spécifique pour les adresses IPv4 (famille AF_INET)."
    },
    {
        "id": 12,
        "question": "Quel est le rôle du DNS ?",
        "options": [
            "Sécuriser la connexion",
            "Traduire un nom d'hôte en adresse IP",
            "Compresser les données",
            "Gérer les erreurs réseaux"
        ],
        "answer": 1,
        "explanation": "Le DNS (Domain Name System) permet de faire correspondre un nom d'hôte convivial à une adresse IP numérique."
    },
    {
        "id": 13,
        "question": "La fonction `listen(sockfd, count)` :",
        "options": [
            "Accepte une connexion immédiatement",
            "Attend des données",
            "Finit la connexion",
            "Met la socket en mode passif (attente)"
        ],
        "answer": 3,
        "explanation": "`listen()` indique au noyau d'accepter les demandes de connexion entrantes sur cette socket."
    },
    {
        "id": 14,
        "question": "Que représente le paramètre 'count' (ou backlog) dans `listen()` ?",
        "options": [
            "Le nombre maximum de sockets créables",
            "Le nombre maximum de connexions actives",
            "La taille de la file d'attente des connexions pendantes",
            "Le délai d'attente avant timeout"
        ],
        "answer": 2,
        "explanation": "Le backlog spécifie combien de connexions peuvent être en attente d'acceptation (handshake terminé mais pas encore accept()) avant d'être rejetées."
    },
    {
        "id": 15,
        "question": "Quelle erreur survient si on tente un `bind()` sur un port déjà pris ?",
        "options": [
            "ENOMEM",
            "EADDRNOTAVAIL",
            "EADDRINUSE",
            "ECONNREFUSED"
        ],
        "answer": 2,
        "explanation": "`EADDRINUSE` signifie que l'adresse (IP/Port) est déjà utilisée par une autre socket."
    },
    {
        "id": 16,
        "question": "Quelle fonction permet au CLIENT d'initier le handshake TCP ?",
        "options": [
            "accept()",
            "dial()",
            "connect()",
            "init()"
        ],
        "answer": 2,
        "explanation": "`connect()` lance la procédure d'établissement de connexion vers le serveur."
    },
    {
        "id": 17,
        "question": "Si un client n'appelle pas `bind()`, que se passe-t-il ?",
        "options": [
            "Erreur à la compilation",
            "Erreur à l'exécution",
            "Le noyau attribue une IP et un port éphémère",
            "Le client utilise le port 0 par défaut"
        ],
        "answer": 2,
        "explanation": "C'est le 'bind implicite'. Le système alloue automatiquement un port libre lorsque `connect()` est appelé."
    },
    {
        "id": 18,
        "question": "Les fonctions `send` et `recv` avec flags=0 sont équivalentes à :",
        "options": [
            "printf et scanf",
            "write et read",
            "put et get",
            "sendto et recvfrom"
        ],
        "answer": 1,
        "explanation": "Sous Unix, écrire sur une socket connectée revient à écrire dans un descripteur de fichier via `write`."
    },
    {
        "id": 19,
        "question": "Quelle primitive est bloquante par défaut ?",
        "options": [
            "socket()",
            "bind()",
            "listen()",
            "connect()"
        ],
        "answer": 3,
        "explanation": "`connect()` bloque le processus jusqu'à ce que la connexion soit établie ou échoue (timeout/refus)."
    },
    {
        "id": 20,
        "question": "Pourquoi faut-il fermer une socket avec `close()` ?",
        "options": [
            "Pour éteindre l'ordinateur",
            "Pour libérer le descripteur et les ressources noyau",
            "Pour envoyer les dernières données",
            "Ce n'est pas nécessaire"
        ],
        "answer": 1,
        "explanation": "Il faut libérer les ressources. Une socket non fermée peut laisser un port en état 'bloqué' (CLOSE_WAIT, etc.)."
    },
    {
        "id": 21,
        "question": "Analysez ce code. Que fait-il ?",
        "code": "int s = socket(AF_INET, SOCK_STREAM, 0);",
        "options": [
            "Crée une socket UDP IPv4",
            "Crée une socket TCP IPv6",
            "Crée une socket TCP IPv4",
            "Crée une socket brute (RAW)"
        ],
        "answer": 2,
        "explanation": "AF_INET = IPv4, SOCK_STREAM = TCP. Le 0 indique le protocole par défaut (TCP)."
    },
    {
        "id": 22,
        "question": "Trouvez l'erreur dans ce code serveur :",
        "code": "bind(sd, (struct sockaddr *)&addr, sizeof(addr));\n// Manque quelque chose ici...\naccept(sd, NULL, NULL);",
        "options": [
            "Il manque socket()",
            "Il manque connect()",
            "Il manque listen()",
            "Il manque close()"
        ],
        "answer": 2,
        "explanation": "Entre `bind` (attacher l'adresse) et `accept` (accepter les clients), il faut impérativement appeler `listen()` pour passer en mode passif."
    },
    {
        "id": 23,
        "question": "Que signifie un retour de -1 sur cet appel ?",
        "code": "if (connect(sockfd, &addr, len) == -1) { ... }",
        "options": [
            "La connexion est établie",
            "La connexion a échoué",
            "La socket est fermée",
            "Le serveur est en attente"
        ],
        "answer": 1,
        "explanation": "Comme la plupart des appels système Unix, -1 signale une erreur (serveur éteint, réseau coupé, etc.)."
    },
    {
        "id": 24,
        "question": "Ce code est-il valide pour envoyer une structure ?",
        "code": "struct Data d = {1, 2};\nsend(sock, &d, sizeof(d), 0);",
        "options": [
            "Non, on ne peut envoyer que des chaînes",
            "Oui, mais attention à l'endianness (ordre des octets)",
            "Non, sizeof() ne marche pas sur les structures",
            "Oui, c'est parfaitement portable tel quel"
        ],
        "answer": 1,
        "explanation": "C'est syntaxiquement valide en C (envoi d'octets bruts), mais risqué entre architectures différentes si on ne gère pas l'endianness (ntohl/htonl)."
    },
    {
        "id": 25,
        "question": "Dans quel état finit une socket si le serveur ferme mais pas le client ?",
        "code": "// Serveur fait close(s)\n// Client ne fait rien",
        "options": [
            "ESTABLISHED",
            "CLOSE_WAIT (côté Client)",
            "LISTEN",
            "CLOSED"
        ],
        "answer": 1,
        "explanation": "Le client reçoit un FIN, l'OS passe sa socket en CLOSE_WAIT, attendant que l'application cliente appelle `close()` explicitement."
    },
    {
        "id": 26,
        "question": "Quelle constante définit le backlog maximum possible ?",
        "code": "listen(sockfd, SOMAXCONN);",
        "options": [
            "MAX_CONN",
            "TCP_MAX",
            "SOMAXCONN",
            "LIMIT_BACKLOG"
        ],
        "answer": 2,
        "explanation": "`SOMAXCONN` est la constante système définissant la limite supérieure de la file d'attente."
    },
    {
        "id": 27,
        "question": "Que fait ce bout de code ?",
        "code": "struct sockaddr_in addr;\naddr.sin_family = AF_INET;\naddr.sin_port = htons(8080);\naddr.sin_addr.s_addr = INADDR_ANY;",
        "options": [
            "Prépare une adresse pour se connecter à Google",
            "Prépare une adresse serveur écoutant sur toutes les interfaces locales",
            "Crée une nouvelle socket",
            "Configure un client UDP"
        ],
        "answer": 1,
        "explanation": "`INADDR_ANY` signifie que le serveur acceptera les connexions venant de n'importe quelle interface réseau de la machine (Wifi, Ethernet, Localhost...)."
    },
    {
        "id": 28,
        "question": "Pourquoi utilise-t-on `htons(8080)` ?",
        "code": "addr.sin_port = htons(8080);",
        "options": [
            "Pour crypter le port",
            "Pour convertir 8080 en string",
            "Pour convertir l'entier du format Hôte vers Réseau (Big Endian)",
            "C'est une fonction d'affichage"
        ],
        "answer": 2,
        "explanation": "`htons` = Host TO Network Short. Le réseau utilise le Big Endian, alors que les PC x86 utilisent le Little Endian."
    },
    {
        "id": 29,
        "question": "Quel est le problème potentiel ici ?",
        "code": "char buf[10];\nrecv(s, buf, 100, 0);",
        "options": [
            "Aucun problème",
            "Buffer overflow (débordement de tampon)",
            "Erreur de syntaxe",
            "La socket va se fermer"
        ],
        "answer": 1,
        "explanation": "On demande de lire jusqu'à 100 octets dans un buffer qui ne peut en contenir que 10. Risque critique de corruption mémoire."
    },
    {
        "id": 30,
        "question": "Quelle fonction permet de récupérer l'adresse IP d'un client qui vient de se connecter ?",
        "code": "int client_sock = accept(srv_sock, ...);",
        "options": [
            "getpeername() (ou via les arguments de accept)",
            "getsockname()",
            "ipconfig()",
            "whoami()"
        ],
        "answer": 0,
        "explanation": "Les arguments pointeurs de `accept()` (struct sockaddr *) ou la fonction `getpeername()` permettent d'obtenir l'IP et le port du client distant."
    }
]